\documentclass[12pt]{cpa2018}
% To produce camera-ready copy with no running headers, etc., add the
% "crc" option above (i.e. \documentclass[12pt,crc]{...}).
%
% Authors: please ignore the above!  It's a note only for editors.
\usepackage{cpalistings}
% \lstloadlanguages{Python}

\usepackage[outputdir=.tmp]{minted}
% \usepackage[cache=false]{minted}
\setminted{frame=lines,linenos,framesep=2mm,fontsize=\small}

\usepackage{times}

\usepackage{amsmath}
\usepackage{amssymb}
\normalfont
%\usepackage[T1]{fontenc}
\renewcommand{\ttdefault}{cmtt}
\usepackage{xcolor}
\usepackage{booktabs, caption, siunitx}

\usepackage{url}
\usepackage{pgfplots}
\usepackage{tikz}


\usepackage[labelsep=period]{caption}

\usetikzlibrary{calc}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}
\usepgfplotslibrary{units}
\pgfplotsset{compat=newest}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}

\usepackage{ifthen}
\pgfkeys{
  /sevenseg/.is family, /sevenseg,
  slant/.estore in      = \sevensegSlant,     % vertical slant in degrees
  size/.estore in       = \sevensegSize,      % length of a segment
  shrink/.estore in     = \sevensegShrink,    % avoids overlapping of segments
  line width/.estore in = \sevensegLinewidth, % thickness of the segments
  line cap/.estore in   = \sevensegLinecap,   % end cap style rect, round, butt
  oncolor/.estore in    = \sevensegOncolor,   % color of an ON segment
  offcolor/.estore in   = \sevensegOffcolor,  % color of an OFF segment
}

\pgfkeys{
  /sevenseg,
  default/.style={
    slant = 0,
    size = 1em,
    shrink = 0.2,
    line width = 0.3em,
    line cap = butt,
    oncolor = green!50!black,
    offcolor = white!75!black
  }
}
\newcommand{\sevenseg}[2][]% options values
{%
\pgfkeys{/sevenseg, default, #1}%
\def\sevensegarray{#2}%
  \begin{tikzpicture}%
    % first define the position of the 6 corner points
    \path (0,0) ++(0,0)                             coordinate (P1);
    \path (0,0) ++(\sevensegSize,0)                 coordinate (P2);
    \path (0,0) ++(90-\sevensegSlant:\sevensegSize) coordinate (P3);
    \path (P2)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P4);
    \path (P3)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P5);
    \path (P4)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P6);
    % then step through the 1/0 values in the segment array
    \foreach \i in {0,...,6}%
    {
      \pgfmathparse{\sevensegarray[\i]}
      \ifthenelse{\equal{\pgfmathresult}{1}}%
        {\let\mycolor=\sevensegOncolor}%  segment is on
        {\let\mycolor=\sevensegOffcolor}% segment is off
      \tikzstyle{segstyle} = [draw=\mycolor, line width = \sevensegLinewidth,
                              line cap = \sevensegLinecap]
      %-----------------------
      \ifthenelse{\equal{\i}{0}}{\path[segstyle]
        (${1-\sevensegShrink}*(P5)+\sevensegShrink*(P6)$)
        -- ($\sevensegShrink*(P5)+{1-\sevensegShrink}*(P6)$);}{} % a
      \ifthenelse{\equal{\i}{1}}{\path[segstyle]
        (${1-\sevensegShrink}*(P6)+\sevensegShrink*(P4)$)
        -- ($\sevensegShrink*(P6)+{1-\sevensegShrink}*(P4)$);}{} % b
      \ifthenelse{\equal{\i}{2}}{\path[segstyle]
        (${1-\sevensegShrink}*(P4)+\sevensegShrink*(P2)$)
        -- ($\sevensegShrink*(P4)+{1-\sevensegShrink}*(P2)$);}{} % c
      \ifthenelse{\equal{\i}{3}}{\path[segstyle]
        (${1-\sevensegShrink}*(P1)+\sevensegShrink*(P2)$)
        -- ($\sevensegShrink*(P1)+{1-\sevensegShrink}*(P2)$);}{} % d
      \ifthenelse{\equal{\i}{4}}{\path[segstyle]
        (${1-\sevensegShrink}*(P1)+\sevensegShrink*(P3)$)
        -- ($\sevensegShrink*(P1)+{1-\sevensegShrink}*(P3)$);}{} % e
      \ifthenelse{\equal{\i}{5}}{\path[segstyle]
        (${1-\sevensegShrink}*(P3)+\sevensegShrink*(P5)$)
        -- ($\sevensegShrink*(P3)+{1-\sevensegShrink}*(P5)$);}{} % f
      \ifthenelse{\equal{\i}{6}}{\path[segstyle]
        (${1-\sevensegShrink}*(P3)+\sevensegShrink*(P4)$)
        -- ($\sevensegShrink*(P3)+{1-\sevensegShrink}*(P4)$);}{} % g
    }
  \end{tikzpicture}%
}

\newcommand{\sevensegnum}[2][]% sample characvters
{%
  \ifthenelse{\equal{#2}{0}}{\sevenseg[#1]{{1,1,1,1,1,1,0,}}}{%
  \ifthenelse{\equal{#2}{1}}{\sevenseg[#1]{{0,1,1,0,0,0,0,}}}{%
  \ifthenelse{\equal{#2}{2}}{\sevenseg[#1]{{1,1,0,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{3}}{\sevenseg[#1]{{1,1,1,1,0,0,1,}}}{%
  \ifthenelse{\equal{#2}{4}}{\sevenseg[#1]{{0,1,1,0,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{5}}{\sevenseg[#1]{{1,0,1,1,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{6}}{\sevenseg[#1]{{1,0,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{7}}{\sevenseg[#1]{{1,1,1,0,0,0,0,}}}{%
  \ifthenelse{\equal{#2}{8}}{\sevenseg[#1]{{1,1,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{9}}{\sevenseg[#1]{{1,1,1,1,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{A}}{\sevenseg[#1]{{1,1,1,0,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{B}}{\sevenseg[#1]{{0,0,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{C}}{\sevenseg[#1]{{0,0,0,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{D}}{\sevenseg[#1]{{0,1,1,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{E}}{\sevenseg[#1]{{1,0,0,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{F}}{\sevenseg[#1]{{1,0,0,0,1,1,1,}}}{%
  {\sevenseg[#1]{{0,0,0,0,0,0,0,}}}}}}}}}}}}}}}}}}}%
}

\tikzset{
  myarrow/.style={
    draw=black,
    thick,
    ->,
    shorten <=3pt,
    shorten >=3pt,
  },
  mycircle/.style={
    draw=black,
    shape=circle,
    very thick,
    inner sep=3pt,
    inner ysep=5pt,
    text width=0.75cm,
    align=center,
    minimum size=0.75cm,
    rounded corners,
  },
  mytriangle/.style={
    draw=black,
    regular polygon,
    regular polygon sides=3,
    align=center,
    rounded corners,
    very thick,
    inner sep=3pt,
  },
  myrectangle/.style={
    draw=black,
    shape=rectangle,
    very thick,
    rounded corners,
    align=center,
    inner sep=7pt,
    inner ysep=7pt,
    text width=2.1cm,
    minimum size=0.5cm,
    minimum height=1.5cm,
    font=\footnotesize
  },
  mysquare/.style={
    draw=black,
    shape=rectangle,
    very thick,
    rounded corners,
    align=center,
    inner sep=7pt,
    inner ysep=7pt,
    font=\footnotesize
  }
}

\pgfplotsset{
  every axis plot post/.style={/pgf/number format/fixed}
}

\newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand{\cspm}{CSP$_M$}

\begin{document}
\begin{frontmatter}                           % The preamble begins here.

\setcounter{page}{1}

%\pretitle{Pretitle}
\title{Towards Automatic Program Specification Using SME Models}
\runningtitle{Towards Automatic Program Specification Using SME Models}
%\subtitle{Subtitle}

\author{\fnms{Alberte} \snm{THEGLER}%
\thanks{Corresponding Author: {\em Alberte Thegler, Blegdamsvej 17, 2100 Copenhagen OE}.
E-mail: {\tt tpq587@alumni.ku.dk}.}}, %
\author{\fnms{Mads} \fnms{Ohm} \snm{LARSEN}}, %
\author{\fnms{Kenneth} \snm{SKOVHEDE}}, %
and %
\author{\fnms{Brian} \snm{VINTER}}%
\runningauthor{A. Thegler et al.}
\address{Niels Bohr Institute, University of Copenhagen, Denmark}

\begin{abstract}
This paper introduces a method to simplify hardware modeling and verification thereof in order for software programmers to, more easily, meet the demands of the growing embedded device industry. We describe a simple method for transpiling from the new SME Implementation Language into \cspm{} and using formal verification to verify properties within the generated program. We present a small example consisting of a
seven segment display clock network and introduce how to verify the widths of the channels in the network.
\end{abstract}

\begin{keyword}
\cspm{}\sep
SME\sep
transpiling
\end{keyword}
\end{frontmatter}

\setcounter{footnote}{1}

\section*{Introduction}
The Internet of Things, computerized medical implants, and the omnipresent growth in robotics, brings with them an increased demand for programmers to develop software for those devices. While this observation may not in itself appear to present a new challenge, many other areas have previously presented a need for more programmers. The new challenge is that these new growth areas are all focused on small size, low power consumption, and high reliability. This means that traditional software engineering methods, and thus traditionally trained programmers, are often not sufficiently qualified to develop these technologies.
In previous decades such systems have been developed by electronic engineers that apply far more rigid development approaches. Especially for hardware solutions like VLSI\footnote{Very-large-scale integration.} and FPGA\footnote{Field-Programmable Gate Array.}, correctness has always been favored over productivity.
While tools have obviously improved and methods refined, the VLSI process is still mostly the same as presented in~\cite{Agrawal:1985:VDP:320599.322570}. The primary workflow from~\cite{Agrawal:1985:VDP:320599.322570} is shown in Figure~\ref{fig:Agrawal}; note the focus on verification in each step.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto, scale=0.8, every node/.style={scale=0.8}]
    \node[myrectangle] (synthesis)                            {Synthesis and test generation};
    \node[myrectangle] (layout)    [right=2.5cm of synthesis] {Layout};
    \node[myrectangle] (wafer)     [right=2.5cm of layout]    {Wafer\\fabrication and packaging};

    \node[myrectangle] (verification1) [below=0.5cm of synthesis] {Verification};
    \node[myrectangle] (verification2) [below=0.5cm of layout]    {Verification};
    \node[myrectangle] (verification3) [below=0.5cm of wafer]     {Testing};

    \node (input) [left=1.5cm of synthesis] {};
    \draw[myarrow] (input) -- node[near start] {\scriptsize Requirements} (synthesis);

    \node (output) [right=1.5cm of wafer] {};
    \draw[myarrow] (wafer) -- node[near end] {\scriptsize VLSI devices} (output);

    \draw[myarrow] (synthesis) -- node[text width=2cm, align=center, midway] {\scriptsize Logic design and test data} (layout);
    \draw[myarrow] (layout)    -- node[text width=2cm, align=center, midway] {\scriptsize Mask and test data} (wafer);

    \draw[myarrow] (synthesis)     to[out=345, in=15]  (verification1);
    \draw[myarrow] (verification1) to[out=165, in=195] (synthesis);

    \draw[myarrow] (layout)        to[out=345, in=15]  (verification2);
    \draw[myarrow] (verification2) to[out=165, in=195] (layout);

    \draw[myarrow] (wafer)         to[out=345, in=15]  (verification3);
    \draw[myarrow] (verification3) to[out=165, in=195] (wafer);

    \draw[myarrow] (verification3) -- node[text width=3cm, align=center, midway, below=2mm] {\scriptsize Timing, testability, quality, reliability, and yield problems} (verification2);
    \draw[myarrow] (verification2) -- node[text width=3cm, align=center, midway, below=2mm] {\scriptsize Timing, testability, quality, reliability, and yield problems} (verification1);
  \end{tikzpicture}
  \caption{VLSI process workflow.}
  \label{fig:Agrawal}
\end{figure}

While the VLSI community is fundamentally following this 1980's design approach, more high-level tools and abstractions have been introduced. Philippe et al.~\cite{ coussy2009introduction} show a workflow (reproduced in Figure~\ref{fig:coussy}) where the important part is the verification that has been partly automated by basing the development on a formal specification of the solution.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (specification) {Specification};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (compilation) [right=0.5cm of specification] {Compilation};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (formalmodel) [right=0.5cm of compilation] {Formal model};

    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (behavioral) [right=0.5cm of formalmodel] {Behavioral synthesis};

    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (generation) [below=1cm of specification] {Generation};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (rtl) [right=0.5cm of generation] {RTL architecture};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (logic) [right=0.5cm of rtl] {Logic synthesis};

    \node[] (dotdotdot) [right=0.5cm of logic] {...};

    \draw[myarrow] (specification) -- (compilation);
    \draw[myarrow] (compilation) -- (formalmodel);
    \draw[myarrow] (formalmodel) -- (behavioral);

    \draw[myarrow] (behavioral) |-([shift={(0mm,-5mm)}]behavioral.south west) -- ([shift={(0mm,5mm)}]generation.north east)-| (generation);

    \draw[myarrow] (generation) -- (rtl);
    \draw[myarrow] (rtl) -- (logic);
    \draw[myarrow] (logic) -- (dotdotdot);
  \end{tikzpicture}
  \caption{Reproduced workflow from Philippe et al.~\cite{coussy2009introduction}.}
  \label{fig:coussy}
\end{figure}

There is no denying that the subjectively slow and rigid development process in the VLSI world~\cite{kepner2004hpc} is highly successful in producing correct and reliable circuits. At the same time, conventional software development is highly focused on productivity and time-to-market, for example, smartphone applications are often developed for continuous release, where bug patches and new features are rolled out daily. This is of course not possible with hardware.

Thus, the authors argue that there is a growing chasm between the way most programmers are trained and the competencies that are needed to support the growth in mission critical embedded devices.
\\

In this work, we propose a tool to help bridge the gap between available programmer profiles and the required competencies for embedded devices. Our approach is based on building a specification from a software implementation and test-suite observations. The overarching goal is to reach a level where a conventional software programmer can write a solution in Synchronous Message Exchange (SME)~\cite{Vinter2014, Vinter2015}, and develop a conventional test suite in the software engineering tradition. By combining the implementation with the \emph{observed} values of internal states in an SME based system implementation, we can produce a formal specification of the system. This specification can be fed into a formal verification tool and thus improve the correctness guarantees from only what is covered by the individual test vectors to the entire space that is spawned by the set of test vectors. We approach the task by transpiling\footnote{Source-to-source compile.} the new SME Implementation Language (SMEIL)~\cite{smeil} for SME into \cspm{}~\cite{Scattergood1998} and verify the formal properties of this version with a tool like FDR4~\cite{fdr}.
\\

This paper builds on the SME model, which have been covered in papers~\cite{Vinter2014, Vinter2015, Skovhede}. In this paper we only include a brief description of the elements required to understand the setup we have developed, and encourage readers to seek out more information in the mentioned papers.
\\\\


\section{Background}
\subsection{Synchronous Message Exchange}
SMEIL is based on the SME model and therefore we give a brief introduction to SME.
\\

SME was first introduced in 2014 and after several iterations~\cite{Vinter2014, Vinter2015, Skovhede} now presents as a programming model, a simulation library, and VHDL code generators~\cite{vhdl}. The original idea was conceived following an attempt to create hardware descriptions from a vector processor model, modeled in PyCSP~\cite{bjorndalen2007pycsp}, a Communicating
Sequential Processes (CSP)~\cite{hoare1978communicating} library for Python.
After this attempt, it became clear that the structure of CSP was poorly suited for modeling clocked systems, and therefore it was decided to create the SME model, based on the CSP algebra. The idea was to only use the subset of the CSP algebra that provided beneficial functionality to hardware modeling which, most importantly, meant that external choice was omitted. However, the shared-nothing property of CSP showed to be very useful, since the network state could only be changed by process communication.
\\

In SME, a network is a combination of processes that are connected through buses. The processes communicate through a collection of signals in a bus, instead of CSP's synchronous rendezvous model, but retains the shared-nothing trait of CSP.
SME uses the term \texttt{bus} instead of \texttt{channel} to enforce the semantic correlation between the SME bus and a physical hardware signal bus.
The process communication is handled by a hidden clock which eliminates the complexity that arose from adding synchronicity to a CSP network. The combination of the hidden clock and the synchronous message passing between processes means that the SME model provides hardware-like signal propagation.

An SME clock cycle consists of three phases: it reads, executes, and writes as can be seen in Figure~\ref{fig:sme_process_flow}. The process is activated on the rising clock edge where it reads from the bus and it reads, executes and writes to the bus in one clock cycle. Just before the rising edge of the clock, all signals are propagated on all buses which means, that all communication happens simultaneously. Because of this structure, if a value is written by a process in cycle $i$, it is read by the receiving process in cycle $i+1$.

SME is able to detect read/write conflicts where multiple writes are performed to a single bus within the same clock cycle as well as reads from a signal that has not been written to in the previous clock-cycle.
\\
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle, text width=2cm, shape=rectangle] (read) {Read};
    \node[mycircle, text width=2cm, shape=rectangle] (execute) [below=0.5cm of read] {Execute};
    \node[mycircle, text width=2cm, shape=rectangle] (write)  [below=0.5cm of execute] {Write};

    \draw [myarrow] (read) -- (execute);
    \draw [myarrow] (execute) -- (write);
    \draw [myarrow] (write) |-([shift={(5mm,-5mm)}]write.south east)-- ([shift={(5mm,5mm)}]read.north east)-| (read);
  \end{tikzpicture}
  \caption{SME process flow for one clock cycle.}
  \label{fig:sme_process_flow}
\end{figure}
Since SME is based on CSP, all SME models have a
corresponding CSP model, and because of this property, we are able to create a transpiler translating SME models to \cspm{}.
The SME model is currently implemented as libraries for the general-purpose languages C\#~\cite{Skovhede}, C++~\cite{asheim2015}, and Python~\cite{asheim2016vhdl}. The Python and C\# libraries both have code generators for VHDL as well.

\subsection{SMEIL}
\label{SMEIL-section}
With the different SME implementations, a need arose for a common intermediate language. SMEIL was developed as a Domain Specific Language (DSL) for SME, usable both as an IL and as an independent implementation language. It has a C-like syntax with a type system that makes hardware modeling simple. In spite of its simplicity, SMEIL still provides hardware-specific functionality that is more difficult to create with general-purpose languages.
Often when modeling hardware in Hardware Description Languages (HDLs) like VHDL or Verilog, code for testing and verifying are often written in the same language as the design itself. Unfortunately, the HDLs often does not have the functionality for generating proper simulation input. Using general-purpose languages for testing hardware models are useful since the range of available libraries are much larger.
Therefore the SMEIL simulator provides a simple language-independent API which enables SME implementations written for general-purpose languages to communicate with SME networks written in SMEIL, so-called co-simulation.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc addone (in inbus)
    bus outbus {
        val: int;
    };
{
    outbus.val = inbus.val + 1;
}

    |$\vdots$|

network net() {
    instance a of addone(b.outbus);
    instance b of ..
    |$\vdots$|
}
\end{minted}
\caption{Small example of process and network syntax in SMEIL.}
\label{lst:smeil_small_syntax_example}
\end{listing}

The two fundamental components of an SMEIL program is \texttt{process} and \texttt{network}. The process consists of variable and bus definitions, as well as the statements that are evaluated once for each clock cycle. The purpose of the \texttt{network} declaration is to define the relations between each entity in the program. A small example of process and network syntax can be seen in Listing~\ref{lst:smeil_small_syntax_example}.

There are several different ways to use SMEIL, one being co-simulation as described above. However, in this work, we focus on the independent SMEIL representation and thus we only present examples in pure SMEIL. These pure SMEIL programs must contain a process which generates input for the network since the network cannot receive input elsewhere. The program is simulated using the command line tool. Simulation is done in order to test the design of the system.

During the simulation, ranges for all observed values are captured so the observed values and types can be used to constrain the original defined types and ranges. This property is of great value when translating into \cspm{}, and when creating assertions, since we can use these values to actually assert the network.
The number of clock cycles, that the simulation is run for, is specified by the programmer via the command line tool. If the simulation is not passing through enough clock cycles, the verification might be inadequate. Since the verification builds on the observed values, the simulation needs to be long enough such that the whole possible range of input values is exhausted.

In Figure~\ref{fig:smeil_transpiler} the SMEIL transpiler structure can be seen.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle, minimum size=1.75cm, align=center, text width=1.75cm, font=\footnotesize]    (smeil)                                       {SMEIL};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (csme)  [above left=-0.25cm and 1.5cm of smeil] {C\#SME};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (pysme) [below left=-0.25cm and 1.5cm of smeil] {PySME};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (vhdl)  [right=1.0cm of smeil]                {VHDL};

    \draw[myarrow] (csme)  -- (smeil);
    \draw[myarrow] (pysme) -- (smeil);
    \draw[myarrow] (smeil) -- (vhdl);
  \end{tikzpicture}
  \caption{SMEIL transpiler structure.}
  \label{fig:smeil_transpiler}
\end{figure}

\section{Seven Segment Display Clock in SMEIL}\label{sec:example-smeil}
In order to explain how we can transpile programs from SMEIL to \cspm{}, we have designed an example using a seven segment display clock.
In this section, the seven segment display example will be explained as well as the SMEIL implementation of the network.
\\

A seven segment display is an electronic display device which is used in displays such as digital clocks or other types of devices that display numerals. An example of a typical digital clock display can be seen in Figure~\ref{fig:6_displays}. When a digit has been determined for a seven segment display, it is encoded to a bitstream that represents the digit in the correctly activated display segments.
\begin{figure}[!ht]
  \begin{center}
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{1}
        \sevensegnum[size=2em, shrink=0.1]{2}
      }
    }
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{3}
        \sevensegnum[size=2em, shrink=0.1]{4}
      }
    }
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{5}
        \sevensegnum[size=2em, shrink=0.1]{6}
      }
    }
  \end{center}
  \caption{Digital clock with six seven segment displays, displaying 12:34:56.}
  \label{fig:6_displays}
\end{figure}
In this example, we wish to model a typical digital clock that is able to calculate and display the current time in hours, minutes, and seconds. Listing~\ref{lst:python} shows this example written in Python.
When creating this model in SMEIL some input must be added to the network, just like \texttt{time\_since\_midnight} in Listing~\ref{lst:python}. The input value represents seconds since midnight, and in order to calculate hours, minutes, and seconds we model three different processes, called the \texttt{time} processes in this example.

When writing hardware models in pure SMEIL, the only way to generate input for the network is to create a data generator process. This process, called the \texttt{clock} process in our example, is instantiated with the start time and is incremented by 1 for each simulation cycle, representing a one second increase. The result is communicated on the process output bus, where the three \texttt{time} processes are listening. These \texttt{time} processes receive the number and by the use of simple integer arithmetic, calculate the hours, minutes, and seconds since midnight respectively. It is obvious that at some point in time, each \texttt{time} process will calculate a two-digit result, for example at 12 hours or 42 seconds. However, a single seven segment display can only show one digit between 0 and 9. Therefore we need two seven segment displays for each \texttt{time} process in order to show the correct time in a 24-hour interval. Each \texttt{time} process has an output bus with two individual channels that represent the communication to each different display. The number representing either hours, minutes, or seconds are separated into first and second digit, by $\lfloor \frac{x}{10} \rfloor$ and $(x \text{ mod } 10)$. These six different results are then communicated onto the six different channels which represent the six different seven segment displays.
The outline of this network can be seen in Figure~\ref{fig:smeil_network}.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{python}
from math import floor

def time(time_since_midnight):
    hours   = floor(time_since_midnight / 3600)
    minutes = floor((time_since_midnight - hours * 3600) / 60)
    seconds = time_since_midnight - hours * 3600 - minutes * 60
    return [hours, minutes, seconds]

print(time( 57100)) # =>  15:51:40
print(time(  3601)) # =>  01:00:01
print(time( 66666)) # =>  18:31:06
\end{minted}
\caption{A Python implementation of the seven segment display example.}
\label{lst:python}
\end{listing}
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mycircle] (I) at (0,0) {$I$};

    \node [mycircle] (H) at (2.5,  1.50) {$H$};
    \node [mycircle] (M) at (2.5,  0.00) {$M$};
    \node [mycircle] (S) at (2.5, -1.50) {$S$};

    \draw [myarrow] (I) -- (M);

    \draw [myarrow, smooth] (I) to[out=0, in=180] (H);
    \draw [myarrow, smooth] (I) to[out=0, in=180] (S);

    % Output arrows without processes
    \draw [myarrow] (3.125,  1.625) -- (4.000,  1.750);
    \draw [myarrow] (3.125,  1.375) -- (4.000,  1.250);
    \draw [myarrow] (3.125,  0.125) -- (4.000,  0.250);
    \draw [myarrow] (3.125, -0.125) -- (4.000, -0.250);
    \draw [myarrow] (3.125, -1.375) -- (4.000, -1.250);
    \draw [myarrow] (3.125, -1.625) -- (4.000, -1.750);
  \end{tikzpicture}
  \caption{SMEIL network for a seven segment display clock. Each SMEIL process is represented by a cicle with a letter corresponding to the processes Input, Hours, Minutes and Seconds respectively.}
  \label{fig:smeil_network}
\end{figure}

In Figure~\ref{fig:smeil_network} the network consists of four processes, the data generator process, \textit{I}, which creates the input that is broadcasted out on the network. The three \texttt{time} processes, hours (\textit{H}), minutes (\textit{M}), and seconds (\textit{S}) are the processes described above, which calculate each part of the current time. The outputs are communicated on the six outgoing channels.

The full SMEIL code for this example can be seen in Listing~\ref{lst:smeil} in  the appendix.
\section{Supporting Technologies}
\subsection{FDR4}
We not only want to transpile SMEIL to \cspm{}, we also want to be able to verify different properties in \cspm{} in order to prove correctness. Today, there exists several tools for formal verification, both in academia and in the industry. One of the currently most favored tools is the Failures-Divergences Refinement tool (FDR4). This tool is a CSP refinement checker that can analyze programs written in the machine-readable version of CSP; \cspm{}.
It provides a parallel refinement-checking engine that can scale up linearly with the number of cores. This means that it can handle processes with a large number of states in a reasonable time. FDR4 can handle several different types of assertions, deadlocks being the most used. However, due to the structure of SMEIL, we use FDR4 in a different way than is typical. Since the SME model cannot have cyclic-wait we have no need to verify the system in this manner.

For our current implementation of the transpiler, we can assert the ranges of the channel inputs, for example, we can automatically assert that the observed ranges, provided by the SMEIL simulation, and the possible input on the \cspm{} channels are not conflicting.
In hardware, we would typically want to verify that the communication on a bus does not exceed a certain range or that the sum of multiple signals does not exceed a specific value. A bus might be able to carry other data than needed, and being able to model a circuit that can assert that the bus never carries other data than expected, is of great value.
\\

CSP was not initially developed for hardware modeling, and therefore it is not evident how to handle the clock cycle, which is an essential part of hardware modeling. When we transpile the SME network into \cspm{} the SMEIL simulation have provided the ranges of all values from the simulation and therefore all clock cycles. This means that when FDR4 asserts a property it asserts on all possible communication combinations for all the simulated clock cycles. Therefore, even though we are transpiling from an SME model, where the clock is crucial, we can simply translate ``one-to-one" from the SMEIL program and still get an accurate assertion on the properties.

\subsection{Transpiling SMEIL to \cspm{}} \label{sec:transpiling}
When transpiling from SMEIL to \cspm{} one of the difficult components was to find a generalized method for transpiling, that could be generalized to most problems. We have worked on separation of concerns in order to simplify, but also have a greater chance of being able to match more SMEIL programs.

An SMEIL process consists of bus and variable declarations, the statements to be run per clock cycle as well as the outgoing communication from the process.  Channels within an SMEIL bus can be translated directly to \cspm{} channels. It is, however, important to give channel names that will be unique since a \cspm{} channel is global as opposed to the local channel within each SMEIL bus. An example of an SMEIL process, where the process structure is evident, can be seen in Listing~\ref{lst:range_smeil} and the corresponding \cspm{} code in Listing~\ref{lst:channel_range_cspm}.

In order to keep the outwards communication and the arithmetic statements together within each process in \cspm{}, we generate \cspm{} processes with a \texttt{let within} statement. The arithmetic statements go into the \texttt{let} section and the communications go into the \texttt{within} section. This gives us the possibility of separating the outwards communication and arithmetic statements while still keeping them within the same \cspm{} process. In Listing~\ref{lst:channel_range_cspm}, an example of the \texttt{let within} statement can be seen in lines 7-14. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes.

The network in an SMEIL program is the crucial part which ties all the processes and communication together. We can standardize the network generation by creating a two-step communication part. Instead of having the actual processes receive the incoming data, they receive the data by their process parameter. The process parameter is then set by the network process which receives the communication from the channels and provides the process with the communicated value.
This ensures that we can generate the processes easily without having to traverse the network in the SMEIL program beforehand to find out which channel provides input for which process. An example of this is shown in Listing~\ref{lst:cspm} in the appendix on lines 61 to 66.

\section{Seven Segment Display Clock Transpiling}
In the following we use a classic hardware design to illustrate each of the steps in the transpiling, and how the types, constraints, and assertions are carried from the original SMEIL program into the \cspm{} program.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (sme) {SME};
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (smeil) [right=1cm of sme] {SMEIL};
    \node[mycircle, text width=2cm, inner sep=5pt, inner ysep=5pt] (transpiler) [right=1cm of smeil] {Transpiler};
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (cspm) [right=1cm of transpiler] {CSP$_M$};

    \draw[myarrow] (sme) -- (smeil);
    \draw[myarrow] (smeil) -- (transpiler);
    \draw[myarrow] (transpiler) -- (cspm);
  \end{tikzpicture}
  \caption{SME to \cspm{} transpiler.}
  \label{fig:sme-to-cspm}
\end{figure}

We wish to model the network presented in Section~\ref{sec:example-smeil} in SMEIL in order to transpile it to \cspm{} so that we may verify properties in FDR4. In Figure~\ref{fig:sme-to-cspm} the workflow of this system can be seen.

Even though SME buses can contain a series of channels, every single channel is translated into a \cspm{} channel. The properties we will assert with FDR4, are the width of the \cspm{} channels. That is, we want to prove that certain values will never be communicated on certain channels.
It is easy to imagine that 4 bits can be communicated between the \texttt{time} processes and the seven segment displays. But 4 bits can represent the numbers 0 through 15, and our seven segment displays can only display the numbers 0 through 9. Therefore we wish to assert that even though the channels can carry 4 bits, the actual communication on the six output channels does not exceed 9. In general, the displays will be able to display 0 through 9, but since the example is a clock showing a 24-hour interval, the displays will of course not be able to show minutes and seconds above 59 and hours above 23.

We know that a program in pure SMEIL must have a data generation process, but this is not the case in a CSP network. Since we are only transpiling from pure SMEIL networks, we can be certain that there will always be a process which just contributes an initial value to the rest of the network.
We also know that a process must either have communication in or out or both.
Therefore, we can assume that all SMEIL processes with no input bus will be a data generator process of some kind, and therefore must have some outwards communication.
So when transpiling to \cspm{}, we do not translate the SMEIL process to a \cspm{} process, but simply create a \cspm{} channel that represents the values communicated out of this SMEIL process.
\\

We assume that the SMEIL programs we transpile only contains channels with types and range annotations. During the simulation, the type will be restricted to the lowest representation possible. For example, if a channel was originally set to be \texttt{int} (unbounded), but the observed values from the simulation show that it could be changed to an \texttt{i8} (signed 8-bit integer with a range of -128 to 127), then the simulated output would be \texttt{i8}.

When creating channels in \cspm{}, we need to define its range of possible values. If a channel is only defined by having the integer type, FDR4 would try to verify for all possible integers, which results in a seemingly unbounded runtime. As explained in Section~\ref{SMEIL-section}, all simulated SMEIL programs will include the observed range and restricted types for all channels and variables. The types represent the observed width of the channels in bits, and by calculating the possible range from these types, we can create the corresponding channels in \cspm{}, and thereby avoid having a seemingly endless runtime in FDR4.

Since the assertion we wish to make is to verify the widths of the channels, it might seem redundant to create \cspm{} channels with a limited range. FDR4 would always only check the values in the defined channel range and therefore there is no point in asserting if the values go beyond this range. After simulating the SME network, SMEIL provides us with both a type and a range of observed values. The type is used to create the \cspm{} channel range and the observed values are used for the assertion. The type will always represent equal or more values than the range of observed values, and by using these values the assertions becomes valuable.
\\

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc seconds (in seconds_in)
    bus seconds_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var seconds: u6 range 1 to 59;
    var seconds_first_temp: u3 range 0 to 5;
    var seconds_second_temp: u4 range 0 to 9;
{
    seconds = seconds_in.val % 60;
    seconds_first_temp = seconds / 10;
    seconds_second_temp = seconds % 10;
    seconds_out.first_digit = seconds_first_temp;
    seconds_out.second_digit = seconds_second_temp;
}
\end{minted}
\caption{Example of the \texttt{seconds} process from the SMEIL seven segment display example. See full example in Listing~\ref{lst:smeil} in the appendix.}
\label{lst:range_smeil}
\end{listing}

When it comes to transpiling the data generator process into a \cspm{} channel, we also use the types of the SMEIL simulation to define it. We use this instead of the observed values because we cannot guarantee the precise input values of the system. If we used the observed values, the assertions will pass every time, since it will test the values already used to generate the rest of the observed values.

An example of simulated SMEIL code can be seen in Listing~\ref{lst:range_smeil}. Notice on lines 2 and 3 that the two channels are defined both with a type \texttt{u3} and \texttt{u4} and with a range 0 to 5 and 0 to 9. These are the observed types and value ranges the simulation tracked for the specific channel. In order to create the \cspm{} channels based on the types, we need to convert \texttt{u3} and \texttt{u4} into its corresponding range, which for \texttt{u3} is 0 through 7 and for \texttt{u4} is 0 through 15. In Listing~\ref{lst:channel_range_cspm} on lines 1 and 2, the calculated ranges are used to define the \cspm{} channels.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}

    |$\vdots$|

Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP
\end{minted}
\caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:channel_range_cspm}
\end{listing}

When creating the assertions, we decided to create separate assert functions to keep the code structure clean. We know that for each \cspm{} channel there must be an assertion, except for the input channel.
Consequently, we create a \textit{monitor} process for each channel and its only job is to listen in on the channel communication and assert the values communicated there. The monitor process is a process that we add specifically for asserting legal communication values in FDR4 and it does not affect the original SME network.
In Figure~\ref{fig:assertion_process} the outline of this kind of structure can be seen and we expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.

The monitor process asserts the observed values of the \cspm{} channels and in Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the Seconds \texttt{time} process can be seen. The values used for these statements are the observed values from the SMEIL simulation, as can be seen at the end of lines 2 and 3 in Listing~\ref{lst:range_smeil}. In Listing~\ref{lst:monitor_range_cspm} the ranges are used to assert that the only values communicated on the channels are within 0 and 5, and 0 and 9 respectively.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
\end{minted}
\caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:monitor_range_cspm}
\end{listing}
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mytriangle] (I) at (0, 0) {$I$};

    %%%%

    \node [mycircle, above right=25ex and 25ex of I] (H) {$H$};

    \node [mysquare, above right=1.5ex and 25ex of H] (H_d1) {$D_{H_1}$};
    \node [mysquare, below right=1.5ex and 25ex of H] (H_d2) {$D_{H_2}$};
    \node [mycircle, above right=3ex and 7.5ex of H] (H_m1) {$M_{H_1}$};
    \node [mycircle, below right=3ex and 7.5ex of H] (H_m2) {$M_{H_2}$};
    \node [draw, red, thick, dotted, fit=(H)(H_m1)(H_m2), inner sep=0.5cm] {};
    \node [right=15ex of H, red] {$N_{hours}$};

    \draw [myarrow, smooth] (I) to[out=0, in=180] (H);

    \draw [myarrow, smooth] (H) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](H_mp1) (H_d1);
    \draw (H_m1) -- (H_mp1)  [black!50];
    \draw [myarrow, smooth] (H) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](H_mp2) (H_d2);
    \draw (H_m2) -- (H_mp2)  [black!50];

    %%%%

    \node [mycircle, right=23.2ex of I] (M) {$M$};

    \node [mysquare, above right=1.5ex and 25ex of M] (M_d1) {$D_{M_1}$};
    \node [mysquare, below right=1.5ex and 25ex of M] (M_d2) {$D_{M_2}$};
    \node [mycircle, above right=3ex and 7.5ex of M] (M_m1) {$M_{M_1}$};
    \node [mycircle, below right=3ex and 7.5ex of M] (M_m2) {$M_{M_2}$};
    \node [draw, red, thick, dotted, fit=(M)(M_m1)(M_m2), inner sep=0.5cm] {};
    \node [right=15ex of M, red] {$N_{minutes}$};

    \draw [myarrow, smooth] (I) to[out=0, in=180] (M);

    \draw [myarrow, smooth] (M) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](M_mp1) (M_d1);
    \draw (M_m1) -- (M_mp1)  [black!50];
    \draw [myarrow, smooth] (M) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](M_mp2) (M_d2);
    \draw (M_m2) -- (M_mp2)  [black!50];

    %%%%

    \node [mycircle, below right=24.5ex and 24.5ex of I] (S) {$S$};

    \node [mysquare, above right=1.5ex and 25ex of S] (S_d1) {$D_{S_1}$};
    \node [mysquare, below right=1.5ex and 25ex of S] (S_d2) {$D_{S_2}$};
    \node [mycircle, above right=3ex and 7.5ex of S] (S_m1) {$M_{S_1}$};
    \node [mycircle, below right=3ex and 7.5ex of S] (S_m2) {$M_{S_2}$};
    \node [draw, red, thick, dotted, fit=(S)(S_m1)(S_m2), inner sep=0.50cm, inner ysep=0.5cm] {};
    \node [right=15ex of S, red] {$N_{seconds}$};

    \draw [myarrow, smooth] (I) to[out=0, in=180] (S);

    \draw [myarrow, smooth] (S) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](S_mp1) (S_d1);
    \draw (S_m1) -- (S_mp1)  [black!50];
    \draw [myarrow, smooth] (S) to[out=0, in=180] coordinate[midway, black!50, draw, shape=circle, inner sep=0pt, minimum size=5pt](S_mp2) (S_d2);
    \draw (S_m2) -- (S_mp2)  [black!50];
  \end{tikzpicture}
  \caption{A seven segment display clock network in \cspm{}. $I$ represents the input channel. $N_{hours}$, $N_{minutes}$ and $N_{seconds}$ represent the network processes with $H$, $M$ and $S$ as the \texttt{time} processes. The results from the \texttt{time} processes are communicated to the displays. The displays are represented by a square since they are not actual \cspm{} processes. Each display communication also has a monitor process which assert the legal communication values.}
  \label{fig:cspm-network}
\end{figure}

After translating the SMEIL processes and creating the monitor processes, we need to create the network described in the last part of the SMEIL program, see lines 53 to 59 in Listing~\ref{lst:smeil} in the appendix. We wish only to assert the values the \texttt{time} processes are communicating to the monitor processes, and therefore we have to synchronize these processes into a single network in \cspm{}. We create three network processes, one for each part of the network, and we create a nested synchronization, in order to have all monitor processes synchronized with the \texttt{time} process. An example of this network can be seen in on lines 61 to 66 in Listing~\ref{lst:cspm} in the appendix. This network process is also the process that receives the input from the input channel. By not adding the receiving communication in the \texttt{time} processes, we avoid having to specify the name of the input channels before creating the network which simplifies the translation, as described in Section~\ref{sec:transpiling}. In SMEIL, this information is part of the \texttt{network} section, and therefore it fits well within this part of the \cspm{} code.

After creating the network we add the actual assert function calls. For these kinds of assertions, where we want to check a range, the best solution is to assert that the network processes behave as the \texttt{SKIP} process. This is done by having the monitor process running the \texttt{SKIP} process if the value is within the range and the \texttt{STOP} process if not. Two examples can be seen in lines 2 and 4 in Listing~\ref{lst:monitor_range_cspm}. We assert this by using the FDR4 failures model on the the \texttt{SKIP} process along with hiding communication events, which can be seen in lines 68, 78 and 88 in Listing~\ref{lst:cspm} in the appendix.
\\

The different parts of transpiling the seven segment display example have been presented and in Figure~\ref{fig:cspm-network} the corresponding network of the \cspm{} system is presented.
The corresponding network in \cspm{} consists of 12 different processes, all created so that not only the network is simulated correctly, but also so the assertions we wish to make, are in place. The input is represented by a triangle, since it transpiles from an SME process to a \cspm{} channel. Each of the dotted squares represents the network of synchronizations for each \texttt{time} processes, which in itself is a process in \cspm{}. For each network, we have the \texttt{time} processes and two monitor processes, for example, $H$, $M_{H_1}$ and $M_{H_2}$.
\\

% Errornous example
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock_out_val : {0..131071}

channel hours_out_first_digit : {0..3}
channel hours_out_second_digit : {0..15}
    |$\vdots$|

Hours(hours_in) =
let
    hours = hours_in / 3600
    |$\vdots$|

Hours_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 2 then SKIP else STOP
Hours_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP

\end{minted}
\caption{Example of an erroneous version of the \texttt{Hours} process from the \cspm{} seven segment display example seen in Listing~\ref{lst:smeil} and in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:cspm_error}
\end{listing}

In order to show that the verification is accurate, the example in Listing~\ref{lst:cspm_error} contains an error that results in FDR4 failing the verification. In Listing~\ref{lst:cspm_error} the example is only able to handle an input that is below 24 hours. This is because the calculation in the \texttt{Hours} process does not handle the wrap around at the 24\textsuperscript{th} hour. This means that if the input represents more than 24 hours, the assertions will fail in FDR4 because one seven segment display suddenly has to display two digits instead of one. An example of such could be the input \texttt{131071}, which represents 36 hours, 24 minutes and 31 seconds, or 1 day, 12 hours, 24 minutes and 31 seconds. When trying to assert the code from Listing~\ref{lst:cspm_error} in FDR4, the assertion fails. The counterexample shows that the number 3 is communicated on \texttt{hours\_out\_first\_digit}, which is not allowed according to the monitor process on lines 12 and 13 in Listing~\ref{lst:cspm_error}.

This example of failure shows how verifying the solution with a tool like FDR4 actually catches errors that the programmer might have overseen. In this case, the error is simply corrected by adding \texttt{\% 24} on the end of line 9 in Listing~\ref{lst:cspm_error} and can be seen corrected in Listing~\ref{lst:cspm} in the appendix at line 15. Now when we try to assert the example in FDR4, it passes. By using modulo on the result, we ensure that we still get the accurate time of day, no matter how many full days the input represents.

The full SMEIL and \cspm{} code for the seven segment display example can be seen in Listing~\ref{lst:smeil} and in Listing~\ref{lst:cspm} in the appendix.
% Errornous example end

\section{Future Work}
With this work, we have taken a small step towards creating a simpler method for software developers to model hardware as well as verify properties within this model. In future work, we would like to extend this to software-hardware co-design, with which we would be able to assert deadlocks.

It would be desirable to be able to automatically create a human-readable report on the ranges and communications that are used within the system. This could become a standard addition to the documentation of the system, which would give a programmer an easy overview of a complicated system and would also allow for easier contemplation over the system.

Another, more complex idea for future work, is to implement support for multi-channel invariants. This is not something that can easily be simulated and therefore it would require some work, but it would provide the ability to express more complex assertions.

\section{Conclusions}
We have presented a transpiler that transpiles SME intermediate language (SMEIL) into \cspm{} for then to use the Failure-Divergences Refinement tool (FDR4) to assert properties in a \cspm{} network. We provide a simple approach that makes it more accessible for software programmers to program hardware and thereby bridging a gap between software programmers and the needs of the industry.
Instead of having to create advanced test-benches, our tool provides a simple way to verify the hardware model via FDR4s assertion functionalities. We can assert that the observed values of a channel, in a simulated SMEIL program, are in fact the only possible values communicated on that specific channel. We have also shown this to work in an example case of a seven segment display.

\section*{Acknowledgements}
Thanks to Uwe Zimmermann who made the seven segment example in TikZ on \url{http://www.texample.net/tikz/examples/segment-display/}.

\bibliographystyle{unsrt}
{\small\bibliography{lit}}
\newpage


\appendix
\section*{Full SMEIL and \cspm code}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc clock ()
    bus clock_out {val: u17 range 1 to 86401;};
    var i: u17 = 0 range 0 to 86401;
{
    i = i + 1;
    clock_out.val = i;
}

proc hours (in hours_in)
    bus hours_out {first_digit: u2 range 0 to 2;
                   second_digit: u4 range 0 to 9;};
    var hours: u5 range 0 to 23;
    var hours_first_temp: u2 range 0 to 2;
    var hours_second_temp: u4 range 0 to 9;
{
    hours = hours_in.val / 3600 % 24;
    hours_first_temp = hours / 10;
    hours_second_temp = hours % 10;
    hours_out.first_digit = hours_first_temp;
    hours_out.second_digit = hours_second_temp;
}

proc minutes (in minutes_in)
    bus minutes_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var minutes: u6 range 0 to 59;
    var minutes_first_temp: u3 range 0 to 5;
    var minutes_second_temp: u4 range 0 to 9;

{
    minutes = minutes_in.val / 60 % 60;
    minutes_first_temp = minutes / 10;
    minutes_second_temp = minutes % 10;
    minutes_out.first_digit = minutes_first_temp;
    minutes_out.second_digit = minutes_second_temp;
}


proc seconds (in seconds_in)
    bus seconds_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var seconds: u6 range 0 to 59;
    var seconds_first_temp: u3 range 0 to 5;
    var seconds_second_temp: u4 range 0 to 9;
{
    seconds = seconds_in.val % 60;
    seconds_first_temp = seconds / 10;
    seconds_second_temp = seconds % 10;
    seconds_out.first_digit = seconds_first_temp;
    seconds_out.second_digit = seconds_second_temp;
}

network clock_network ()
{
    instance g of clock();
    instance h of hours(g.clock_out);
    instance m of minutes(g.clock_out);
    instance s of seconds(g.clock_out);
}

\end{minted}
\captionof{listing}{The full SMEIL code used for transpiling in the seven segment display example.\label{lst:smeil}}

\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock_out_val : {0..131071}

channel hours_out_first_digit : {0..3}
channel hours_out_second_digit : {0..15}

channel minutes_out_first_digit : {0..7}
channel minutes_out_second_digit : {0..15}

channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}


Hours(hours_in) =
let
    hours = hours_in / 3600  % 24
    hours_first_temp = hours / 10
    hours_second_temp = hours % 10
within
    hours_out_first_digit ! hours_first_temp ->
    hours_out_second_digit ! hours_second_temp ->
    SKIP

Hours_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 2 then SKIP else STOP
Hours_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


Minutes(minutes_in) =
let
    minutes = minutes_in / 60  % 60
    minutes_first_temp = minutes / 10
    minutes_second_temp = minutes % 10
within
    minutes_out_first_digit ! minutes_first_temp ->
    minutes_out_second_digit ! minutes_second_temp ->
    SKIP

Minutes_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Minutes_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP

Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


N_hours = clock_out_val ? variable ->
          (Hours(variable)
          [| {| hours_out_first_digit|} |]
          Hours_out_first_digit_monitor(hours_out_first_digit))
          [| {| hours_out_second_digit|} |]
          Hours_out_second_digit_monitor(hours_out_second_digit)

assert SKIP [F= N_hours \ Events


N_minutes = clock_out_val ? variable ->
            (Minutes(variable)
            [| {| minutes_out_first_digit|} |]
            Minutes_out_first_digit_monitor(minutes_out_first_digit))
            [| {| minutes_out_second_digit|} |]
            Minutes_out_second_digit_monitor(minutes_out_second_digit)

assert SKIP [F= N_minutes \ Events


N_seconds = clock_out_val ? variable ->
            (Seconds(variable)
            [| {| seconds_out_first_digit|} |]
            Seconds_out_first_digit_monitor(seconds_out_first_digit))
            [| {| seconds_out_second_digit|} |]
            Seconds_out_second_digit_monitor(seconds_out_second_digit)

assert SKIP [F= N_seconds \ Events

\end{minted}
\captionof{listing}{The full \cspm{} code after transpiling the seven segment display example, as seen in Listing~\ref{lst:smeil} in the appendix.\label{lst:cspm}}



\end{document}
