\documentclass[a4paper]{report}

\usepackage[latin1]{inputenc}
\usepackage{palatino}
\usepackage[usenames]{color}

\usepackage{hyperref}

\usepackage{chngpage}
\usepackage{graphicx}

\usepackage{booktabs}
\usepackage{multirow}

\usepackage[]{algorithm2e}
\usepackage{varwidth}

\usepackage{setspace}

\usepackage{todonotes}

\usepackage[outputdir=.tmp]{minted}
% \usepackage[cache=false]{minted}
\setminted{frame=lines,linenos,framesep=2mm,fontsize=\small}

\usepackage{times}

\usepackage{amsmath}
\usepackage{amssymb}
\normalfont
%\usepackage[T1]{fontenc}
\renewcommand{\ttdefault}{cmtt}
\usepackage{xcolor}
\usepackage{booktabs, caption, siunitx}

\usepackage[babel, en, nat, farve, titelside]{ku-forside}

\usepackage{url}
\usepackage{pgfplots}
\usepackage{tikz}

\usepackage[labelsep=period]{caption}

\usetikzlibrary{calc}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}
\usepgfplotslibrary{units}
\pgfplotsset{compat=newest}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}

\usepackage{ifthen}
\pgfkeys{
  /sevenseg/.is family, /sevenseg,
  slant/.estore in      = \sevensegSlant,     % vertical slant in degrees
  size/.estore in       = \sevensegSize,      % length of a segment
  shrink/.estore in     = \sevensegShrink,    % avoids overlapping of segments
  line width/.estore in = \sevensegLinewidth, % thickness of the segments
  line cap/.estore in   = \sevensegLinecap,   % end cap style rect, round, butt
  oncolor/.estore in    = \sevensegOncolor,   % color of an ON segment
  offcolor/.estore in   = \sevensegOffcolor,  % color of an OFF segment
}

\pgfkeys{
  /sevenseg,
  default/.style={
    slant = 0,
    size = 1em,
    shrink = 0.2,
    line width = 0.3em,
    line cap = butt,
    oncolor = green!50!black,
    offcolor = white!75!black
  }
}
\newcommand{\sevenseg}[2][]% options values
{%
\pgfkeys{/sevenseg, default, #1}%
\def\sevensegarray{#2}%
  \begin{tikzpicture}%
    % first define the position of the 6 corner points
    \path (0,0) ++(0,0)                             coordinate (P1);
    \path (0,0) ++(\sevensegSize,0)                 coordinate (P2);
    \path (0,0) ++(90-\sevensegSlant:\sevensegSize) coordinate (P3);
    \path (P2)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P4);
    \path (P3)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P5);
    \path (P4)  ++(90-\sevensegSlant:\sevensegSize) coordinate (P6);
    % then step through the 1/0 values in the segment array
    \foreach \i in {0,...,6}%
    {
      \pgfmathparse{\sevensegarray[\i]}
      \ifthenelse{\equal{\pgfmathresult}{1}}%
        {\let\mycolor=\sevensegOncolor}%  segment is on
        {\let\mycolor=\sevensegOffcolor}% segment is off
      \tikzstyle{segstyle} = [draw=\mycolor, line width = \sevensegLinewidth,
                              line cap = \sevensegLinecap]
      %-----------------------
      \ifthenelse{\equal{\i}{0}}{\path[segstyle]
        (${1-\sevensegShrink}*(P5)+\sevensegShrink*(P6)$)
        -- ($\sevensegShrink*(P5)+{1-\sevensegShrink}*(P6)$);}{} % a
      \ifthenelse{\equal{\i}{1}}{\path[segstyle]
        (${1-\sevensegShrink}*(P6)+\sevensegShrink*(P4)$)
        -- ($\sevensegShrink*(P6)+{1-\sevensegShrink}*(P4)$);}{} % b
      \ifthenelse{\equal{\i}{2}}{\path[segstyle]
        (${1-\sevensegShrink}*(P4)+\sevensegShrink*(P2)$)
        -- ($\sevensegShrink*(P4)+{1-\sevensegShrink}*(P2)$);}{} % c
      \ifthenelse{\equal{\i}{3}}{\path[segstyle]
        (${1-\sevensegShrink}*(P1)+\sevensegShrink*(P2)$)
        -- ($\sevensegShrink*(P1)+{1-\sevensegShrink}*(P2)$);}{} % d
      \ifthenelse{\equal{\i}{4}}{\path[segstyle]
        (${1-\sevensegShrink}*(P1)+\sevensegShrink*(P3)$)
        -- ($\sevensegShrink*(P1)+{1-\sevensegShrink}*(P3)$);}{} % e
      \ifthenelse{\equal{\i}{5}}{\path[segstyle]
        (${1-\sevensegShrink}*(P3)+\sevensegShrink*(P5)$)
        -- ($\sevensegShrink*(P3)+{1-\sevensegShrink}*(P5)$);}{} % f
      \ifthenelse{\equal{\i}{6}}{\path[segstyle]
        (${1-\sevensegShrink}*(P3)+\sevensegShrink*(P4)$)
        -- ($\sevensegShrink*(P3)+{1-\sevensegShrink}*(P4)$);}{} % g
    }
  \end{tikzpicture}%
}

\newcommand{\sevensegnum}[2][]% sample characvters
{%
  \ifthenelse{\equal{#2}{0}}{\sevenseg[#1]{{1,1,1,1,1,1,0,}}}{%
  \ifthenelse{\equal{#2}{1}}{\sevenseg[#1]{{0,1,1,0,0,0,0,}}}{%
  \ifthenelse{\equal{#2}{2}}{\sevenseg[#1]{{1,1,0,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{3}}{\sevenseg[#1]{{1,1,1,1,0,0,1,}}}{%
  \ifthenelse{\equal{#2}{4}}{\sevenseg[#1]{{0,1,1,0,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{5}}{\sevenseg[#1]{{1,0,1,1,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{6}}{\sevenseg[#1]{{1,0,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{7}}{\sevenseg[#1]{{1,1,1,0,0,0,0,}}}{%
  \ifthenelse{\equal{#2}{8}}{\sevenseg[#1]{{1,1,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{9}}{\sevenseg[#1]{{1,1,1,1,0,1,1,}}}{%
  \ifthenelse{\equal{#2}{A}}{\sevenseg[#1]{{1,1,1,0,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{B}}{\sevenseg[#1]{{0,0,1,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{C}}{\sevenseg[#1]{{0,0,0,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{D}}{\sevenseg[#1]{{0,1,1,1,1,0,1,}}}{%
  \ifthenelse{\equal{#2}{E}}{\sevenseg[#1]{{1,0,0,1,1,1,1,}}}{%
  \ifthenelse{\equal{#2}{F}}{\sevenseg[#1]{{1,0,0,0,1,1,1,}}}{%
  {\sevenseg[#1]{{0,0,0,0,0,0,0,}}}}}}}}}}}}}}}}}}}%
}

\tikzset{
  myarrow/.style={
    draw=black,
    thick,
    ->,
    shorten <=3pt,
    shorten >=3pt,
  },
  mycircle/.style={
    draw=black,
    shape=circle,
    very thick,
    inner sep=3pt,
    inner ysep=5pt,
    text width=0.75cm,
    align=center,
    minimum size=0.75cm,
    rounded corners,
  },
  mytriangle/.style={
    draw=black,
    regular polygon,
    regular polygon sides=3,
    align=center,
    rounded corners,
    very thick,
    inner sep=3pt,
  },
  myrectangle/.style={
    draw=black,
    shape=rectangle,
    very thick,
    rounded corners,
    align=center,
    inner sep=7pt,
    inner ysep=7pt,
    text width=2.1cm,
    minimum size=0.5cm,
    minimum height=1.5cm,
    font=\footnotesize
  },
  mysquare/.style={
    draw=black,
    shape=rectangle,
    very thick,
    rounded corners,
    align=center,
    inner sep=7pt,
    inner ysep=7pt,
    font=\footnotesize
  }
}

\pgfplotsset{
  every axis plot post/.style={/pgf/number format/fixed}
}

% \newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand{\cspm}{CSP$_M$}



\usepackage{fancyhdr}
\pagestyle{fancy}

\lhead{Alberte Thegler}
\chead{Master's Thesis}
\rhead{August 2018}

\renewcommand{\headrulewidth}{0.4pt} % thickness of line at header
\renewcommand{\footrulewidth}{0.4pt} % thickness of line at footer
\setlength{\belowcaptionskip}{-10pt} % space below captions


\opgave{Master's Thesis}
\title{Towards Automatic Program Specification From SME Models}
\undertitel{Department of Computer Science}
\author{Alberte Thegler - alberte@thegler.dk}
\date{November 2018}
\vejleder{Advisors: Professor Brian Vinter and Kenneth Skovhede}

\begin{document}

\maketitle

\pagenumbering{roman}
\begin{abstract}
\begin{doublespace}
Abstract

\end{doublespace}
\end{abstract}



\newpage
\tableofcontents
%
% Abstract
% acknowledgements
% Introduction
% Motivation
% Background
% Code generation
% Evaluation
% discussion
% conclusion
% bibliography
%
\newpage
%\listoftodos
%\newpage
\pagenumbering{arabic}
\chapter{Introduction}
When we create programs, we wish to verify that it is also correct. There are several ways to do this, one commenly used is \texttt{testing} which require that the programmer creates several different scenarios and its expected output, or that the programmer programs a test-generator to create the scenarios and expected output. This, however, is not adequate for critical systems since it is never a 100\% accurate. Therefore it is of high interest to create a formal verification of the system or program.\\
%Talk about how verification was first created and how it became to be used for concurrent systems. Then write about how it works and then write about the different systems and formal languages that is used for it. \\\\


In this thesis we look at model checking, that is, verifying that a specific property will always hold for a piece of code.
\\\\

Formal verification is the process of checking whether a program satisfies specific properties. Different methods have evolved, all having different advantages and disadvantages. FDR is sometimes referred to as a model checker however is it actually a refinement checker.
\\\\

The Internet of Things, computerized medical implants, and the omnipresent growth in robotics, brings with them an increased demand for programmers to develop software for those devices. While this observation may not in itself appear to present a new challenge, many other areas have previously presented a need for more programmers. The new challenge is that these new growth areas are all focused on small size, low power consumption, and high reliability. This means that traditional software engineering methods, and thus traditionally trained programmers, are often not sufficiently qualified to develop these technologies.
In previous decades such systems have been developed by electronic engineers that apply far more rigid development approaches. Especially for hardware solutions like VLSI\footnote{Very-large-scale integration.} and FPGA\footnote{Field-Programmable Gate Array.}, correctness has always been favored over productivity.
While tools have obviously improved and methods refined, the VLSI process is still mostly the same as presented in~\cite{Agrawal:1985:VDP:320599.322570}. The primary workflow from~\cite{Agrawal:1985:VDP:320599.322570} is shown in Figure~\ref{fig:Agrawal}; note the focus on verification in each step.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto, scale=0.8, every node/.style={scale=0.8}]
    \node[myrectangle] (synthesis)                            {Synthesis and test generation};
    \node[myrectangle] (layout)    [right=2.5cm of synthesis] {Layout};
    \node[myrectangle] (wafer)     [right=2.5cm of layout]    {Wafer\\fabrication and packaging};

    \node[myrectangle] (verification1) [below=0.5cm of synthesis] {Verification};
    \node[myrectangle] (verification2) [below=0.5cm of layout]    {Verification};
    \node[myrectangle] (verification3) [below=0.5cm of wafer]     {Testing};

    \node (input) [left=1.5cm of synthesis] {};
    \draw[myarrow] (input) -- node[near start] {\scriptsize Requirements} (synthesis);

    \node (output) [right=1.5cm of wafer] {};
    \draw[myarrow] (wafer) -- node[near end] {\scriptsize VLSI devices} (output);

    \draw[myarrow] (synthesis) -- node[text width=2cm, align=center, midway] {\scriptsize Logic design and test data} (layout);
    \draw[myarrow] (layout)    -- node[text width=2cm, align=center, midway] {\scriptsize Mask and test data} (wafer);

    \draw[myarrow] (synthesis)     to[out=345, in=15]  (verification1);
    \draw[myarrow] (verification1) to[out=165, in=195] (synthesis);

    \draw[myarrow] (layout)        to[out=345, in=15]  (verification2);
    \draw[myarrow] (verification2) to[out=165, in=195] (layout);

    \draw[myarrow] (wafer)         to[out=345, in=15]  (verification3);
    \draw[myarrow] (verification3) to[out=165, in=195] (wafer);

    \draw[myarrow] (verification3) -- node[text width=3cm, align=center, midway, below=2mm] {\scriptsize Timing, testability, quality, reliability, and yield problems} (verification2);
    \draw[myarrow] (verification2) -- node[text width=3cm, align=center, midway, below=2mm] {\scriptsize Timing, testability, quality, reliability, and yield problems} (verification1);
  \end{tikzpicture}
  \caption{VLSI process workflow.}
  \label{fig:Agrawal}
\end{figure}

While the VLSI community is fundamentally following this 1980's design approach, more high-level tools and abstractions have been introduced. Philippe et al.~\cite{ coussy2009introduction} show a workflow (reproduced in Figure~\ref{fig:coussy}) where the important part is the verification that has been partly automated by basing the development on a formal specification of the solution.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (specification) {Specification};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (compilation) [right=0.5cm of specification] {Compilation};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (formalmodel) [right=0.5cm of compilation] {Formal model};

    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (behavioral) [right=0.5cm of formalmodel] {Behavioral synthesis};

    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (generation) [below=1cm of specification] {Generation};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (rtl) [right=0.5cm of generation] {RTL architecture};
    \node[myrectangle, text width=3cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (logic) [right=0.5cm of rtl] {Logic synthesis};

    \node[] (dotdotdot) [right=0.5cm of logic] {...};

    \draw[myarrow] (specification) -- (compilation);
    \draw[myarrow] (compilation) -- (formalmodel);
    \draw[myarrow] (formalmodel) -- (behavioral);

    \draw[myarrow] (behavioral) |-([shift={(0mm,-5mm)}]behavioral.south west) -- ([shift={(0mm,5mm)}]generation.north east)-| (generation);

    \draw[myarrow] (generation) -- (rtl);
    \draw[myarrow] (rtl) -- (logic);
    \draw[myarrow] (logic) -- (dotdotdot);
  \end{tikzpicture}
  \caption{Reproduced workflow from Philippe et al.~\cite{coussy2009introduction}.}
  \label{fig:coussy}
\end{figure}

There is no denying that the subjectively slow and rigid development process in the VLSI world~\cite{kepner2004hpc} is highly successful in producing correct and reliable circuits. At the same time, conventional software development is highly focused on productivity and time-to-market, for example, smartphone applications are often developed for continuous release, where bug patches and new features are rolled out daily. This is of course not possible with hardware.

Thus, the authors argue that there is a growing chasm between the way most programmers are trained and the competencies that are needed to support the growth in mission critical embedded devices.
\\

In this work, we propose a tool to help bridge the gap between available programmer profiles and the required competencies for embedded devices. Our approach is based on building a specification from a software implementation and test-suite observations. The overarching goal is to reach a level where a conventional software programmer can write a solution in Synchronous Message Exchange (SME)~\cite{Vinter2014, Vinter2015}, and develop a conventional test suite in the software engineering tradition. By combining the implementation with the \emph{observed} values of internal states in an SME based system implementation, we can produce a formal specification of the system. This specification can be fed into a formal verification tool and thus improve the correctness guarantees from only what is covered by the individual test vectors to the entire space that is spawned by the set of test vectors. We approach the task by transpiling\footnote{Source-to-source compile.} the new SME Implementation Language (SMEIL)~\cite{smeil} for SME into \cspm{}~\cite{Scattergood1998} and verify the formal properties of this version with a tool like FDR4~\cite{fdr}.
\\

This paper builds on the SME model, which have been covered in papers~\cite{Vinter2014, Vinter2015, Skovhede}. In this paper we only include a brief description of the elements required to understand the setup we have developed, and encourage readers to seek out more information in the mentioned papers.
\\\\


\textit{"Matematicians tend to reject proofs by exhaustive checking of all cases as being less satisfying than deductive proofs, and with good reason. First, they are not applicable for proving theorems about integers and real numbers, which are infinite domains so that the number of interpretations is infinite and they cannot be exhaustively checked. Second, they offer no insight into why a theorem is true. But computer scientists have more practical concerns. If they can check all computations of a program and show that they all satisfy a correctness property, we will be willing to forego elegance and be more than satisfied that our program has been proven correct."} from "A primer on model checking af Ben-Ari" \cite{Ben-ari2010}\
\newpage
\section{Motivation}
\subsection{Ariane 5 failure}
The Ariane 5 space rocket\cite{InquiryBoard1996} was designed to launch large payloads into Earths orbit, such as communications satelites, etc. Ariane 5 was the follow-up on the sucessful Ariane 4 launchers. On june 4th, 1996, the Ariane 5 rocket had its first test flight. The rocket, which was owned by The European Space Agency (ESA) and the French spatial agency Centre national d'\'etudes spatiales (CNES) was manufactured by Airbus Defence and Space.\\ The rocket was launched in French Guiana, and only 37 seconds after successful lift-off, the rocket flipped 90 degrees and two seconds later the forces of aerodynamics ripped the boosters appart from the core stage. This caused the self-destruct mechanism to trigger and the rocket self-destructed in a giant explotion shortly afterwards.\\ This giant disaster cost approximately 500 million dollars and it was a huge loss for ESA and CNES.  \\
The reason for the failure was an error that could have easily been avoided. Luckily the rocket was unmanned, but this kind of error could happen in any other space rocket. This launch failure is acknowledged as one of the most expensive failures in history. \\
The failure was caused by a bug in the Inertial Reference System (SRI). The SRI system is used to determine the orientation of the rocket, which is also known as the horizontal bias or the BH value. The error occured when a 64-bit floating point number, representing the horizontal velocity, was converted to a 16-bit signed integer, without any exception handling. This code was written in Ada, a language that other Hardware Description Languages (HDLs) have later been based on.\\ As the rockets velocity increased the 64-bit floating point number became larger than what can fit into a 16-bit signed integer and therefore causing an overflow. The SRI system misinterpreted this as true flight-data, and to counteract the "wrong" direction, the engines thrusted to change course and thus it was ripped apart by aerodynamics. The backup system, that should take over when errors occur in the main system, was running the exact same code as the main system and therefore it had failed, for the same reasons, just before the main system failed, causing the self-destruct mechanism to activate.\\

This insident becomes even more horrible when discovered that the BH value, which was the cause of the failure, was not neseccary after launch. The code had been reused from the Ariane 4 rocket, which required the value after launch, but the Ariane 5 rocket did not. The code that could have handled these problems had been disabled due to performance issues on Ariane 4 and had not been reapplied on Ariane 5. Also, Ariane 4 was launched with a less steep trajectory than Ariane 5, and therefore it did not overflow the BH value. However, since Ariane 5 ascent to space faster, it was highly probable that the BH value would overflow. If anyone had taken a look at this, taken the new rocket into account, this massive failure might have been avoided.
\subsection{Therac-25 failure}
In the 80's the company Atomic Energy of Canada Limited (AECL) manufactured a revolutionary radiation therapy machine, the Therac-25\cite{Leveson1993}, which could provide two different kinds of treatment. At that time, hospitals would typically have two different machines for the two different treatments that the Therac-25 machine could provide in one machine. The two treatments consisted of a beam of low-energy electrons which used scanning magnets to spread the electron beam, and a beam of higher-energy X-Ray photons which worked by rotating four components into the beam. The Therac-25 was build based on the previous Therac-20 and Therac-6 and some code from the Therac-20 was reused in the Therac-25. Unfortunately, there were no independent protective circuits for monitoring the electron beam or any interlocks to ensure safety with the Therac-25, which had been in the previous versions. AECL put more faith on software reliability than on hardware. \\ After the Therac-25 had been operational for a couple of years on several different hospitals, a series of incidents happened where patients were exposed to too much radiation and that led to six patients being seriously injured or killed. Friz Hager, the staff physicist at East Texas Cancer Center, tried to reproduce the errors they had experienced on the Therac-25, and was successful. When the user selected the X-Ray mode on the Therac-25, the machine began setting up for high-powered X-rays, which took about 8 seconds. If the user switched to Electron mode before the machine finished setting up for X-ray mode, i.e within 8 seconds, the turntable would not switch to the correct position causing an enormous amount of radiation to reach the patient.\\
After solving the problem and releasing a new version of the Therac-25, another problem emerged where a patient was overdosed. This time it turned out to be a counter overflow. If a command was sent at the exact moment the counter overflowed, the machine would not set op properly and again, resulting in an overdose of radiation for the patient. \\
After this incident with the Therac-25, it was found that some of the same software problems was found in Therac-20, but due to the hardware precautions on the Therac-20, the problems never occurred.
\\ This example shows how important it is for critical systems to be well designed as well as well tested or verified.

\subsection{The patriot misile failure}
During the Persian Gulf war on February 25, 1991, an American Patriot Misile failed to intercept an incomming Iraqi Scud misile which caused the Scud to hit an American Army barracks which injured around 100 people and killed 28 soldiers. The Patriot Misile failed due to an error when converting an interger, representing time since last boot, to a real number using a 24-bit register. As time since last boot increased, the chopping error increased due to the fact that the conversion was fixed to a 24-bit range. At the time of the incident, the Patriod Misile Battery had been up for approximately 100 hours, which caused the chopping inaccuracy to be around 0.34 seconds. The Scud travels at around 1.676 meters per second, and therefore in the 0.34 seconds it travels more than a half kilometer. The consequences of this restriction in  registers caused the precision to be inacurate and so the Patriot Misile did not struck the Scud as it was meant to.


%Intels-division bug \\
%Toyota bremse-fejl\\
\section{Learning goals}
The learning goals accepted for this project are:
\begin{itemize}
\item Reflect on the set of SME expressible problems, that are verifiable with FDR4.
\item Reason about efficient code transformation from an executable format to a verifiable format
\item Reason about design choices and their consequences for execution performance.
\item Demonstrate efficient constraint transfer from SME to FDR4.
\item Reason about SME program size and time to verification.
\item Reflect on the generality of a generic verification template.
\item Disseminate project results to a professional audience.
\end{itemize}
\chapter{Related work}
The concepts of formal verification was first expressed in 1954 when Martin Davis created the first computer generated mathematical proof that the product of two even numbers, is even. First-order theorem provers were applied to verification problems in Pascal, Ada and Java, in the late 1960s.
At Stanford, in 1972, Sir Robin Milner had success building the original LCF system for proof checking and his work in automated reasoning have been the foundation for a lot of other theorem provers, like the proof assistant HOL (Higher Order Logic) by Mike Gordon, which was originally developed for reasoning about hardware. The formal proof management system Coq is a descendent of LCF. \\
Also in 1972, Robert S. Boyer and J. Strother Moore was successful in building a machine-based prover, called Nqthm which became the basis for ACL2 which is a programming language and a theorem prover. Theorem provers have proved very valuable over the time, but one problem with them was, that if they found a problem in a theorem, they could not tell why it could not prove the theorem. It was not possible to create a counter example or any other explanation as to why it was not possible to prove this theorem. \\\\
In 1967, Robert W. Floyd was published with the paper \textit{Assigning meaning to programs}\cite{Floyd1967}. Floyd provided a basis for the formal definitions of the meaning of programs which can be used for proving correctness, equivalence and termination. By using flowcharts, he argued that when a command is reached, all previous commands will have been true as well.\\ C.A.R Hoare was inspired by Floyd and in 1969 his paper \textit{An axiomtic basis for computer programming}\cite{Hoare1969} was published. The logic he presented there (later known as \textit{Hoare logic}), was build on Floyd's ideas and proposed the notation \textit{Partial correctness specification}; $\{P\} C \{Q\}$. Here, $C$ is a command and $P$ and $Q$ are conditions on the program variables in $C$. Hoare showed that whenever $C$ is executed in a state that satisfies the condition $P$, and if the execution terminates, then the state that $C$ terminates in, will satisfy $Q$. Hoares logic have been the basis of a lot of different formal languages and have contributed to the continuous work on formal verification. \\
Since the original Hoares logic was not originially thought as to model concurrent programs, L. Lamport extended Hoare's logic in his paper \textit{The 'Hoare logic' of concurrent programs}\cite{Lamport1980} in 1980. Here, he discuss why Hoare's logic, as proposed by C.A.R Hoare, does not work for concurrent programs and proposes a "generalized Hoare's logic" that takes concurrency into account. \\\\
In 1978 Hoares paper \textit{Communicating Sequential Processes} was published and with it, CSP was born. It have been widely used in many different types of work and have also been expanded since Hoare initially described it in 1978\cite{Abdallah2005}. The first version of CSP was a simple programming language that had quite a different syntax than todays CSP. In 1984, Brookes, Hoare and Roscoe published their continued work on CSP with the paper \textit{A Theory of Communicating Sequential Processes}\cite{Brookes1984}, and created the modern process algebra it is today. Only a few minor changes have been made to CSP since then, and they are described in Roscoe's \textit{The Theory and Practice of Concurrency}\cite{Roscoe1997}.\\
A number of tools have been created in order to analyse, verify and understand systems written in CSP. Since CSP was mostly a blackboard language and difficult to use on larger scale, different types of machine-readable CSP syntaxes have been created over the years in order to make it easier to use CSP on a larger scale. Most of todays CSP tools use a version of machine-readble CSP called \cspm{} which was created by Scattergood\cite{Scattergood1998}. Scattergood created \cspm{} as a combination of the standard CSP algebra and a functional programming language which provided a better baseline for tools to work with CSP.\\
Here is a subset of the different CSP tools:
\begin{itemize}
\item One of the most known CSP tools is the Failure-Divergence Refinement tool (FDR), build by Formal Systems (Europe) Ltd., and is currently at version 4.2.3\cite{fdr}. FDR4 is a refinement checker and the newer version of FDR is able to run in parallel as well as do state compression in order to avoid a very large state space. FDR only work on finite-state processes.
\item ProBE (Process Behaviour Explorer)\cite{probe} is a tool to animate CSP in order to explore the state space of CSP processes. It can handle infinite state and is based on the same \cspm{} version as FDR4 is. ProBE was also created by Formal Systems (Europe) Ltd and ProBE is integrated into the current version of FDR4.
\item At Adelaide University, The Adelaide Refinement Checker (ARC)\cite{Parashkevov1996} was created as an automatic verification tool for CSP. It uses Ordered Binary Decision Diagrams (OBDDs) to represent the internal representation of data structures. This lessen the state explosion problem that other model checker tools have had. \todo{which language does it use?}
\item The ProB project\cite{ProB}\cite{Leuschel2003} was originally created as an animation and model checker tool for the B-Method\cite{Abrial1988} but it also supports other languages like Z and \cspm{}. Newer versions of ProB can do refinement checking of \cspm{} scripts but does not have the full functionality that FDR does. \todo{research this more}
\item J. Sun, Y.Liu, J.Dong et al. presented the Process Analysis Toolkit (PAT) in their 2009 paper\cite{Sun2009}. PAT is a CSP analysis tool that can perform Linear Temporal Logic (LTL) model checking, refinement checking and simulation of CSP processes. \todo{research this more}
\item CSP-Prover\cite{Isobe2005} is a theorem prover for CSP and based on the theorem prover Isabelle. It is an entirely different way to check programs than model checking. It attempts to prove some general results based on specific theory. It is better at proving general results where model checkers are better at proving combinatorial problems. \todo{make this more clear}
\end{itemize}
The programming language Occam\cite{Occam1995}, which was first released in 1983, is a concurrent programming language that builds on the CSP process algebra. Occam was continuouly in development during the years and the Kent Retargetable occam Compiler (KRoC) team at Kent University created the Occam-$\pi$\cite{UniveristyofKent} variant of the Occam programming language. It is a version that extends the ideas of CSP in the original Occam language but adding mobility features from pi-calculus. In the paper \textit{The symbiosis of concurrency and verification: teaching and case studies}\cite{Pedersen2018} Pedersen and Welch uses Occam-$\pi$ along with \cspm in order to reason about the logic behind \cspm and FDR. By using an executable language like Occam-$\pi$ which is based on the concurrency model of CSP it becomes easier to understand the logic of \cspm and thereby verify the program with FDR4.\\\\
SPIN\cite{spin} is a verification tool that uses process interactions to prove correctness for a system. The systems are described in the formal language \texttt{PROMELA}(PROcess MEta LAnguage)\cite{Holzmann1991} and the correctness properties are spcified in Linear Temporal Logic (LTL)\cite{Pnueli1977}. In the paper \textit{Reasoning About Infinite Computations}\cite{Vardi1994}, Vardi and Wolper showed that all LTL formulas can be translated into a B\"uchi automata which SPIN makes use of and thus converting the given LTL into a B\"uchi automaton. Spin performs verification on concurrent software and does not perform verification on hardware circuits. \\
Spin was developed at Bell Labs, starting in 1980. Gerard J. Holzmann gives an introduction to the theoretical foundations, the design and structure and examples of applications in the paper \textit{The model checker SPIN}\cite{Holzmann1997}. SPIN, as well as other model checker tools, have been build on the pioneering work on logic model checking by Clarke and Emerson\cite{Clarke1981}, as well as Sifakis and Queille\cite{Queille1982}. \todo{Should I add more info here? } Vardi and Wolper extended their work with an automata-theoretic approach to automatically verify programs\cite{Vardi1986}.\\\\
Another verification tool was developed as a collaboration between the Department of Information Technology at Uppsala University (UPP) in Sweden and the Department of Computer Science at Aalborg University (AAL) in Denmark. Larsen et al. first proposed the ideas for UPPAAL\cite{Larsen1995} in 1995 and further introduced it in the paper \textit{UPPAAL - a Tool Suite for Automatic Verifcation of Real-Time Systems}\cite{Bengtsson1995}.
UPPAAL is a verification tool for modelling, simulating and verifying real-time systems. It is based on the theory of timed automata\cite{Hopcroft2001}\cite{Alur1990} and the typical systems to gain advantage of UPPAAL are systems where timing aspects are critical and where the communication goes through channels or shared variables.
As other model checkers, UPPAAL have a modelling language, wherein the system is specified, and a query language that is used to specify the properties to check against the system. The query language is a subset of CTL (computational tree logic) that work for real-time systems\cite{Henzinger1994} \cite{Larsen1995}. The model checking is done by checking the state-space by making a reachability analysis. The current version of UPPAAL is called UPPAAL2K and was released in 1999\cite{Amnell2001}. \\\\
In 1981, Edmund M. Clarke and E. Allen Emerson managed to combine temporal logic with the state-space exploration in order to provide the first automated model checking algorithm\cite{Clarke1981}. It was capable of proving properties of programs as well as producing counter examples.
In the mid 1980s it was shown how model checking could be applied to hardware verification. However, it quickly became clear that model checking on hardware was very limited due to the state-space explosion that occurs especially on hardware. \\
Randall Bryant from the CMU electrical engineering department invented ordered Binary decision diagrams (OBDDs). Later on, J. Burch, E. Clarke, K. McMillan et al.\cite{Burch1992} used OBDDs and created \textit{symbolic model checking} which represents the state space symbolically. The symbolic model checking can verify systems with an extremely large number of states and thus creating a solution to the problems of state space explosion.\\
Because of the state-space explosion problem and the increasing complexity of digital electronic circuits, there was a need to be able to model the timing and data flow of a ciruit with a certain amount of abstraction. This became Hardware Description Languages (HDL) \\\\
VHDL (VHSIC Hardware Description Language) was initially ordered by the United States Department of Defence in 1981 to help with the growing problem of hardware life cycles. It is based on the Ada programming language and have been the base Hardware Description language that was used to model hardware. In 1987 it became an IEEE standard, known as VHDL-87. After a major modification in 1993 it was known as VHDL-93. VHDL ... \todo{write something more}

Verilog was published by Gateway Design Automation in 1985 and along side VHDL are the two main HDL's used for modelling circuits. Cadence Design Systems received the rights to Verilog-XL which is the HDL simulator that would end up being the de-facto standard Verilog simulator.



However, VHDL and Verilog share many of the same limitations: neither is suitable for analog or mixed-signal circuit simulation; neither possesses language constructs to describe recursively-generated logic structures. Specialized HDLs (such as Confluence) were introduced with the explicit goal of fixing specific limitations of Verilog and VHDL, though none were ever intended to replace them. (From WIKI)
(From WIKI): Essential to HDL design is the ability to simulate HDL programs. Simulation allows an HDL description of a design (called a model) to pass design verification, an important milestone that validates the design's intended function (specification) against the code implementation in the HDL description. It also permits architectural exploration. The engineer can experiment with design choices by writing multiple variations of a base design, then comparing their behaviour in simulation. Thus, simulation is critical for successful HDL design.


Look at functional verification

Look at Property Specification Language
also look at SVA (two property languages that are derived from LTL) (used for Hardware)


HDL include explicit notation for expressing concurrency as well as a notion of time.
HDLs are used to write executable specifications for hardware.
Because HDLs can be executed it gives the illusion of programming languages even though it is more of a specification language or modelling language.
First HDLs in late 60's. C.Gordon Bell and Allan Newells text "Computer Structures" in 1971 - first to give a hdl with lasting effect.

(from
http://www.techdesignforums.com/practice/guides/formal-verification-guide/) "Equivalence checking has been used for more than a decade to check that RTL and gate-level descriptions of a design represent the same design"



Take a look at Temporal logic model checking (As it is mentioned in the formal verification - evolution article)
- Clarke et. al. CMU 1981
- Sifakis et. al. Grenoble 1982
and also look at
Symbolic model checking
McMillan 1991
SMV

WRIGHT\cite{Allen1997}\cite{Allen1997a} \todo{It would be worth to read more about this! They have done a bit of the same that I am to do in my thesis with auto generating \cspm}
is an architecture description language which was developed at Carnegie Mellon University. They can auto generate \cspm code from WRIGHT and from there they can confirm certain properties by using FDR. http://www.cs.cmu.edu/~able/wright/



Both theorem provers and model checkers have been, and are still, widely used for both software and hardware. There is a third form of formal verification that is also being used more often now. This is equivalence checking, which compares two models of a design and produces an outcome that either shows that they are equal or provides a counter-example to show when they disagree. It is beginning to become common practice for hardware designers to use equvalence checking to compare the design of an optimized digital design and an unoptimized digital design. This way it is possible for the designer to check that the optimizations did not change the functionality of the design.






\chapter{Analysis}
\section{SME}
\subsection{Synchronous Message Exchange}
SMEIL is based on the SME model and therefore we give a brief introduction to SME.
\\

SME was first introduced in 2014 and after several iterations~\cite{Vinter2014, Vinter2015, Skovhede} now presents as a programming model, a simulation library, and VHDL code generators~\cite{vhdl}. The original idea was conceived following an attempt to create hardware descriptions from a vector processor model, modeled in PyCSP~\cite{bjorndalen2007pycsp}, a Communicating
Sequential Processes (CSP)~\cite{hoare1978communicating} library for Python.
After this attempt, it became clear that the structure of CSP was poorly suited for modeling clocked systems, and therefore it was decided to create the SME model, based on the CSP algebra. The idea was to only use the subset of the CSP algebra that provided beneficial functionality to hardware modeling which, most importantly, meant that external choice was omitted. However, the shared-nothing property of CSP showed to be very useful, since the network state could only be changed by process communication.
\\

In SME, a network is a combination of processes that are connected through buses. The processes communicate through a collection of signals in a bus, instead of CSP's synchronous rendezvous model, but retains the shared-nothing trait of CSP.
SME uses the term \texttt{bus} instead of \texttt{channel} to enforce the semantic correlation between the SME bus and a physical hardware signal bus.
The process communication is handled by a hidden clock which eliminates the complexity that arose from adding synchronicity to a CSP network. The combination of the hidden clock and the synchronous message passing between processes means that the SME model provides hardware-like signal propagation.

An SME clock cycle consists of three phases: it reads, executes, and writes as can be seen in Figure~\ref{fig:sme_process_flow}. The process is activated on the rising clock edge where it reads from the bus and it reads, executes and writes to the bus in one clock cycle. Just before the rising edge of the clock, all signals are propagated on all buses which means, that all communication happens simultaneously. Because of this structure, if a value is written by a process in cycle $i$, it is read by the receiving process in cycle $i+1$.

SME is able to detect read/write conflicts where multiple writes are performed to a single bus within the same clock cycle as well as reads from a signal that has not been written to in the previous clock-cycle.
\\
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle, text width=2cm, shape=rectangle] (read) {Read};
    \node[mycircle, text width=2cm, shape=rectangle] (execute) [below=0.5cm of read] {Execute};
    \node[mycircle, text width=2cm, shape=rectangle] (write)  [below=0.5cm of execute] {Write};

    \draw [myarrow] (read) -- (execute);
    \draw [myarrow] (execute) -- (write);
    \draw [myarrow] (write) |-([shift={(5mm,-5mm)}]write.south east)-- ([shift={(5mm,5mm)}]read.north east)-| (read);
  \end{tikzpicture}
  \caption{SME process flow for one clock cycle.}
  \label{fig:sme_process_flow}
\end{figure}
Since SME is based on CSP, all SME models have a
corresponding CSP model, and because of this property, we are able to create a transpiler translating SME models to \cspm{}.
The SME model is currently implemented as libraries for the general-purpose languages C\#~\cite{Skovhede}, C++~\cite{asheim2015}, and Python~\cite{asheim2016vhdl}. The Python and C\# libraries both have code generators for VHDL as well.

\subsection{SMEIL}
\label{SMEIL-section}
With the different SME implementations, a need arose for a common intermediate language. SMEIL was developed as a Domain Specific Language (DSL) for SME, usable both as an IL and as an independent implementation language. It has a C-like syntax with a type system that makes hardware modeling simple. In spite of its simplicity, SMEIL still provides hardware-specific functionality that is more difficult to create with general-purpose languages.
Often when modeling hardware in Hardware Description Languages (HDLs) like VHDL or Verilog, code for testing and verifying are often written in the same language as the design itself. Unfortunately, the HDLs often does not have the functionality for generating proper simulation input. Using general-purpose languages for testing hardware models are useful since the range of available libraries are much larger.
Therefore the SMEIL simulator provides a simple language-independent API which enables SME implementations written for general-purpose languages to communicate with SME networks written in SMEIL, so-called co-simulation.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc addone (in inbus)
    bus outbus {
        val: int;
    };
{
    outbus.val = inbus.val + 1;
}

    |$\vdots$|

network net() {
    instance a of addone(b.outbus);
    instance b of ..
    |$\vdots$|
}
\end{minted}
\caption{Small example of process and network syntax in SMEIL.}
\label{lst:smeil_small_syntax_example}
\end{listing}

The two fundamental components of an SMEIL program is \texttt{process} and \texttt{network}. The process consists of variable and bus definitions, as well as the statements that are evaluated once for each clock cycle. The purpose of the \texttt{network} declaration is to define the relations between each entity in the program. A small example of process and network syntax can be seen in Listing~\ref{lst:smeil_small_syntax_example}.

There are several different ways to use SMEIL, one being co-simulation as described above. However, in this work, we focus on the independent SMEIL representation and thus we only present examples in pure SMEIL. These pure SMEIL programs must contain a process which generates input for the network since the network cannot receive input elsewhere. The program is simulated using the command line tool. Simulation is done in order to test the design of the system.

During the simulation, ranges for all observed values are captured so the observed values and types can be used to constrain the original defined types and ranges. This property is of great value when translating into \cspm{}, and when creating assertions, since we can use these values to actually assert the network.
The number of clock cycles, that the simulation is run for, is specified by the programmer via the command line tool. If the simulation is not passing through enough clock cycles, the verification might be inadequate. Since the verification builds on the observed values, the simulation needs to be long enough such that the whole possible range of input values is exhausted.

In Figure~\ref{fig:smeil_transpiler} the SMEIL transpiler structure can be seen.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle, minimum size=1.75cm, align=center, text width=1.75cm, font=\footnotesize]    (smeil)                                       {SMEIL};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (csme)  [above left=-0.25cm and 1.5cm of smeil] {C\#SME};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (pysme) [below left=-0.25cm and 1.5cm of smeil] {PySME};
    \node[myrectangle, text width=1.5cm, minimum height=1.0cm, inner sep=5pt, inner ysep=5pt] (vhdl)  [right=1.0cm of smeil]                {VHDL};

    \draw[myarrow] (csme)  -- (smeil);
    \draw[myarrow] (pysme) -- (smeil);
    \draw[myarrow] (smeil) -- (vhdl);
  \end{tikzpicture}
  \caption{SMEIL transpiler structure.}
  \label{fig:smeil_transpiler}
\end{figure}

\section{SMEIL}
%\textbf{This is where the theory go. fx. SME and the correlation between that and CSP.}
%CSPm was devised by Bryan Scattergood as a machine-readable dialect of CSP  - se the paper \textit{The Semantics and Implementation of Machine-Readable CSP}\\\\
%" FDR2 is often described as a model checker, but is technically a refinement checker, in that it converts two CSP process expressions into Labelled Transition Systems (LTSs), and then determines whether one of the processes is a refinement of the other within some specified semantic model (traces, failures, or failures/divergence)" (from Wikipedia - se paper \textit{Model-checking CSP - af Roscoe} \\\\
\section{CSP}
Today, Communicating Sequential Processes (CSP) is a process algebra that provides a way to express concurrent systems. By using message passing between processes the language avoids certain problems that arise with the use of e.g shared variables. An essential part of CSP is message passing and the syntax for input is \texttt{X?c}. This represents an input from channel\texttt{X} and an assignment of the input value to the variable \texttt{c}. The output syntax is \texttt{X!c} where the value of the variable \texttt{c} is sent over the output channel \texttt{X}. At first Hoare had defined the message syntax to use the process names, but later on when CSP was developed into a proper process algebra, the syntax changed into using channels in order to be able to have several processes connected via the same channels.   \textbf{do not write too much here. just short explain csp}
\section{\cspm{}}
\cspm is a formal language that combines CSP with a functional programming language in order to make it easier for the programmer to model the systems and then use the code on tools that can animate, verify or similar.
\section{FDR}
FDR (Failures Divergence Refinement) tool is a refinement checker for

In the paper \textit{A primer on model checking}\cite{Ben-ari2010} Mordechai Ben-Ari explains a concurrent problem that he had used for many years, to teach his students about concurrency. ... \textbf{write this when I have read the article again}

\section{Supporting Technologies}
\subsection{FDR4}
We not only want to transpile SMEIL to \cspm{}, we also want to be able to verify different properties in \cspm{} in order to prove correctness. Today, there exists several tools for formal verification, both in academia and in the industry. One of the currently most favored tools is the Failures-Divergences Refinement tool (FDR4). This tool is a CSP refinement checker that can analyze programs written in the machine-readable version of CSP; \cspm{}.
It provides a parallel refinement-checking engine that can scale up linearly with the number of cores. This means that it can handle processes with a large number of states in a reasonable time. FDR4 can handle several different types of assertions, deadlocks being the most used. However, due to the structure of SMEIL, we use FDR4 in a different way than is typical. Since the SME model cannot have cyclic-wait we have no need to verify the system in this manner.

For our current implementation of the transpiler, we can assert the ranges of the channel inputs, for example, we can automatically assert that the observed ranges, provided by the SMEIL simulation, and the possible input on the \cspm{} channels are not conflicting.
In hardware, we would typically want to verify that the communication on a bus does not exceed a certain range or that the sum of multiple signals does not exceed a specific value. A bus might be able to carry other data than needed, and being able to model a circuit that can assert that the bus never carries other data than expected, is of great value.
\\

CSP was not initially developed for hardware modeling, and therefore it is not evident how to handle the clock cycle, which is an essential part of hardware modeling. When we transpile the SME network into \cspm{} the SMEIL simulation have provided the ranges of all values from the simulation and therefore all clock cycles. This means that when FDR4 asserts a property it asserts on all possible communication combinations for all the simulated clock cycles. Therefore, even though we are transpiling from an SME model, where the clock is crucial, we can simply translate ``one-to-one" from the SMEIL program and still get an accurate assertion on the properties.

\subsection{Transpiling SMEIL to \cspm{}} \label{sec:transpiling}
When transpiling from SMEIL to \cspm{} one of the difficult components was to find a generalized method for transpiling, that could be generalized to most problems. We have worked on separation of concerns in order to simplify, but also have a greater chance of being able to match more SMEIL programs.

An SMEIL process consists of bus and variable declarations, the statements to be run per clock cycle as well as the outgoing communication from the process.  Channels within an SMEIL bus can be translated directly to \cspm{} channels. It is, however, important to give channel names that will be unique since a \cspm{} channel is global as opposed to the local channel within each SMEIL bus. An example of an SMEIL process, where the process structure is evident, can be seen in Listing~\ref{lst:range_smeil} and the corresponding \cspm{} code in Listing~\ref{lst:channel_range_cspm}.

In order to keep the outwards communication and the arithmetic statements together within each process in \cspm{}, we generate \cspm{} processes with a \texttt{let within} statement. The arithmetic statements go into the \texttt{let} section and the communications go into the \texttt{within} section. This gives us the possibility of separating the outwards communication and arithmetic statements while still keeping them within the same \cspm{} process. In Listing~\ref{lst:channel_range_cspm}, an example of the \texttt{let within} statement can be seen in lines 7-14. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes.

The network in an SMEIL program is the crucial part which ties all the processes and communication together. We can standardize the network generation by creating a two-step communication part. Instead of having the actual processes receive the incoming data, they receive the data by their process parameter. The process parameter is then set by the network process which receives the communication from the channels and provides the process with the communicated value.
This ensures that we can generate the processes easily without having to traverse the network in the SMEIL program beforehand to find out which channel provides input for which process. An example of this is shown in Listing~\ref{lst:cspm} in the appendix on lines 61 to 66.


\chapter{Generalize specification from program and traces}
\section{Seven Segment Display Clock in SMEIL}\label{sec:example-smeil}
In order to explain how we can transpile programs from SMEIL to \cspm{}, we have designed an example using a seven segment display clock.
In this section, the seven segment display example will be explained as well as the SMEIL implementation of the network.
\\

A seven segment display is an electronic display device which is used in displays such as digital clocks or other types of devices that display numerals. An example of a typical digital clock display can be seen in Figure~\ref{fig:6_displays}. When a digit has been determined for a seven segment display, it is encoded to a bitstream that represents the digit in the correctly activated display segments.
\begin{figure}[!ht]
  \begin{center}
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{1}
        \sevensegnum[size=2em, shrink=0.1]{2}
      }
    }
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{3}
        \sevensegnum[size=2em, shrink=0.1]{4}
      }
    }
    \tikz{
      \node[inner sep=5pt, outer sep=2pt, draw=blue] {
        \sevensegnum[size=2em, shrink=0.1]{5}
        \sevensegnum[size=2em, shrink=0.1]{6}
      }
    }
  \end{center}
  \caption{Digital clock with six seven segment displays, displaying 12:34:56.}
  \label{fig:6_displays}
\end{figure}
In this example, we wish to model a typical digital clock that is able to calculate and display the current time in hours, minutes, and seconds. Listing~\ref{lst:python} shows this example written in Python.
When creating this model in SMEIL some input must be added to the network, just like \texttt{time\_since\_midnight} in Listing~\ref{lst:python}. The input value represents seconds since midnight, and in order to calculate hours, minutes, and seconds we model three different processes, called the \texttt{time} processes in this example.

When writing hardware models in pure SMEIL, the only way to generate input for the network is to create a data generator process. This process, called the \texttt{clock} process in our example, is instantiated with the start time and is incremented by 1 for each simulation cycle, representing a one second increase. The result is communicated on the process output bus, where the three \texttt{time} processes are listening. These \texttt{time} processes receive the number and by the use of simple integer arithmetic, calculate the hours, minutes, and seconds since midnight respectively. It is obvious that at some point in time, each \texttt{time} process will calculate a two-digit result, for example at 12 hours or 42 seconds. However, a single seven segment display can only show one digit between 0 and 9. Therefore we need two seven segment displays for each \texttt{time} process in order to show the correct time in a 24-hour interval. Each \texttt{time} process has an output bus with two individual channels that represent the communication to each different display. The number representing either hours, minutes, or seconds are separated into first and second digit, by $\lfloor \frac{x}{10} \rfloor$ and $(x \text{ mod } 10)$. These six different results are then communicated onto the six different channels which represent the six different seven segment displays.
The outline of this network can be seen in Figure~\ref{fig:smeil_network}.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{python}
from math import floor

def time(time_since_midnight):
    hours   = floor(time_since_midnight / 3600)
    minutes = floor((time_since_midnight - hours * 3600) / 60)
    seconds = time_since_midnight - hours * 3600 - minutes * 60
    return [hours, minutes, seconds]

print(time( 57100)) # =>  15:51:40
print(time(  3601)) # =>  01:00:01
print(time( 66666)) # =>  18:31:06
\end{minted}
\caption{A Python implementation of the seven segment display example.}
\label{lst:python}
\end{listing}
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mycircle] (I) at (0,0) {$I$};

    \node [mycircle] (H) at (2.5,  1.50) {$H$};
    \node [mycircle] (M) at (2.5,  0.00) {$M$};
    \node [mycircle] (S) at (2.5, -1.50) {$S$};

    \draw [myarrow] (I) -- (M);

    \draw [myarrow, smooth] (I) to[out=0, in=180] (H);
    \draw [myarrow, smooth] (I) to[out=0, in=180] (S);

    % Output arrows without processes
    \draw [myarrow] (3.125,  1.625) -- (4.000,  1.750);
    \draw [myarrow] (3.125,  1.375) -- (4.000,  1.250);
    \draw [myarrow] (3.125,  0.125) -- (4.000,  0.250);
    \draw [myarrow] (3.125, -0.125) -- (4.000, -0.250);
    \draw [myarrow] (3.125, -1.375) -- (4.000, -1.250);
    \draw [myarrow] (3.125, -1.625) -- (4.000, -1.750);
  \end{tikzpicture}
  \caption{SMEIL network for a seven segment display clock. Each SMEIL process is represented by a cicle with a letter corresponding to the processes Input, Hours, Minutes and Seconds respectively.}
  \label{fig:smeil_network}
\end{figure}

In Figure~\ref{fig:smeil_network} the network consists of four processes, the data generator process, \textit{I}, which creates the input that is broadcasted out on the network. The three \texttt{time} processes, hours (\textit{H}), minutes (\textit{M}), and seconds (\textit{S}) are the processes described above, which calculate each part of the current time. The outputs are communicated on the six outgoing channels.

The full SMEIL code for this example can be seen in Listing~\ref{lst:smeil} in  the appendix.

\section{Seven Segment Display Clock Transpiling}
In the following we use a classic hardware design to illustrate each of the steps in the transpiling, and how the types, constraints, and assertions are carried from the original SMEIL program into the \cspm{} program.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (sme) {SME};
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (smeil) [right=1cm of sme] {SMEIL};
    \node[mycircle, text width=2cm, inner sep=5pt, inner ysep=5pt] (transpiler) [right=1cm of smeil] {Transpiler};
    \node[myrectangle, text width=2cm, minimum height=1cm, inner sep=5pt, inner ysep=5pt] (cspm) [right=1cm of transpiler] {CSP$_M$};

    \draw[myarrow] (sme) -- (smeil);
    \draw[myarrow] (smeil) -- (transpiler);
    \draw[myarrow] (transpiler) -- (cspm);
  \end{tikzpicture}
  \caption{SME to \cspm{} transpiler.}
  \label{fig:sme-to-cspm}
\end{figure}

We wish to model the network presented in Section~\ref{sec:example-smeil} in SMEIL in order to transpile it to \cspm{} so that we may verify properties in FDR4. In Figure~\ref{fig:sme-to-cspm} the workflow of this system can be seen.

Even though SME buses can contain a series of channels, every single channel is translated into a \cspm{} channel. The properties we will assert with FDR4, are the width of the \cspm{} channels. That is, we want to prove that certain values will never be communicated on certain channels.
It is easy to imagine that 4 bits can be communicated between the \texttt{time} processes and the seven segment displays. But 4 bits can represent the numbers 0 through 15, and our seven segment displays can only display the numbers 0 through 9. Therefore we wish to assert that even though the channels can carry 4 bits, the actual communication on the six output channels does not exceed 9. In general, the displays will be able to display 0 through 9, but since the example is a clock showing a 24-hour interval, the displays will of course not be able to show minutes and seconds above 59 and hours above 23.

We know that a program in pure SMEIL must have a data generation process, but this is not the case in a CSP network. Since we are only transpiling from pure SMEIL networks, we can be certain that there will always be a process which just contributes an initial value to the rest of the network.
We also know that a process must either have communication in or out or both.
Therefore, we can assume that all SMEIL processes with no input bus will be a data generator process of some kind, and therefore must have some outwards communication.
So when transpiling to \cspm{}, we do not translate the SMEIL process to a \cspm{} process, but simply create a \cspm{} channel that represents the values communicated out of this SMEIL process.
\\

We assume that the SMEIL programs we transpile only contains channels with types and range annotations. During the simulation, the type will be restricted to the lowest representation possible. For example, if a channel was originally set to be \texttt{int} (unbounded), but the observed values from the simulation show that it could be changed to an \texttt{i8} (signed 8-bit integer with a range of -128 to 127), then the simulated output would be \texttt{i8}.

When creating channels in \cspm{}, we need to define its range of possible values. If a channel is only defined by having the integer type, FDR4 would try to verify for all possible integers, which results in a seemingly unbounded runtime. As explained in Section~\ref{SMEIL-section}, all simulated SMEIL programs will include the observed range and restricted types for all channels and variables. The types represent the observed width of the channels in bits, and by calculating the possible range from these types, we can create the corresponding channels in \cspm{}, and thereby avoid having a seemingly endless runtime in FDR4.

Since the assertion we wish to make is to verify the widths of the channels, it might seem redundant to create \cspm{} channels with a limited range. FDR4 would always only check the values in the defined channel range and therefore there is no point in asserting if the values go beyond this range. After simulating the SME network, SMEIL provides us with both a type and a range of observed values. The type is used to create the \cspm{} channel range and the observed values are used for the assertion. The type will always represent equal or more values than the range of observed values, and by using these values the assertions becomes valuable.
\\

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc seconds (in seconds_in)
    bus seconds_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var seconds: u6 range 1 to 59;
    var seconds_first_temp: u3 range 0 to 5;
    var seconds_second_temp: u4 range 0 to 9;
{
    seconds = seconds_in.val % 60;
    seconds_first_temp = seconds / 10;
    seconds_second_temp = seconds % 10;
    seconds_out.first_digit = seconds_first_temp;
    seconds_out.second_digit = seconds_second_temp;
}
\end{minted}
\caption{Example of the \texttt{seconds} process from the SMEIL seven segment display example. See full example in Listing~\ref{lst:smeil} in the appendix.}
\label{lst:range_smeil}
\end{listing}

When it comes to transpiling the data generator process into a \cspm{} channel, we also use the types of the SMEIL simulation to define it. We use this instead of the observed values because we cannot guarantee the precise input values of the system. If we used the observed values, the assertions will pass every time, since it will test the values already used to generate the rest of the observed values.

An example of simulated SMEIL code can be seen in Listing~\ref{lst:range_smeil}. Notice on lines 2 and 3 that the two channels are defined both with a type \texttt{u3} and \texttt{u4} and with a range 0 to 5 and 0 to 9. These are the observed types and value ranges the simulation tracked for the specific channel. In order to create the \cspm{} channels based on the types, we need to convert \texttt{u3} and \texttt{u4} into its corresponding range, which for \texttt{u3} is 0 through 7 and for \texttt{u4} is 0 through 15. In Listing~\ref{lst:channel_range_cspm} on lines 1 and 2, the calculated ranges are used to define the \cspm{} channels.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}

    |$\vdots$|

Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP
\end{minted}
\caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:channel_range_cspm}
\end{listing}

When creating the assertions, we decided to create separate assert functions to keep the code structure clean. We know that for each \cspm{} channel there must be an assertion, except for the input channel.
Consequently, we create a \textit{monitor} process for each channel and its only job is to listen in on the channel communication and assert the values communicated there. The monitor process is a process that we add specifically for asserting legal communication values in FDR4 and it does not affect the original SME network.
In Figure~\ref{fig:assertion_process} the outline of this kind of structure can be seen and we expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.

The monitor process asserts the observed values of the \cspm{} channels and in Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the Seconds \texttt{time} process can be seen. The values used for these statements are the observed values from the SMEIL simulation, as can be seen at the end of lines 2 and 3 in Listing~\ref{lst:range_smeil}. In Listing~\ref{lst:monitor_range_cspm} the ranges are used to assert that the only values communicated on the channels are within 0 and 5, and 0 and 9 respectively.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
\end{minted}
\caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:monitor_range_cspm}
\end{listing}
s

After translating the SMEIL processes and creating the monitor processes, we need to create the network described in the last part of the SMEIL program, see lines 53 to 59 in Listing~\ref{lst:smeil} in the appendix. We wish only to assert the values the \texttt{time} processes are communicating to the monitor processes, and therefore we have to synchronize these processes into a single network in \cspm{}. We create three network processes, one for each part of the network, and we create a nested synchronization, in order to have all monitor processes synchronized with the \texttt{time} process. An example of this network can be seen in on lines 61 to 66 in Listing~\ref{lst:cspm} in the appendix. This network process is also the process that receives the input from the input channel. By not adding the receiving communication in the \texttt{time} processes, we avoid having to specify the name of the input channels before creating the network which simplifies the translation, as described in Section~\ref{sec:transpiling}. In SMEIL, this information is part of the \texttt{network} section, and therefore it fits well within this part of the \cspm{} code.

After creating the network we add the actual assert function calls. For these kinds of assertions, where we want to check a range, the best solution is to assert that the network processes behave as the \texttt{SKIP} process. This is done by having the monitor process running the \texttt{SKIP} process if the value is within the range and the \texttt{STOP} process if not. Two examples can be seen in lines 2 and 4 in Listing~\ref{lst:monitor_range_cspm}. We assert this by using the FDR4 failures model on the the \texttt{SKIP} process along with hiding communication events, which can be seen in lines 68, 78 and 88 in Listing~\ref{lst:cspm} in the appendix.
\\

The different parts of transpiling the seven segment display example have been presented and in Figure~\ref{fig:cspm-network} the corresponding network of the \cspm{} system is presented.
The corresponding network in \cspm{} consists of 12 different processes, all created so that not only the network is simulated correctly, but also so the assertions we wish to make, are in place. The input is represented by a triangle, since it transpiles from an SME process to a \cspm{} channel. Each of the dotted squares represents the network of synchronizations for each \texttt{time} processes, which in itself is a process in \cspm{}. For each network, we have the \texttt{time} processes and two monitor processes, for example, $H$, $M_{H_1}$ and $M_{H_2}$.
\\

% Errornous example
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock_out_val : {0..131071}

channel hours_out_first_digit : {0..3}
channel hours_out_second_digit : {0..15}
    |$\vdots$|

Hours(hours_in) =
let
    hours = hours_in / 3600
    |$\vdots$|

Hours_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 2 then SKIP else STOP
Hours_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP

\end{minted}
\caption{Example of an erroneous version of the \texttt{Hours} process from the \cspm{} seven segment display example seen in Listing~\ref{lst:smeil} and in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:cspm_error}
\end{listing}

In order to show that the verification is accurate, the example in Listing~\ref{lst:cspm_error} contains an error that results in FDR4 failing the verification. In Listing~\ref{lst:cspm_error} the example is only able to handle an input that is below 24 hours. This is because the calculation in the \texttt{Hours} process does not handle the wrap around at the 24\textsuperscript{th} hour. This means that if the input represents more than 24 hours, the assertions will fail in FDR4 because one seven segment display suddenly has to display two digits instead of one. An example of such could be the input \texttt{131071}, which represents 36 hours, 24 minutes and 31 seconds, or 1 day, 12 hours, 24 minutes and 31 seconds. When trying to assert the code from Listing~\ref{lst:cspm_error} in FDR4, the assertion fails. The counterexample shows that the number 3 is communicated on \texttt{hours\_out\_first\_digit}, which is not allowed according to the monitor process on lines 12 and 13 in Listing~\ref{lst:cspm_error}.

This example of failure shows how verifying the solution with a tool like FDR4 actually catches errors that the programmer might have overseen. In this case, the error is simply corrected by adding \texttt{\% 24} on the end of line 9 in Listing~\ref{lst:cspm_error} and can be seen corrected in Listing~\ref{lst:cspm} in the appendix at line 15. Now when we try to assert the example in FDR4, it passes. By using modulo on the result, we ensure that we still get the accurate time of day, no matter how many full days the input represents.

The full SMEIL and \cspm{} code for the seven segment display example can be seen in Listing~\ref{lst:smeil} and in Listing~\ref{lst:cspm} in the appendix.
% Errornous example end

\section{Target solution}

\section{Manual translation}
The first step in translating from SMEIL to \cspm is to create a small example and create a manual translation. This ensures that we have a suitable example to test the automatic gode generation, but also gives a good understanding of how the translation could be created and what kind of challenges there will arise from translating from SMEIL to \cspm.
The example \textit{Seven segment example} is an example of modelling a digital clock that consists of 6 different 7-segment displays. A 7-segment display is a display device for displaying decimal numerals. It consist of 7 identical segments which can be lit in different combinations in order to show the Arabic numerals 0 to 9. In the example we model a circuit that receives an input in the form; "seconds after midnight" and from this, calculates and displays the correct hours, minutes and seconds on the displays. Since only one digit can be shown on each 7-segment display it is necessary to separate the actual number into two e.g if the hour is 12 it will be shown as 1 and 2 on two separate displays. \\ The SME example in figure \ref{seven_segments_exaple.sme} inputs a numeral from a source process that is incremented by one for each run. It then sends the input out on the output bus where three different calculating processes receives from. Each process calculates respectively hours, minutes and seconds and separates the number in order to output the result to the two output channels. \\ The \cspm code in figure \ref{seven_segments_exaple.csp} is the handmade translation from the SME file. \\ The translation in \cspm is equivalent to the SME version where each process calculates either the hours, minutes or seconds and separate the result into two digits, one for each output channel.\\
What we need to assert in this example is the number that is sent to the 7-segment displays. A 7 segment display can only represent 0-9 but 4 bits can represent 0-15. This means that we are interested in figuring out if this model can result in an ouput less that 10, in which case, the assertion fails and the model needs to be changed. The assertion used in \cspm checks if the processes refines the \texttt{SKIP} process i.e if the process terminates. This works because of the \texttt{if-then-else} statement that ensures that the process never stops (\texttt{STOP}) if one of the outputs are larger than 10. \\\\
One problem that arises when trying to translate SMEIL to \cspm, is that in SMEIL the input has to be generated by a process, i.e there is no input from file or stdout.
Therefore we create a source process, in this case the \texttt{clock()} process, that does not have any input but, in this case, generates a variable which is saved and incremented by one for each run.
Now, FDR checks all possible inputs and therefore we have to find a solution so that we can figure out the entire input range automatic.
The solution lies in the SMIEL simulator.
When simulating the sme program, it creates a range of all observed inputs on all channels in order to change the general \texttt{int} to e.g \texttt{i4} if all observed inputs are within i4.
Then we can observe and generalize that a process with no input bus will be the source process that generates the input for the circuit.
Due to this generalization, we can translate the output bus of the source process in sme to be the the input channel in \cspm.
That is, the range observed on the output bus in sme will be translated into the range of the input channel in \cspm.
So in reality the source process is not created as an actual process in \cspm and therefore it is also crucial that the source process in sme does not have hidden channels or do calculations that we wish to assert on. \\
In \cspm, one always note the input ranges of channel if the channel carries numerals. However if we simply write \texttt{channel input : int}, then FDR will check for all integers, which will last forever, therefore we wish to create the proper range on the input channel by using the source process in sme.
However for the rest of the circuit, we might need to assert on the input or output of the busses and therefore we do not wish to use the ranges from the sme simulator on other busses than the output bus from the source process.
Since it is necessary to give a range to all channels in \cspm, as mentioned above, the challenge lies in figuring out the correct ranges for these channels. \\

\begin{figure}
\label{seven_segments_exaple.sme}
\caption{Seven segments example in SMEIL}
\end{figure}


\begin{figure}
\label{seven_segments_exaple.csp}
\caption{Seven segments example in \cspm}
\end{figure}


\section{Automated translation}
 \textbf{It is important to mention that the FDR version of the SMEIL program are represented as one clock cycle and therefore we do not have to handle implicit clock cycle issues. we can just translate one-to-one, because FDR models one clock cycle and the input represents all possible input in one clock cycle.}

 \textbf{From my paper - the ANTLR section}
\subsection{ANTLR4}
For the transpiling between SMEIL source code and \cspm{} source code, we decided to use ANTLR4~\cite{antlr} for creating a parser and a lexer. ANTLR4 is a Java-based parser generator library that, based on a grammar, can generate parsers in Java or another target language. ANTLR4 provided a tool that could easily transform the given grammar into a parser and lexer that could immediately be used to transform into \cspm{}.

ANTLR takes a grammar, defined in .g4 (BKNF?) and create the parser and lexer of the files.

A lexical analysis, which is what the lexer does, is a process of converting a string of characters into tokens, which is also called tokenization. Each token represents a lexer rule in the grammer, for instance, if the string is "123" and there is a lexer rule "INT: {0-9}+" which means one or more of 0-9 digits. Then the token would be an INT.

A parser...\todo{write more here}

Currently, only a subset of the SMEIL grammar have been implemented for translating and parts of the grammar have been changed slightly to match the expectations from a simulated SMEIL program, which varies a bit from a non-simulated SMEIL program. An example of this could be that in the original SMEIL grammar a channel declaration only includes an optional range, however, we are expecting a simulated SMEIL program and therefore the simulation would always have generated ranges of observed values for each channel. Therefore, in the grammar, created for ANTLR4, the range for each channel must always be defined.

The ANTRL4 grammar is provided in a filetype called \texttt{.g4} but the structure of the grammar is similar to standard grammar notation.
After running ANTLR4 and generating a parser and a lexer, one can decide to traverse the parse tree itself or use a listener or visitor that ANTLR4 provides. The main difference between the two is that the methods the listener provides are called by the walker object, which ANTLR4 provides, and the visitor methods must call their children explicitly to walk them.
For our implementation, we used the ANTLR4 listener along with Python. When generating a parser and lexer for another target language than Java, the programmer only has to specify this in the ANTLR4 command in the command-line.


\chapter{Experiments and results}
\chapter{Discussion}

\section{Future Work}
With this work, we have taken a small step towards creating a simpler method for software developers to model hardware as well as verify properties within this model. In future work, we would like to extend this to software-hardware co-design, with which we would be able to assert deadlocks.

It would be desirable to be able to automatically create a human-readable report on the ranges and communications that are used within the system. This could become a standard addition to the documentation of the system, which would give a programmer an easy overview of a complicated system and would also allow for easier contemplation over the system.

Another, more complex idea for future work, is to implement support for multi-channel invariants. This is not something that can easily be simulated and therefore it would require some work, but it would provide the ability to express more complex assertions.

\section{Conclusions}
We have presented a transpiler that transpiles SME intermediate language (SMEIL) into \cspm{} for then to use the Failure-Divergences Refinement tool (FDR4) to assert properties in a \cspm{} network. We provide a simple approach that makes it more accessible for software programmers to program hardware and thereby bridging a gap between software programmers and the needs of the industry.
Instead of having to create advanced test-benches, our tool provides a simple way to verify the hardware model via FDR4s assertion functionalities. We can assert that the observed values of a channel, in a simulated SMEIL program, are in fact the only possible values communicated on that specific channel. We have also shown this to work in an example case of a seven segment display.

\section*{Acknowledgements}
Thanks to Uwe Zimmermann who made the seven segment example in TikZ on \url{http://www.texample.net/tikz/examples/segment-display/}.



\chapter{Conclusion}

\section{Future work}

\newpage
\bibliographystyle{abbrv}
\bibliography{library}

% Appendix
\appendix
\section{Paper}
% Add the paper as PDF here
\section*{Full SMEIL and \cspm code}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc clock ()
    bus clock_out {val: u17 range 1 to 86401;};
    var i: u17 = 0 range 0 to 86401;
{
    i = i + 1;
    clock_out.val = i;
}

proc hours (in hours_in)
    bus hours_out {first_digit: u2 range 0 to 2;
                   second_digit: u4 range 0 to 9;};
    var hours: u5 range 0 to 23;
    var hours_first_temp: u2 range 0 to 2;
    var hours_second_temp: u4 range 0 to 9;
{
    hours = hours_in.val / 3600 % 24;
    hours_first_temp = hours / 10;
    hours_second_temp = hours % 10;
    hours_out.first_digit = hours_first_temp;
    hours_out.second_digit = hours_second_temp;
}

proc minutes (in minutes_in)
    bus minutes_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var minutes: u6 range 0 to 59;
    var minutes_first_temp: u3 range 0 to 5;
    var minutes_second_temp: u4 range 0 to 9;

{
    minutes = minutes_in.val / 60 % 60;
    minutes_first_temp = minutes / 10;
    minutes_second_temp = minutes % 10;
    minutes_out.first_digit = minutes_first_temp;
    minutes_out.second_digit = minutes_second_temp;
}


proc seconds (in seconds_in)
    bus seconds_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var seconds: u6 range 0 to 59;
    var seconds_first_temp: u3 range 0 to 5;
    var seconds_second_temp: u4 range 0 to 9;
{
    seconds = seconds_in.val % 60;
    seconds_first_temp = seconds / 10;
    seconds_second_temp = seconds % 10;
    seconds_out.first_digit = seconds_first_temp;
    seconds_out.second_digit = seconds_second_temp;
}

network clock_network ()
{
    instance g of clock();
    instance h of hours(g.clock_out);
    instance m of minutes(g.clock_out);
    instance s of seconds(g.clock_out);
}

\end{minted}
\captionof{listing}{The full SMEIL code used for transpiling in the seven segment display example.\label{lst:smeil}}

\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock_out_val : {0..131071}

channel hours_out_first_digit : {0..3}
channel hours_out_second_digit : {0..15}

channel minutes_out_first_digit : {0..7}
channel minutes_out_second_digit : {0..15}

channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}


Hours(hours_in) =
let
    hours = hours_in / 3600  % 24
    hours_first_temp = hours / 10
    hours_second_temp = hours % 10
within
    hours_out_first_digit ! hours_first_temp ->
    hours_out_second_digit ! hours_second_temp ->
    SKIP

Hours_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 2 then SKIP else STOP
Hours_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


Minutes(minutes_in) =
let
    minutes = minutes_in / 60  % 60
    minutes_first_temp = minutes / 10
    minutes_second_temp = minutes % 10
within
    minutes_out_first_digit ! minutes_first_temp ->
    minutes_out_second_digit ! minutes_second_temp ->
    SKIP

Minutes_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Minutes_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP

Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP


N_hours = clock_out_val ? variable ->
          (Hours(variable)
          [| {| hours_out_first_digit|} |]
          Hours_out_first_digit_monitor(hours_out_first_digit))
          [| {| hours_out_second_digit|} |]
          Hours_out_second_digit_monitor(hours_out_second_digit)

assert SKIP [F= N_hours \ Events


N_minutes = clock_out_val ? variable ->
            (Minutes(variable)
            [| {| minutes_out_first_digit|} |]
            Minutes_out_first_digit_monitor(minutes_out_first_digit))
            [| {| minutes_out_second_digit|} |]
            Minutes_out_second_digit_monitor(minutes_out_second_digit)

assert SKIP [F= N_minutes \ Events


N_seconds = clock_out_val ? variable ->
            (Seconds(variable)
            [| {| seconds_out_first_digit|} |]
            Seconds_out_first_digit_monitor(seconds_out_first_digit))
            [| {| seconds_out_second_digit|} |]
            Seconds_out_second_digit_monitor(seconds_out_second_digit)

assert SKIP [F= N_seconds \ Events

\end{minted}
\captionof{listing}{The full \cspm{} code after transpiling the seven segment display example, as seen in Listing~\ref{lst:smeil} in the appendix.\label{lst:cspm}}


\end{document}
