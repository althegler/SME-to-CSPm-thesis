\documentclass[a4paper]{report}

\usepackage[latin1]{inputenc}
\usepackage{palatino}
\usepackage[usenames]{color}

\usepackage{hyperref}

\usepackage{chngpage}
\usepackage{graphicx}

\usepackage{booktabs}
\usepackage{multirow}

\usepackage[]{algorithm2e}
\usepackage{varwidth}

\usepackage{setspace}
\usepackage{hyperref}

\usepackage{todonotes}


\usepackage[babel, en, nat, farve, titelside]{ku-forside}

% (asbjoern commando: nbuf command)
% \newcommand{\nbuf}{\textit{nbuf} }

\usepackage{fancyhdr}
\pagestyle{fancy}

\lhead{Alberte Thegler}
\chead{Master's Thesis}
\rhead{August 2018}

\renewcommand{\headrulewidth}{0.4pt} % thickness of line at header
\renewcommand{\footrulewidth}{0.4pt} % thickness of line at footer
\setlength{\belowcaptionskip}{-10pt} % space below captions


\opgave{Master's Thesis}
\title{Towards formal verification of FDR4}
\undertitel{Department of Computer Science}
\author{Alberte Thegler - alberte@thegler.dk}
\date{August 2018}
\vejleder{Professor Brian Vinter}

\begin{document}

\maketitle

\pagenumbering{roman}
\begin{abstract}
\begin{doublespace}
Bla bla 
bla bla


\end{doublespace}
\end{abstract}



\newpage
\tableofcontents

\newpage
\listoftodos
\newpage
\pagenumbering{arabic}
\chapter{Introduction}
When we create programs, we wish to verify that it is also correct. There are several ways to do this, one commenly used is \texttt{testing} which require that the programmer creates several different scenarios and its expected output, or that the programmer programs a test-generator to create the scenarios and expected output. This, however, is not adequate for (word for important systens). Therefore it is of high interest to create a verification of the system or program.\\
Talk about how verification was first created and how it became to be used for concurrent systems. Then write about how it works and then write about the different systems and formal languages that is used for it. 


In this thesis we look at model checking, that is, verifying that a specific property will always hold for a piece of code.


Formal verification is the process of checking whether a program satisfies specific properties. Different methods have evolved, all having different advantages and disadvantages. FDR is sometimes referred to as a model checker however is it actually a refinement checker.



\textbf{Matematicians tend to reject proofs by exhaustive checking of all cases as being less satisfying than deductive proofs, and with good reason. First, they are not applicable for proving theorems about integers and real numbers, which are infinite domains so that the number of interpretations is infinite and they cannot be exhaustively checked. Second, they offer no insight into why a theorem is true. But computer scientists have more practical concerns. If they can check all computations of a program and show that they all satisfy a correctness property, we will be willing to forego elegance and be more than satisfied that our program has been proven correct. (from "A primer on model checking af Ben-Ari} 
\section{Learning goals}
This is where the learning goals go.
\chapter{Related work}
\textbf{Related work should be about describing the history of formal verification and formal languages in both software and hardware.}

In 1969, Tony Hoare proposed the Hoare logic\cite{Hoare1969} in his paper \textit{An axiomtic basis for computer programming}. He proposed that a program could be viewed as a  
partial correctness relation between a precondition and a postcondition predicate. This means that if the state the program starts in satisfies the precondition and it terminates, then the final state satisfies the postcondition.\\ Hoare was much inspired by Robert W. Floyd, who had published his paper \textit{Assigning meaning to programs}\cite{Floyd1967} a few years before. The paper described a method for proving the partial correctness of a program by using flowcharts and Hoare's logic provided a good way of formulating Floyd's method.

A lot of verification systems used today is based on Hoare logic. Hoare was much inpired by Robert W. Floyd, who a few years before had published 
Several different software verification tools exists today, and they all have different advantages.




SPIN \todo{Add reference to SPIN} is a verification system that uses process interactions to prove correctness for a system. The system is described in the formal language \texttt{PROMELA}(PROcess MEta LAnguage)\todo{add reference to promela} and the correctness properties are spcified in Linear Temporal Logic or LTL \todo{add reference to Linear Temporal Logic}. Spin was developed at Bell Labs, starting in 1980. Since 1991 it has been freely available and today it is used by thousands of people worldwide.\\
The job is to find other types of models and compare them, as well as the types of languages. so different tools and different languages.. 

Occam-pi is a programming language that came from occam and was merged with pi-calculus. 


\textbf{The two most popular methods for automatic formal verification are language containment and model checking. The current version of VIS emphasizes model checking, but it also offers to the user a limited form of language containment (language emptiness)." from https://embedded.eecs.berkeley.edu/research/vis/doc/VisUser/vis\_user/node4.html}






\chapter{Theory}
\textbf{This is where the theory go. fx. SME and the correlation between that and CSP.}
\chapter{Method}
\textbf{This is the method section that describes what I did, how and why.}
\chapter{Results and tests (Experiment?)}
\textbf{Does it work? why, why not}
\chapter{Discussion}

\chapter{Conclusion}
\section{Future work}

\newpage
\bibliographystyle{abbrv}
\bibliography{library}

\section{Appendix}
\end{document}
