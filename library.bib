Automatically generated by Mendeley Desktop 1.19.2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Bengtsson1995,
abstract = {Uppaal is a tool suite for automatic veri cation of safety and bounded liveness properties of real-time systems modeled as networks of timed automata. It includes: a graphical interface that supports graphical and textual representations of networks of timed automata, and automatic transformation from graphical representations to textual format, a compiler that transforms a certain class of linear hybrid systems to networks of timed automata, and a model checker which is implemented based on constraint solving techniques. Uppaal also supports diagnostic model-checking providing diagnostic information in case veri cation of a particular real-time systems fails. The current version of Uppaal is available on the World Wide Web via the Uppaal home page http: www.docs.uu.se docs rtmv uppaal.},
author = {Bengtsson, Johan and Larsen, Kim G and Larsson, Fredrik and Pettersson, Paul and Yi, Wang},
isbn = {354061155X},
journal = {Proceedings of the 4th DIMACS Workshop on Verification and Control of Hybrid Systems},
number = {1066},
pages = {232--243},
title = {{UPPAAL - a Tool Suite for Automatic Verifcation of Real-Time Systems}},
year = {1995}
}
@article{Ouakninet,
author = {Ouakninet, Joel},
title = {{A Framework for Model-Checking Timed CSP * t}}
}
@article{Henzinger1994,
abstract = {We describe finite-state programs over real-numbered time in a guarded-command language with real-valued clocks or, equivalently, as finite automata with real-valued clocks. Model checking answers the question which states of a real-time program satisfy a branching-time specification (given in an extension of CTL with clock variables). We develop an algorithm that computes this set of states symbolically as a fixpoint of a functional on state predicates, without constructing the state space. For this purpose, we introduce a $\mu$-calculus on computation trees over real-numbered time. Unfortunately, many standard program properties, such as response for all nonzeno execution sequences (during which time diverges), cannot be characterized by fixpoints: we show that the expressiveness of the timed $\mu$-calculus is incomparable to the expressiveness of timed CTL. Fortunately, this result does not impair the symbolic verification of "implementable" real-time programs-those whose safety constraints are machine-closed with respect to diverging time and whose fairness constraints are restricted to finite upper bounds on clock values. All timed CTL properties of such programs are shown to be computable as finitely approximable fixpoints in a simple decidable theory.},
author = {Henzinger, Thomas A. and Nicollin, Xavier and Sifakis, Joseph and Yovine, Sergio},
journal = {Information and Computation},
pages = {193--244},
title = {{Symbolic model checking for real-time systems}},
year = {1994}
}
@inproceedings{Alur1990,
annote = {I do not have this paper on hand!},
author = {Alur, Rajeev and Dill, David},
booktitle = {Automata, Languages and Programming},
pages = {322--335},
title = {{Automata for modeling real-time systems}},
year = {1990}
}
@article{Allen1997a,
abstract = {As software systems become more complex, the overall system structure—or software architecture—becomes a central design problem. An important step toward an engineering discipline of software is a formal basis for describing and analyzing these designs. In the article we present a formal approach to one aspect of architectural design: the interactions among components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We further provide a formal semantics and show how this leads to a system in which architectural compatibility can be checked in a way analogous to type-checking in programming languages.},
author = {Allen, Robert and Garlan, David},
doi = {10.1145/258077.258078},
isbn = {1049-331X},
issn = {1049331X},
journal = {ACM Transactions on Software Engineering and Methodology},
keywords = {Formal models,WRIGHT,model-checking,module interconnection,software analysis},
number = {3},
pages = {213--249},
pmid = {6933516898357064178},
title = {{A formal basis for architectural connection}},
url = {http://portal.acm.org/citation.cfm?doid=258077.258078},
volume = {6},
year = {1997}
}
@misc{fdr_example,
title = {{FDR4 manual example files}},
url = {https://www.cs.ox.ac.uk/projects/fdr/manual/examples/index.html},
urldate = {2018-10-06}
}
@book{Parr2012,
author = {Parr, Terence},
pages = {319},
publisher = {The Pragmatic Programmers, LLC},
title = {{The Definitive ANTLR 4 Reference}},
year = {2012}
}
@misc{Vardi1994,
abstract = {We investigate extensions of temporal logic by connectives defined by finite automata on infinite words. We consider three different logics, corresponding to three different types of acceptance conditions (finite, looping, and repeating) for the automata. It turns out, however that these logics all have the same expressive power and that their decision problems are all PSPACE-complete. We also investigate connectives defined by alternating automata and show that they do not increase the expressive power of the logic or the complexity of the decision problem.},
author = {Vardi, Moshh Y. and Wolper, Pierre},
booktitle = {Information and Computation},
doi = {10.1006/inco.1994.1092},
isbn = {0-8186-0508-1},
issn = {10902651},
number = {1},
pages = {1--37},
title = {{Reasoning about Infinite Computations}},
volume = {115},
year = {1994}
}
@unpublished{smeil,
annote = {To be published},
author = {Asheim, Truls},
title = {{SMEIL: A Domain-Specific Language for Synchronous Message Exchange Networks}},
year = {2018}
}
@misc{Roscoe1995,
author = {Roscoe, A. W.},
title = {{Model-checking CSP}},
year = {1995}
}
@article{Holzmann1997,
abstract = {SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.},
author = {Holzmann, Gerard J},
keywords = {Formal methods,concurrency.,design verification,distributed systems,model checking,program verification},
number = {5},
pages = {279--295},
title = {{The Model Checker SPIN}},
volume = {23},
year = {1997}
}
@article{Raju2003,
abstract = {We present tools that automatically convert a subset of machine-readable CSPscript to executable Java or C code. CSP is used to design and verify thecorrectness of large and complex systems of processes that interact only viaexplicit synchronous messages. These systems can be implemented in Javausing CTJ or JCSP, packages that add CSP-like features to Java, or in CCSP, apackage that adds similar features to standard C. Implementation of CSP systemscan be tedious and error-prone when large numbers of processes andcommunications are involved, and sorting out errors in channel naming or theordering of messages can be very time-consuming. The tools we have developedminimize such problems by converting the verified CSP descriptions ofcommunicating processes directly into Java or C code, thus guaranteeing thatchannels are correctly named and the communications occur in the proper order.This process can significantly cut development time.},
author = {Raju, V. and Rong, L. and Stiles, G. S.},
isbn = {1 58603 381 6},
issn = {13837575},
journal = {Communicating Process Architectures 2003},
pages = {63--81},
title = {{Automatic Conversion of CSP to CTJ, JCSP, and CCSP}},
year = {2003}
}
@manual{fdrmanual,
author = {{Thomas Gibson-Robinson Philip Armstrong}, Alexandre Boulgakov A W Roscoe},
title = {{Failures Divergences Refinement (FDR) Version 3}},
url = {https://www.cs.ox.ac.uk/projects/fdr/},
year = {2013}
}
@article{Scattergood2011,
author = {Scattergood, Bryan and Armstrong, Philip},
title = {{CSPM: A Reference Manual}},
url = {http://www.cs.ox.ac.uk/ucs/cspm.pdf},
year = {2011}
}
@book{Holzmann1991,
author = {Holzmann, G J},
isbn = {0135399254, 9780135399255},
publisher = {Prentice Hall},
title = {{Design and Validation of Computer Protocols}},
year = {1991}
}
@inproceedings{10.1007/978-3-540-73370-6_15,
abstract = {We present an approach for the verification of spatial properties with Spin. We first extend one of Spin's main property specification mechanisms, i.e., the linear-time temporal logic LTL, with spatial connectives that allow us to restrict the reasoning of the behaviour of a system to some components of the system, only. For instance, one can express whether the system can reach a certain state from which a subset of processes can evolve alone until some property is fulfilled. We give a model checking algorithm for the logic and propose how Spin can be minimally extended to include the algorithm. We also discuss potential improvements to mitigate the exponential complexity introduced by spatial connectives. Finally, we present some experiments that compare our Spin extension with a spatial model checker for the {\$}\pi{\$}-calculus.},
address = {Berlin, Heidelberg},
author = {{Lluch Lafuente}, Alberto},
booktitle = {Model Checking Software},
editor = {Bo{\v{s}}na{\v{c}}ki, Dragan and Edelkamp, Stefan},
isbn = {978-3-540-73370-6},
pages = {223--242},
publisher = {Springer Berlin Heidelberg},
title = {{Towards Model Checking Spatial Properties with SPIN}},
year = {2007}
}
@article{kepner2004hpc,
author = {Kepner, Jeremy},
journal = {The International Journal of High Performance Computing Applications},
number = {4},
pages = {393--397},
publisher = {Sage Publications Sage CA: Thousand Oaks, CA},
title = {{HPC productivity: An overarching view}},
volume = {18},
year = {2004}
}
@book{Abdallah2005,
archivePrefix = {arXiv},
arxivId = {9780201398298},
author = {Abdallah, A E and Jones, C B and Sanders, J W},
doi = {10.1007/3-540-68339-9_34},
eprint = {9780201398298},
isbn = {9783540258131},
issn = {0302-9743},
pmid = {4520227},
title = {{Communicating Sequential Processes. The First 25 Years: Symposium on the Occasion of 25 Years of CSP, London, UK, July 7-8, 2004. Revised Invited Papers}},
url = {http://books.google.no/books?id=Q7SCim{\_}-8VEC},
year = {2005}
}
@article{Pedersen2018,
author = {Pedersen, Jan B. and Welch, Peter H.},
doi = {10.1007/s00165-017-0447-x},
issn = {0934-5043},
journal = {Formal Aspects of Computing},
keywords = {CSP,Concurrency,Deadlock,Event ordering,Liveness,Occam-pi,Verification,proxwaa-orientation},
number = {2},
pages = {239--277},
publisher = {Springer London},
title = {{The symbiosis of concurrency and verification: teaching and case studies}},
url = {http://link.springer.com/10.1007/s00165-017-0447-x},
volume = {30},
year = {2018}
}
@inproceedings{Leuschel2008a,
abstract = {We present a new animation and model checking tool for CSP. The tool covers the CSP-M language, as supported by existing tools such as fdr and probe. Compared to those tools, it provides visual feedback in the source code, has an LTL model checker and can be used for combined CSP || B specifications. During the development of the tool some intricate issues were uncovered with the CSP-M language. We discuss those issues, and provide suggestions for improvement. We also explain how we have ensured conformance with fdr, by using fdr itself to validate our tool's output. We also provide empirical evidence on the performance of our tool compared to fdr, showing that it can be used on industrial-strength specifications.},
address = {Berlin, Heidelberg},
author = {Leuschel, Michael and Fontaine, Marc},
booktitle = {Formal Methods and Software Engineering},
editor = {Liu, Shaoying and Maibaum, Tom and Araki, Keijiro},
isbn = {978-3-540-88194-0},
pages = {278--297},
publisher = {Springer Berlin Heidelberg},
title = {{Probing the Depths of CSP-M: A New fdr-Compliant Validation Tool}},
year = {2008}
}
@article{Dibley2018,
author = {Dibley, James and Bradshaw, Karen},
journal = {Communicating Process Architectures 2018},
keywords = {communicating sequential processes,concurrency,go,model checking,software prototyping,software synthesis,translation,verification},
pages = {1--20},
title = {{Deriving Reusable Go Components from Verified CSP Prototypes}},
year = {2018}
}
@misc{asheim2015,
annote = {Bachelor's Thesis},
author = {Asheim, Truls},
title = {{Implementing High Performance Synchronous Message Exchange}},
year = {2015}
}
@article{Lamport1980,
abstract = {Hoare's logical system for specifying and proving partial correctness properties of sequential programs is generalized to concurrent programs. The basic idea is to define the assertion {\{} P {\}} S {\{} Q {\}} to mean that if execution is begun anywhere in S with P true, then P will remain true until S terminates, and Q will be true if and when S terminates. The predicates P and Q may depend upon program control locations as well as upon the values of variables. A system of inference rules and axiom schemas is given, and a formal correctness proof for a simple program is outlined. We show that by specifying certain requirements for the unimplemented parts, correctness properties can be proved without completely implementing the program. The relation to Pnueli's temporal logic formalism is also discussed.},
author = {Lamport, Leslie},
doi = {10.1007/BF00289062},
issn = {00015903},
journal = {Acta Informatica},
number = {1},
pages = {21--37},
title = {{The 'Hoare logic' of concurrent programs}},
volume = {14},
year = {1980}
}
@article{Skovhedea,
abstract = {This paper introduces a multi-language simulation and code generation capability for programs written with Synchronous Message Exchange. We show how to use Synchronous Message Exchange to build and verify process-oriented networks that can be translated into C++ and VHDL. This approach gives the developer freedom in choosing the optimal implemen- tation, and enables experimentations with hardware/software co-design. The emitted C++ can also be used to simulate the FPGA implementation inside software, thus enabling a faster development and debugging workflow. We describe the translation process and evaluate the performance of the generated code.},
author = {Skovhede, Kenneth and Vinter, Brian},
pages = {8},
title = {{C ++ support for better hardware / software co-design in C {\#} with SME}}
}
@article{Sun2009,
abstract = {Recent development on distributed systems has shown that a variety of fairness constraints (some of which are only recently defined) play vital roles in designing self-stabilizing population protocols. Current practice of system analysis is, however, deficient under fairness. In this work, we present PAT, a toolkit for flexible and efficient system analysis under fairness. A unified algorithm is proposed to model check systems with a variety of fairness effectively in two different settings. Empirical evaluation shows that PAT complements existing model checkers in terms of fairness. We report that previously unknown bugs have been revealed using PAT against systems functioning under strong global fairness.},
author = {Sun, Jun and Liu, Yang and Dong, Jin Song and Pang, Jun},
doi = {10.1007/978-3-642-02658-4_59},
isbn = {3642026575},
issn = {03029743},
pages = {709--714},
title = {{PAT: Towards flexible verification under fairness}},
year = {2009}
}
@misc{InquiryBoard1996,
author = {{Inquiry Board}},
title = {{Adriane 5 Flight 501 Failure}},
url = {http://www-users.math.umn.edu/{~}arnold/disasters/ariane5rep.html},
urldate = {2018-09-24},
year = {1996}
}
@misc{spin,
author = {Labs, Bell},
title = {{SPIN}},
url = {http://spinroot.com/spin/whatispin.html}
}
@article{Armstrong2012,
author = {Armstrong, Philip and Lowe, Gavin},
journal = {Philip Armstrong Gavin Lowe A.W. Roscoe Jo{\"{e}}l Ouaknine},
number = {March},
pages = {1--21},
title = {{Model checking Timed CSP}},
url = {http://www.cs.ox.ac.uk/people/joel.ouaknine/publications/timedcsp12.pdf},
volume = {2},
year = {2012}
}
@techreport{Milner1972,
author = {Milner, Robin},
pages = {40},
title = {{Logic For Computable Functions Description of a Machine Implementation}},
year = {1972}
}
@misc{pysme,
annote = {[Online; accessed April 2018]},
author = {Asheim, Truls},
title = {{PySME source code}},
url = {https://github.com/truls/pysme},
urldate = {2018-11-03}
}
@article{Armstrong2011,
author = {Armstrong, Philip and {Gavin Lowe} and {Jo{\"{e}}l Ouaknine} and {A.W. Roscoe}},
title = {{Model checking Timed CSP}},
year = {2011}
}
@misc{UniveristyofKent,
author = {{Univeristy of Kent}},
title = {{occam-pi: blending the best of CSP and the pi-calculus}},
url = {https://www.cs.kent.ac.uk/projects/ofa/kroc/{\#}pubs},
urldate = {2018-04-22}
}
@inproceedings{fdr,
author = {Gibson-Robinson, Thomas and Armstrong, Philip and Boulgakov, Alexandre and Roscoe, A W},
booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
editor = {{\'{A}}brah{\'{a}}m, Erika and Havelund, Klaus},
pages = {187--201},
series = {Lecture Notes in Computer Science},
title = {{FDR3 --- A Modern Refinement Checker for CSP}},
volume = {8413},
year = {2014}
}
@inproceedings{bjorndalen2007pycsp,
author = {Bj{\o}rndalen, John Markus and Vinter, Brian and Anshus, Otto J},
booktitle = {Cpa},
pages = {229--248},
title = {{PyCSP-Communicating Sequential Processes for Python.}},
year = {2007}
}
@article{Vinter2015,
abstract = {In this work we present a new design and implementation of the Syn- chronous Message Exchange model. The new version uses explicit busses, which may include multiple fields, and where a components may use a bus for both reading and writing, whereas the original version allowed only reading from or writing to a bus, which triggered a need for some busses to exist in two versions for different direc- tions. In addition to the new and improved bus-model, the new SME version also pro- duces traces that may be used for validating a later VHDL implementation of the de- signed component, and can produce a graphical representation of a design to help with debugging.},
author = {Vinter, Brian and Skovhede, Kenneth},
keywords = {FPGA,PyCSP,Scientific Byte Code,Synchronous Messaging},
number = {August},
title = {{Bus Centric Synchronous Message Exchange for Hardware Designs}},
year = {2015}
}
@inproceedings{Agrawal:1985:VDP:320599.322570,
address = {New York, NY, USA},
author = {Agrawal, Vishwani and Poon, Samuel H C},
booktitle = {Proceedings of the 1985 ACM Thirteenth Annual Conference on Computer Science},
doi = {10.1145/320599.322570},
isbn = {0-89791-150-4},
pages = {74--78},
publisher = {ACM},
series = {CSC '85},
title = {{VLSI Design Process}},
url = {http://doi.acm.org/10.1145/320599.322570},
year = {1985}
}
@article{Leveson1993,
author = {Leveson, N.G. and Turner, C.S.},
doi = {10.1109/MC.1993.274940},
issn = {0018-9162},
journal = {Computer},
number = {7},
pages = {18--41},
title = {{An investigation of the Therac-25 accidents}},
url = {http://ieeexplore.ieee.org/document/274940/},
volume = {26},
year = {1993}
}
@misc{ProB,
author = {Heinrich-Heine-University},
title = {{ProB}},
url = {https://www3.hhu.de/stups/prob/index.php/Main{\_}Page},
urldate = {2018-04-06},
year = {2017}
}
@misc{UniversityofOxford,
author = {{University of Oxford.}},
title = {{FDR Documentation}},
url = {https://www.cs.ox.ac.uk/projects/fdr/manual/},
urldate = {2018-10-06}
}
@misc{Vardi1986,
abstract = {We describe an automata-theoretic approach to automatic verification of concurrent finite-state programs by model checking. The basic idea underlying this approach is that for any temporal formula we can construct an automaton that accepts precisely the computations that satisfy the formula. The model-checking algorithm that results from this approach is much simpler and cleaner than tableau-based algortihms. We use this approach to extend model checking to probabilistic concurrent finite-state programs.},
author = {Vardi, M Y and Wolper, P},
booktitle = {Lics},
doi = {10.1234/12345678},
isbn = {0818607203},
pages = {332--344},
title = {{An automata-theoretic approach to automatic program verification}},
url = {http://hdl.handle.net/2268/116609{\%}5Cnhttp://www.cs.utep.edu/sroach/F07-5383/AutomataTheoretic-Approach-SPIN-lics86.pdf},
year = {1986}
}
@misc{Hoare1969,
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantages, both theoretical and practical, may follow from a pursuance of these topics.},
author = {Hoare, C. A. R.},
booktitle = {Communications of the ACM},
doi = {10.1145/363235.363259},
isbn = {0001-0782},
issn = {00010782},
number = {10},
pages = {576--580},
title = {{An axiomatic basis for computer programming}},
url = {http://portal.acm.org/citation.cfm?doid=363235.363259},
volume = {12},
year = {1969}
}
@article{Floyd1967,
author = {Floyd, Robert W.},
doi = {10.1007/978-94-011-1793-7_4},
isbn = {0821813196},
issn = {01460404},
pages = {19--32},
pmid = {17389487},
title = {{Assigning Meanings to Programs}},
url = {http://www.springerlink.com/index/10.1007/978-94-011-1793-7{\_}4},
year = {1967}
}
@misc{Go,
title = {{Go Project. The Go programming language}},
url = {https://golang.org},
urldate = {2018-10-15}
}
@misc{antlr,
annote = {[Online; accessed June 2018]},
howpublished = {$\backslash$url{\{}http://www.antlr.org/{\}}},
title = {{ANTLR4}}
}
@inproceedings{Larsen1995,
abstract = {Efficient automatic model-checking algorithms for real-time systems have been obtained in recent years based on the state-region graph technique of Alur, Courcoubetis and Dill. However, these algorithms are faced with two potential types of explosion arising from parallel composition: explosion in the space of control nodes, and explosion in the region space over clock-variables.},
address = {Berlin, Heidelberg},
annote = {I do not have this paper on hand right now},
author = {Larsen, Kim G and Pettersson, Paul and Yi, Wang},
booktitle = {Fundamentals of Computation Theory},
editor = {Reichel, Horst},
isbn = {978-3-540-44770-2},
pages = {62--88},
publisher = {Springer Berlin Heidelberg},
title = {{Model-checking for real-time systems}},
year = {1995}
}
@article{Pnueli1977,
abstract = {A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs.},
author = {Pnueli, Amir},
doi = {10.1109/SFCS.1977.32},
isbn = {0272-5428},
issn = {0272-5428},
journal = {18th Annual Symposium on Foundations of Computer Science (sfcs 1977)},
pages = {46--57},
title = {{The temporal logic of programs}},
url = {http://ieeexplore.ieee.org/document/4567924/},
year = {1977}
}
@misc{coq,
title = {{The Coq Proof Assistant}},
url = {https://coq.inria.fr/},
urldate = {2018-10-14}
}
@article{asheim2016vhdl,
abstract = {The Synchronous Message Exchange, SME, is a programming model that both resembles communication in hardware, and can be implemented as a CSP net- work. This paper extends on previous work for modeling hardware-like programs us- ing SME in Python, with the addition of a source-to-source compiler that converts an SME network implemented in Python to an equivalent implementation in VHDL. We describe the challenges, constraints, and solutions involved in translating a highly dynamic language like Python into the hardware-like VHDL language. We also show how the approach can assist in further VHDL refinement by generating tedious test bench code, such that VHDL designs can be simulated and verified with vendor sup- plied simulation and synthesis tools.},
author = {Asheim, Truls and Vinter, Brian and Skovhede, Kenneth},
keywords = {CSP,FPGA,HLS,Haskell,Python,VHDL,synchronous messaging,transpiler},
number = {September},
pages = {23},
title = {{VHDL Generation From Python Synchronous Message Exchange Networks}},
year = {2016}
}
@inproceedings{Oliveira2007,
abstract = {The complexity inherent to concurrent systems can turn their development into a very complex and error-prone task. The use of formal languages like CSP and tools that support them simplifies considerably the task of developing such systems. This process, however, usually aims at reaching an executable program: a translation between the specification language and a practical programming language is still needed and is usually rather problematic. In this paper we present a translation framework and a tool, csp2hc, that implements it. This framework provides an automatic translation from a subset of CSP to Handel-C, a programming language that is similar to standard C, but whose programs can be converted to produce files to program an FPGA.},
address = {Berlin, Heidelberg},
author = {Oliveira, Marcel and Woodcock, Jim},
booktitle = {Formal Methods and Software Engineering},
editor = {Butler, Michael and Hinchey, Michael G and Larrondo-Petrie, Mar{\'{i}}a M},
isbn = {978-3-540-76650-6},
pages = {286--306},
publisher = {Springer Berlin Heidelberg},
title = {{Automatic Generation of Verified Concurrent Hardware}},
year = {2007}
}
@phdthesis{Asheim2018,
author = {Asheim, Truls},
school = {University of Copenhagen, Niels Bohr Institute},
title = {{A Domain Specific Language for Synchronous Message Exchange Networks}},
type = {masterthesis},
year = {2018}
}
@article{Isobe2005,
author = {Isobe, Y and Roggenbach, Markus},
doi = {10.1007/978-3-540-31980-1_8},
isbn = {3-540-25333-5},
issn = {03029743},
journal = {Tools and Algorithms for the Construction and Analysis of Systems, Proceedings},
pages = {108--123},
title = {{A generic theorem prover of CSP refinement}},
volume = {3440},
year = {2005}
}
@article{coussy2009introduction,
author = {Coussy, Philippe and Gajski, Daniel D and Meredith, Michael and Takach, Andres},
journal = {IEEE Design {\&} Test of Computers},
number = {4},
pages = {8--17},
publisher = {IEEE},
title = {{An introduction to high-level synthesis}},
volume = {26},
year = {2009}
}
@article{REED1988249,
author = {Reed, G M and Roscoe, A W},
doi = {https://doi.org/10.1016/0304-3975(88)90030-8},
issn = {0304-3975},
journal = {Theoretical Computer Science},
number = {1},
pages = {249--261},
title = {{A timed model for communicating sequential processes}},
url = {http://www.sciencedirect.com/science/article/pii/0304397588900308},
volume = {58},
year = {1988}
}
@article{Rehr2013,
author = {Rehr, Martin and Skovhede, Kenneth and Vinter, Brian},
journal = {Communicating Process Architectures},
keywords = {fpga,pycsp,scientific byte code},
pages = {233--248},
title = {{BPU Simulator}},
year = {2013}
}
@article{Zhou2000,
abstract = {This report discusses the design and implementation of a package of Mathematica-based tools for serializing scripts describing the behavior of concurrent systems in CSP. Under some conditions, serialization can yield code that is more efficient than multi-process versions and can better meet processor constraints. Under most conditions concurrent design is easier and more reliable so we prefer to design concurrently and only implement serially when necessary. The tools include a set of definitions and procedures to automatically change concurrent code to serial code. Conversions of the following step laws have been implemented thus far: external choice, generalized parallel, and alphabetized parallel; additional laws will be implemented in the next month or so. The tools support the input of the more formal typeset notation of CSP, which makes the script writing intuitive, and can convert the typeset version to the machine-readable version required by software such as FDR. The correctness of the conversions has been checked with the FDR package. This package should be of use to both those regularly working on concurrent systems and those learning CSP.},
author = {Zhou, Weiyang and Stiles, G. S.},
isbn = {1 58603 077 9},
journal = {Communicating Process Architectures},
pages = {15--32},
title = {{The Automated Serialization of Concurrent CSP Scripts using Mathematica}},
year = {2000}
}
@article{Skovhede,
abstract = {This paper introduces a method for modeling hardware in the C{\#} language , using an abstraction called Synchronous Message Exchange . We describe how Synchronous Message Exchange helps model hardware from a high - level language , and describe the process used in automatically transpiling a subset of C{\#} models into standard VHDL . We evaluate the approach with a set of examples , comprising a memory component , a financial trading algorithm , and AES encryption .},
author = {Skovhede, Kenneth and Vinter, Brian},
pages = {9},
title = {{Building hardware from C{\#} models}},
year = {2016}
}
@inproceedings{Queille1982,
abstract = {The aim of this paper is to illustrate by an example, the alternating bit protocol, the use of CESAR, an interactive system for aiding the design of distributed applications.},
address = {Berlin, Heidelberg},
author = {Queille, J P and Sifakis, J},
booktitle = {International Symposium on Programming},
editor = {Dezani-Ciancaglini, Mariangiola and Montanari, Ugo},
isbn = {978-3-540-39184-5},
pages = {337--351},
publisher = {Springer Berlin Heidelberg},
title = {{Specification and verification of concurrent systems in CESAR}},
year = {1982}
}
@misc{Celoxia2002,
author = {Celoxia},
title = {{Handel-C language reference manual, v. 3.0}},
year = {2002}
}
@mastersthesis{Skaarup14,
author = {Skaarup, Esben and Frisch, Andreas},
school = {University of Copenhagen, Niels Bohr Institute},
title = {{Generation of FPGA Hardware Specifications from PyCSP Networks}},
year = {2014}
}
@inproceedings{vinter2009pycsp,
author = {Vinter, Brian and Bj{\o}rndalen, John Markus and Friborg, Rune M{\o}llegaard},
title = {{PyCSP Revisited}}
}
@article{Ben-ari2010,
author = {Ben-ari, Mordechai Moti},
number = {1},
pages = {40--47},
title = {{A Primer on Model Checking}},
volume = {1},
year = {2010}
}
@article{VHDL98,
journal = {IEEE Std 1076-1987},
keywords = {VLSI,circuit CAD,context-free languages,integrated},
title = {{IEEE Standard VHDL Language Reference Manual}},
year = {1998}
}
@article{Burch1992,
abstract = {Many different methods have been devised for automatically verifying finite state systems by examining state-graph models of system behavior. These methods all depend on decision procedures that explicitly represent the state space using a list or a table that grows in proportion to the number of states. We describe a general method that represents the state space symbolically instead of explicitly. The generality of our method comes from using a dialect of the Mu-Calculus as the primary specification language. We describe a model checking algorithm for Mu-Calculus formulas that uses Bryant's Binary Decision Diagrans (Bryant, R. E., 1986, IEEE Trans. Comput.C-35) to represent relations and formulas. We then show how our new Mu-Calculus model checking algorithm can be used to derive efficient decision procedures for CTL model checking, satisfiability of linear-time temporal logic formulas, strong and weak observational equivalence of finite transition systems, and language containment for finite $\omega$-automata. The fixed point computations for each decision procedure are sometimes complex, but can be concisely expressed in the Mu-Calculus. We illustrate the practicality of our approach to symbolic model checking by discussing how it can be used to verify a simple synchronous pipeline circuit.},
author = {Burch, J.R. and Clarke, E.M. and McMillan, K.L. and Dill, D.L. and Hwang, L.J.},
doi = {10.1016/0890-5401(92)90017-A},
isbn = {0-8186-2073-0},
issn = {08905401},
journal = {Information and Computation},
number = {2},
pages = {142--170},
title = {{Symbolic model checking: 10{\^{}}20 States and beyond}},
url = {http://linkinghub.elsevier.com/retrieve/pii/089054019290017A},
volume = {98},
year = {1992}
}
@book{Roscoe1997,
address = {Upper Saddle River, NJ, USA},
annote = {I do not have this! Looks like its a book to buy},
author = {Roscoe, A W},
isbn = {0136744095},
publisher = {Prentice Hall PTR},
title = {{The Theory and Practice of Concurrency}},
year = {1997}
}
@article{Milner1992,
author = {Milner, Robin and Parrow, Joachim and Walker, David},
journal = {Information and Computation},
number = {1},
pages = {1--40},
title = {{A Calculus of Mobile Processes, I}},
volume = {100},
year = {1992}
}
@book{Hopcroft2001,
author = {Hopcroft, John E. and Motwani, Rajeev and D.Ullman, Jeffrey},
editor = {2},
isbn = {0-201-44124-1},
pages = {537},
publisher = {Addison-Wesley},
title = {{Introduction to Automata Theory, Formal Languages and Computation}},
year = {2001}
}
@article{Leuschel2003,
abstract = {We present ProB, an animation and model checking tool for the B method. ProB's animation facilities allow users to gain confidence in their specifications, and unlike the animator provided by the B-Toolkit, the user does not have to guess the right values for the operation arguments or choice variables. ProB contains a model checker and a constraint-based checker, both of which can be used to detect various errors in B specifications. We present our first experiences in using ProB on several case studies, highlighting that ProB enables users to uncover errors that are not easily discovered by existing tools.},
author = {Leuschel, Michael and Butler, Michael},
doi = {10.1007/b13229},
isbn = {3-540-40828-2},
issn = {03029743},
journal = {FME 2003 Formal Methods},
keywords = {animation,b-method,constraints,logic,model checking,programming,tool support},
pages = {855--874},
title = {{ProB: A Model Checker for B}},
url = {http://eprints.soton.ac.uk/258341/},
volume = {2805},
year = {2003}
}
@article{Hoare1978,
abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar programming exercises.},
author = {Hoare, C. A. R.},
doi = {10.1145/359576.359585},
isbn = {0131532715},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {concurrency,guarded commands,input,nondeterminacy,output,parallel programming,program structures,programming,programming languages,programming primitives},
number = {8},
pages = {666--677},
pmid = {2142694823583477576},
title = {{Communicating sequential processes}},
url = {http://portal.acm.org/citation.cfm?doid=359576.359585},
volume = {21},
year = {1978}
}
@article{Lamport1984a,
abstract = {Generalized Hoare Logic is a formal logical system for deriving invariance properties of programs. It provides a uniform way to describe a variety of methods for reasoning about concurrent programs, including noninterference, satisfaction, and cooperation proofs. We describe a simple recta-rule ofthe Generalized Hoare Logic--the Decomposition Principle--and show how all these methods can be derived using it.},
author = {Lamport, Leslie and Schneider, Fred B.},
doi = {10.1145/2993.357247},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
number = {2},
pages = {281--296},
title = {{The "Hoare Logic'' of CSP, and All That}},
url = {http://portal.acm.org/citation.cfm?doid=2993.357247},
volume = {6},
year = {1984}
}
@manual{probe,
author = {Ltd, Formal Systems (Europe)},
organization = {Formal Systems (Europe) Ltd},
title = {{Process Behaviour Explorer - ProBE User Manual}}
}
@article{Brookes1984,
abstract = {A mathematical model for communicating sequential processes is given, and a number of its interesting and useful properties are stated and proved. The possibilities of nondetermimsm are fully taken into account.},
author = {Brookes, S. D. and Hoare, C.A.R. and Roscoe, A. W.},
doi = {10.1145/828.833},
isbn = {0004-5411},
issn = {00045411},
journal = {Journal of the ACM},
number = {3},
pages = {560--599},
title = {{A Theory of Communicating Sequential Processes}},
url = {http://www.cs.ox.ac.uk/bill.roscoe/publications/4.pdf},
volume = {31},
year = {1984}
}
@article{Vinter2014,
abstract = {In our 2013 paper, we introduced the idea of modeling hardware with PyCSP. Encouraged by our initial success we started a masters project where two students continued our work towards a fully detailed processor built in PyCSP. The two students succeeded, but also identified a number of reasons why PyCSP is not well suited for modeling hardware. Their conclusion was that since the hardware is synchronous, communication is frequently based on broadcast and external choice is never used. This means that PyCSP does not provide the mechanisms that are needed, and the strength of PyCSP is never utilized. In this work we introduce a new mes- saging framework, Synchronous Message Exchange, SME, which greatly simplifies hardware modeling, and is also easily used for other strictly synchronous applications, such as a subset of computer games. We describe the SME framework, and show how it has a rather simple equivalence in CSP so that the properties that are associated with CSP based applications are maintained, except rendezvous message exchange.},
author = {Vinter, B and Skovhede, K},
journal = {Communicating Process Architectures},
keywords = {FPGA,PyCSP,scientific byte code,synchronous messaging},
number = {August},
pages = {13},
title = {{Synchronous message exchange for hardware designs}},
year = {2014}
}
@article{Camurati1988,
author = {Camurati, Paolo and Prinetto, Paolo and Torino, Politecnico},
pages = {12},
title = {{Verification of Hardware Correctness :}},
year = {1988}
}
@article{Amnell2001,
author = {Amnell, Tobias and Behrmann, Gerd and Bengtsson, Johan and D'Argenio, Pedro R and David, Alexandre and Fehnker, Ansgar and Hune, Thomas and Jeannet, Bertrand and Larsen, Kim G and M{\"{o}}ller, M Oliver and Others},
isbn = {3-540-42787-2},
journal = {Modeling and verification of parallel processes},
pages = {99--124},
title = {{Uppaal-now, next, and future}},
volume = {41},
year = {2001}
}
@techreport{Luckham1979,
address = {Stanford, CA, USA},
author = {Luckham, David C and German, Steven M and von Henke, Friedrich W and Karp, Richard A and Milne, P W and Oppen, Derek C and Polak, Wolfgang and Scherlis, William L},
publisher = {Stanford University},
title = {{Stanford Pascal Verifier User Manual}},
year = {1979}
}
@article{VHDL92,
doi = {10.1109/IEEESTD.1992.101084},
journal = {IEEE Std 1076/INT-1991},
keywords = {Design automation,IEEE Std 1076-1987,Specification languages,Standards,VHSIC Hardware Description Language,circuit CAD,specification languages,standards},
title = {{IEEE Standards Interpretations: IEEE Std 1076-1987, IEEE Standard VHDL Language Reference Manual}},
year = {1992}
}
@inproceedings{Schneider2002a,
abstract = {This paper describes a way of using the process algebra CSP to enable controlled interaction between B machines. This approach supports compositional verification: each of the controlled machines, and the combination of controller processes, can be analysed and verified separately in such a way as to guarantee correctness of the combined communicating system. Reasoning about controlled machines separately is possible due to the introduction of guards and assertions into description of the controller processes in order to capture assumptions about other controlled machines and provide guarantees to the rest of the system. The verification process can be completely supported by difierent tools. The use of separate controller processes facilitates the iterative development and analysis of complex control flows within the system. The approach is motivated and illustrated with a non-trivial running example.},
address = {Berlin, Heidelberg},
author = {Schneider, Steve and Treharne, Helen},
booktitle = {ZB 2002:Formal Specification and Development in Z and B},
editor = {Bert, Didier and Bowen, Jonathan P and Henson, Martin C and Robinson, Ken},
isbn = {978-3-540-45648-3},
pages = {416--435},
publisher = {Springer Berlin Heidelberg},
title = {{Communicating B Machines}},
year = {2002}
}
@article{Parashkevov1996,
abstract = {The paper presents the design and implementation of ARC-a tool for automated verification of concurrent systems. The tool is based on the untimed CSP language, its semantic models and theory of refinement. We alleviate the combinatorial explosion problem using ordered binary decision diagrams (OBDDs) for the internal representation of complex data structures-sets and labeled transition systems (LTS). The semantically complex external choice operator is translated into the corresponding LTS using an optimized algorithm. This and some other implementation improvements allow verifying systems with up to 1033 states, which is consistent with the capabilities of other OBDD based approaches. Compared to two existing CSP tools, FDR and MRC, ARC has fewer language restrictions and is more memory efficient. A performance comparison based on the n-schedulers and dining philosophers problems suggests that the checking algorithm of ARC is, in most cases, faster than those of the other tools},
author = {Parashkevov, A N and Yantchev, J},
doi = {10.1109/ICAPP.1996.562859},
isbn = {0-7803-3529-5},
journal = {Algorithms amp; Architectures for Parallel Processing, 1996. ICAPP 96. 1996 IEEE Second International Conference on},
keywords = {communicating sequential processes,concurrency con},
number = {July},
pages = {68--75},
title = {{ARC-a tool for efficient refinement and equivalence checking for CSP}},
year = {1996}
}
@book{Roscoe2010,
abstract = {Na.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Roscoe, A.W.},
doi = {10.1007/978-1-84882-258-0},
eprint = {arXiv:1011.1669v3},
isbn = {978-1-84882-257-3},
issn = {02569574},
pmid = {20529422},
title = {{Understanding Concurrent Systems}},
year = {2010}
}
@phdthesis{Allen1997,
author = {Allen, Robert J},
isbn = {0591647443},
title = {{A Formal Approach to Software Architecture}},
year = {1997}
}
@misc{Clarke1981,
abstract = {We present a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. Because the synchronization skeleton is in general finite state, its properties can be specifies by a formula f in a propositional Temporal Logic. (The synthesis method uses a decision procedure based on the finite model property of the logic to determinesatisfiability of f.) If the formula f is satisfiable, then the specification is expresses is consistent, and a model for f with a finite number of states is constructed. The synchronization skeleton of a program meeting the specification can be read from this model. If f is unsatisfiable, the specification is inconsistent. In the traditional approach to concurrent program verification, the proof that a program meets its specification is constructed using various axioms and rules of inference in a deductive system such as temporal logic. The task of proof construction can be quite tedious, and a good deal of ingenuity may be required. We believe that this task may be unnecessary in the case of finite state concurrent systems, and can be replaced by a mechanical check that the system meets a specification expressed in a propositional temporal logic. The global system flowgraph of a finite state concurrent system may be viewed as defining a finite structure. We describe an efficient algorithm (a model checker) to decide whether a given finite structure is a model of a particular formula. We also discuss extended logics for which it is not possible to construct efficient model checkers.},
author = {Clarke, Edmund and Emerson, Allen},
booktitle = {Logic of Programs},
doi = {10.1007/BFb0025774},
isbn = {3-540-11212-X},
issn = {0302-9743 (Print) 1611-3349 (Online)},
pages = {52--71},
title = {{Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic}},
year = {1981}
}
@inproceedings{Abrial1988,
address = {Berlin, Heidelberg},
annote = {I do not have this as a file},
author = {Abrial, J R},
booktitle = {VDM '88 VDM --- The Way Ahead},
editor = {Bloomfield, Robin E and Marshall, Lynn S and Jones, Roger B},
isbn = {978-3-540-45955-2},
pages = {86--87},
publisher = {Springer Berlin Heidelberg},
title = {{The B tool (Abstract)}},
year = {1988}
}
@article{Occam1995,
author = {{SGS-THOMSON Microelectronics Limited}},
doi = {10.1016/0167-6423(89)90030-0},
isbn = {0-13-629321-3},
issn = {01676423},
title = {occam 2.1 reference manual},
year = {1995}
}
@phdthesis{Scattergood1998,
abstract = {The CSP process-algebra provides a powerful mathematical notation for reasoning about concurrent systems, together with a rich supporting theory. This thesis adapts and extends CSP to produce a language which can be used with tools. The notation is extended by using a functional programming language to provide a concrete version of the (traditionally unspeci ed) expression language which sup- ports the process-algebra. The existing theory is used as the basis for both a denotational semantics and an operational semantics using Plotkin-style transition systems. The two semantics are then shown to be congruent using a bridging semantics based on the synchronisation trees of Brookes, Roscoe and Walker. A reference implementation of the semantics is outlined, along with a lexer and parser. This provides a core which can be used as the basis for future work on tools such as animators, proof assistants and re nement checkers.},
author = {Scattergood, Bryan},
pages = {1--179},
title = {{The semantics and implementation of machine-readable CSP}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.66.1542{\&}rep=rep1{\&}type=pdf},
year = {1998}
}
@inproceedings{10.1007/978-3-642-31759-0_12,
abstract = {We describe an extension of the Spin model checker that allows us to take advantage of the increasing number of cpu-cores available on standard desktop systems. Our main target is to speed up the verification process for safety properties, the mode used most frequently, but we also describe a small modification of the parallel search algorithm, called the piggyback algorithm, that is remarkably effective in catching violations for an interesting class of liveness properties at little cost.},
address = {Berlin, Heidelberg},
author = {Holzmann, Gerard J},
booktitle = {Model Checking Software},
editor = {Donaldson, Alastair and Parker, David},
isbn = {978-3-642-31759-0},
pages = {155--171},
publisher = {Springer Berlin Heidelberg},
title = {{Parallelizing the Spin Model Checker}},
year = {2012}
}
@article{Clarke2008a,
abstract = {“When the time is ripe for certain things, these things appear in different places in the manner of violets coming to light in early spring.” (Wolfgang Bolyai to his son Johann in urging him to claim the invention of non- Euclidean geometry without delay {\{}[{\}}Vit88{\{}]{\}}).},
author = {Clarke, Edmund M},
doi = {10.1007/978-3-540-69850-0_1},
isbn = {978-3-540-69850-0},
issn = {03029743},
journal = {Link.Springer.Com},
keywords = {Compilers,Interpreters,Mathematical Logic and Formal Languages,Programming Languages,Programming Techniques,logics and meanings of programs,software engineering},
number = {Chapter 1},
pages = {1--26},
title = {{The Birth of Model Checking BT - link.springer.com}},
url = {http://www.springerlink.com/index/10.1007/978-3-540-69850-0{\_}1{\%}5Cnpapers2://publication/doi/10.1007/978-3-540-69850-0{\_}1},
volume = {5000},
year = {2008}
}
@misc{jinja2,
author = {Ronacher, Armin},
title = {{Jinja2 Documentation}},
url = {http://jinja.pocoo.org/docs/2.10/{\#}},
urldate = {2018-11-02}
}
@article{Phillips2004,
abstract = {We present tools that convert a subset of CSP into Handel-C code. Handel-C was derived from the original occam concurrency language, but has a syntax similar to the standard C programming language. It compiles to produce files to program an FPGA. We thus now have a process that can directly generate hardware from a verified high-level description. The CSP to Handel-C translator makes use of the Lex and Yacc programming tools. The Handel-C code produced is functional, but not necessarily optimized for all situations. The translator has been tested using several CSP scripts of varying complexity. The functionality of the resulting Handel-C programs has been verified with simulations, and two scripts were further checked with successful implementations on an FPGA.},
author = {Phillips, Jonathan D and Stiles, G. S.},
doi = {10.1.1.81.5737},
issn = {1545-5963},
journal = {Communicating Process Architectures},
pages = {19--37},
pmid = {18245877},
title = {{An automatic translation of CSP to Handel-C}},
url = {citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.81.5737{\&}rep=rep1{\&}type=pdf{\%}0Ahttp://books.google.com/books?hl=en{\&}lr={\&}id=NziHFoKbbC4C{\&}oi=fnd{\&}pg=PA19{\&}dq=Handel-C+Phillips{\&}ots=twXnOFMEyY{\&}sig=Ku8BWUNyWjJmz2LL2RmAA{\_}QkU1w},
year = {2004}
}
@article{fdr4,
abstract = {FDR is a tool for analysing programs written in Hoare's CSP notation, in particular machine-readable CSP namely CSPM, which combines the operators of CSP with a functional programming language. The original FDR was written in 1991 by Formal Systems (Europe) Ltd, and a completely revised version FDR2 was released in the mid-1990s by the same organisation. The current version of the tool is FDR3, first released in 2013. It is released by the University of Oxford, which also released FDR2 versions 2.90 and above in the period 2008-12.},
author = {{University of Oxford}},
title = {{FDR Manual Release 4.2.3}},
year = {2017}
}
