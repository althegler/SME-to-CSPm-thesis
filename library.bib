Automatically generated by Mendeley Desktop 1.17.13
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop


@article{Brookes1984,
abstract = {A mathematical model for communicating sequential processes is given, and a number of its interesting and useful properties are stated and proved. The possibilities of nondetermimsm are fully taken into account.},
author = {Brookes, S. D. and Hoare, C.A.R. and Roscoe, A. W.},
doi = {10.1145/828.833},
isbn = {0004-5411},
issn = {00045411},
journal = {Journal of the ACM},
number = {3},
pages = {560--599},
title = {{A Theory of Communicating Sequential Processes}},
url = {http://www.cs.ox.ac.uk/bill.roscoe/publications/4.pdf},
volume = {31},
year = {1984}
}
@misc{Roscoe1995,
author = {Roscoe, A. W.},
title = {{Model-checking CSP}},
year = {1995}
}
@article{Lamport1980,
abstract = {Hoare's logical system for specifying and proving partial correctness properties of sequential programs is generalized to concurrent programs. The basic idea is to define the assertion {\{} P {\}} S {\{} Q {\}} to mean that if execution is begun anywhere in S with P true, then P will remain true until S terminates, and Q will be true if and when S terminates. The predicates P and Q may depend upon program control locations as well as upon the values of variables. A system of inference rules and axiom schemas is given, and a formal correctness proof for a simple program is outlined. We show that by specifying certain requirements for the unimplemented parts, correctness properties can be proved without completely implementing the program. The relation to Pnueli's temporal logic formalism is also discussed.},
author = {Lamport, Leslie},
doi = {10.1007/BF00289062},
issn = {00015903},
journal = {Acta Informatica},
number = {1},
pages = {21--37},
title = {{The 'Hoare logic' of concurrent programs}},
volume = {14},
year = {1980}
}
@article{Pnueli1977,
abstract = {A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs.},
author = {Pnueli, Amir},
doi = {10.1109/SFCS.1977.32},
isbn = {0272-5428},
issn = {0272-5428},
journal = {18th Annual Symposium on Foundations of Computer Science (sfcs 1977)},
pages = {46--57},
title = {{The temporal logic of programs}},
url = {http://ieeexplore.ieee.org/document/4567924/},
year = {1977}
}
@book{Roscoe1997,
address = {Upper Saddle River, NJ, USA},
annote = {I do not have this! Looks like its a book to buy},
author = {Roscoe, A W},
isbn = {0136744095},
publisher = {Prentice Hall PTR},
title = {{The Theory and Practice of Concurrency}},
year = {1997}
}
@article{Armstrong2012,
author = {Armstrong, Philip and Lowe, Gavin},
journal = {Philip Armstrong Gavin Lowe A.W. Roscoe Jo{\"{e}}l Ouaknine},
number = {March},
pages = {1--21},
title = {{Model checking Timed CSP}},
url = {http://www.cs.ox.ac.uk/people/joel.ouaknine/publications/timedcsp12.pdf},
volume = {2},
year = {2012}
}
@article{Holzmann1997,
abstract = {SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.},
author = {Holzmann, Gerard J},
keywords = {Formal methods,concurrency.,design verification,distributed systems,model checking,program verification},
number = {5},
pages = {279--295},
title = {{The Model Checker SPIN}},
volume = {23},
year = {1997}
}
@inproceedings{10.1007/978-3-642-31759-0_12,
abstract = {We describe an extension of the Spin model checker that allows us to take advantage of the increasing number of cpu-cores available on standard desktop systems. Our main target is to speed up the verification process for safety properties, the mode used most frequently, but we also describe a small modification of the parallel search algorithm, called the piggyback algorithm, that is remarkably effective in catching violations for an interesting class of liveness properties at little cost.},
address = {Berlin, Heidelberg},
author = {Holzmann, Gerard J},
booktitle = {Model Checking Software},
editor = {Donaldson, Alastair and Parker, David},
isbn = {978-3-642-31759-0},
pages = {155--171},
publisher = {Springer Berlin Heidelberg},
title = {{Parallelizing the Spin Model Checker}},
year = {2012}
}
@book{Holzmann1991,
author = {Holzmann, G J},
isbn = {0135399254, 9780135399255},
publisher = {Prentice Hall},
title = {{Design and Validation of Computer Protocols}},
year = {1991}
}
@article{Camurati1988,
author = {Camurati, Paolo and Prinetto, Paolo and Torino, Politecnico},
pages = {12},
title = {{Verification of Hardware Correctness :}},
year = {1988}
}
@article{Ben-ari2010,
author = {Ben-ari, Mordechai Moti},
number = {1},
pages = {40--47},
title = {{A Primer on Model Checking}},
volume = {1},
year = {2010}
}

@article{Hoare1978,
abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar programming exercises.},
author = {Hoare, C. A. R.},
doi = {10.1145/359576.359585},
isbn = {0131532715},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {concurrency,guarded commands,input,nondeterminacy,output,parallel programming,program structures,programming,programming languages,programming primitives},
number = {8},
pages = {666--677},
pmid = {2142694823583477576},
title = {{Communicating sequential processes}},
url = {http://portal.acm.org/citation.cfm?doid=359576.359585},
volume = {21},
year = {1978}
}

@article{Vinter2016,
abstract = {The Synchronous Message Exchange, SME, is a programming model that both resembles communication in hardware, and can be implemented as a CSP net- work. This paper extends on previous work for modeling hardware-like programs us- ing SME in Python, with the addition of a source-to-source compiler that converts an SME network implemented in Python to an equivalent implementation in VHDL. We describe the challenges, constraints, and solutions involved in translating a highly dynamic language like Python into the hardware-like VHDL language. We also show how the approach can assist in further VHDL refinement by generating tedious test bench code, such that VHDL designs can be simulated and verified with vendor sup- plied simulation and synthesis tools.},
author = {Vinter, Brian and Skovhede, Kenneth},
keywords = {CSP,FPGA,HLS,Haskell,Python,VHDL,synchronous messaging,transpiler},
number = {September},
pages = {23},
title = {{VHDL Generation From Python Synchronous Message Exchange Networks}},
year = {2016}
}
@article{Vinter2015,
abstract = {In this work we present a new design and implementation of the Syn- chronous Message Exchange model. The new version uses explicit busses, which may include multiple fields, and where a components may use a bus for both reading and writing, whereas the original version allowed only reading from or writing to a bus, which triggered a need for some busses to exist in two versions for different direc- tions. In addition to the new and improved bus-model, the new SME version also pro- duces traces that may be used for validating a later VHDL implementation of the de- signed component, and can produce a graphical representation of a design to help with debugging.},
author = {Vinter, Brian and Skovhede, Kenneth},
keywords = {FPGA,PyCSP,Scientific Byte Code,Synchronous Messaging},
number = {August},
title = {{Bus Centric Synchronous Message Exchange for Hardware Designs}},
year = {2015}
}

@article{Floyd1967,
author = {Floyd, Robert W.},
doi = {10.1007/978-94-011-1793-7_4},
isbn = {0821813196},
issn = {01460404},
pages = {19--32},
pmid = {17389487},
title = {{Assigning Meanings to Programs}},
url = {http://www.springerlink.com/index/10.1007/978-94-011-1793-7{\_}4},
year = {1967}
}


@article{Lamport1984a,
abstract = {Generalized Hoare Logic is a formal logical system for deriving invariance properties of programs. It provides a uniform way to describe a variety of methods for reasoning about concurrent programs, including noninterference, satisfaction, and cooperation proofs. We describe a simple recta-rule ofthe Generalized Hoare Logic--the Decomposition Principle--and show how all these methods can be derived using it.},
author = {Lamport, Leslie and Schneider, Fred B.},
doi = {10.1145/2993.357247},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
number = {2},
pages = {281--296},
title = {{The "Hoare Logic" of CSP, and All That}},
url = {http://portal.acm.org/citation.cfm?doid=2993.357247},
volume = {6},
year = {1984}
}

@misc{Clarke1981,
abstract = {We present a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. Because the synchronization skeleton is in general finite state, its properties can be specifies by a formula f in a propositional Temporal Logic. (The synthesis method uses a decision procedure based on the finite model property of the logic to determinesatisfiability of f.) If the formula f is satisfiable, then the specification is expresses is consistent, and a model for f with a finite number of states is constructed. The synchronization skeleton of a program meeting the specification can be read from this model. If f is unsatisfiable, the specification is inconsistent. In the traditional approach to concurrent program verification, the proof that a program meets its specification is constructed using various axioms and rules of inference in a deductive system such as temporal logic. The task of proof construction can be quite tedious, and a good deal of ingenuity may be required. We believe that this task may be unnecessary in the case of finite state concurrent systems, and can be replaced by a mechanical check that the system meets a specification expressed in a propositional temporal logic. The global system flowgraph of a finite state concurrent system may be viewed as defining a finite structure. We describe an efficient algorithm (a model checker) to decide whether a given finite structure is a model of a particular formula. We also discuss extended logics for which it is not possible to construct efficient model checkers.},
author = {Clarke, Edmund and Emerson, Allen},
booktitle = {Logic of Programs},
doi = {10.1007/BFb0025774},
isbn = {3-540-11212-X},
issn = {0302-9743 (Print) 1611-3349 (Online)},
pages = {52--71},
title = {{Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic}},
year = {1981}
}
@misc{Vardi1994,
abstract = {We investigate extensions of temporal logic by connectives defined by finite automata on infinite words. We consider three different logics, corresponding to three different types of acceptance conditions (finite, looping, and repeating) for the automata. It turns out, however that these logics all have the same expressive power and that their decision problems are all PSPACE-complete. We also investigate connectives defined by alternating automata and show that they do not increase the expressive power of the logic or the complexity of the decision problem.},
author = {Vardi, Moshh Y. and Wolper, Pierre},
booktitle = {Information and Computation},
doi = {10.1006/inco.1994.1092},
isbn = {0-8186-0508-1},
issn = {10902651},
number = {1},
pages = {1--37},
title = {{Reasoning about Infinite Computations}},
volume = {115},
year = {1994}
}


@article{Vinter2014,
abstract = {In our 2013 paper, we introduced the idea of modeling hardware with PyCSP. Encouraged by our initial success we started a masters project where two students continued our work towards a fully detailed processor built in PyCSP. The two students succeeded, but also identified a number of reasons why PyCSP is not well suited for modeling hardware. Their conclusion was that since the hardware is synchronous, communication is frequently based on broadcast and external choice is never used. This means that PyCSP does not provide the mechanisms that are needed, and the strength of PyCSP is never utilized. In this work we introduce a new mes- saging framework, Synchronous Message Exchange, SME, which greatly simplifies hardware modeling, and is also easily used for other strictly synchronous applications, such as a subset of computer games. We describe the SME framework, and show how it has a rather simple equivalence in CSP so that the properties that are associated with CSP based applications are maintained, except rendezvous message exchange.},
author = {Vinter, B and Skovhede, K},
journal = {Communicating Process Architectures},
keywords = {FPGA,PyCSP,scientific byte code,synchronous messaging},
number = {August},
pages = {13},
title = {{Synchronous message exchange for hardware designs}},
year = {2014}
}


@article{Skovhede,
abstract = {This paper introduces a method for modeling hardware in the C{\#} language , using an abstraction called Synchronous Message Exchange . We describe how Synchronous Message Exchange helps model hardware from a high - level language , and describe the process used in automatically transpiling a subset of C{\#} models into standard VHDL . We evaluate the approach with a set of examples , comprising a memory component , a financial trading algorithm , and AES encryption .},
author = {Skovhede, Kenneth and Vinter, Brian},
pages = {9},
title = {{Building hardware from C{\#} models}},
year = {2016}
}

@article{Pedersen2018,
author = {Pedersen, Jan B. and Welch, Peter H.},
doi = {10.1007/s00165-017-0447-x},
issn = {0934-5043},
journal = {Formal Aspects of Computing},
keywords = {CSP,Concurrency,Deadlock,Event ordering,Liveness,Occam-pi,Verification,proxwaa-orientation},
number = {2},
pages = {239--277},
publisher = {Springer London},
title = {{The symbiosis of concurrency and verification: teaching and case studies}},
url = {http://link.springer.com/10.1007/s00165-017-0447-x},
volume = {30},
year = {2018}
}
@article{Ouakninet,
author = {Ouakninet, Joel},
title = {{A Framework for Model-Checking Timed CSP * t}}
}

@inproceedings{10.1007/978-3-540-73370-6_15,
abstract = {We present an approach for the verification of spatial properties with Spin. We first extend one of Spin's main property specification mechanisms, i.e., the linear-time temporal logic LTL, with spatial connectives that allow us to restrict the reasoning of the behaviour of a system to some components of the system, only. For instance, one can express whether the system can reach a certain state from which a subset of processes can evolve alone until some property is fulfilled. We give a model checking algorithm for the logic and propose how Spin can be minimally extended to include the algorithm. We also discuss potential improvements to mitigate the exponential complexity introduced by spatial connectives. Finally, we present some experiments that compare our Spin extension with a spatial model checker for the {\$}\pi{\$}-calculus.},
address = {Berlin, Heidelberg},
author = {{Lluch Lafuente}, Alberto},
booktitle = {Model Checking Software},
editor = {Bo{\v{s}}na{\v{c}}ki, Dragan and Edelkamp, Stefan},
isbn = {978-3-540-73370-6},
pages = {223--242},
publisher = {Springer Berlin Heidelberg},
title = {{Towards Model Checking Spatial Properties with SPIN}},
year = {2007}
}
@inproceedings{10.1007/978-3-642-16164-3_9,
abstract = {SpinJa is a model checker for promela, implemented in Java. SpinJa is designed to behave similarly to Spin, but to be more easily extendible and reusable. Despite the fact that SpinJa uses a layered object-oriented design and is written in Java, SpinJa's performance is reasonable: benchmark experiments have shown that, in exhaustive mode, SpinJa is about five times slower than the highly optimized Spin. For bitstate verification runs the difference is only a factor of two.},
address = {Berlin, Heidelberg},
author = {de Jonge, Marc and Ruys, Theo C},
booktitle = {Model Checking Software},
editor = {van de Pol, Jaco and Weber, Michael},
isbn = {978-3-642-16164-3},
pages = {124--128},
publisher = {Springer Berlin Heidelberg},
title = {{The SpinJa Model Checker}},
year = {2010}
}


@inproceedings{Queille1982,
abstract = {The aim of this paper is to illustrate by an example, the alternating bit protocol, the use of CESAR, an interactive system for aiding the design of distributed applications.},
address = {Berlin, Heidelberg},
author = {Queille, J P and Sifakis, J},
booktitle = {International Symposium on Programming},
editor = {Dezani-Ciancaglini, Mariangiola and Montanari, Ugo},
isbn = {978-3-540-39184-5},
pages = {337--351},
publisher = {Springer Berlin Heidelberg},
title = {{Specification and verification of concurrent systems in CESAR}},
year = {1982}
}

@misc{Hoare1969,
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantages, both theoretical and practical, may follow from a pursuance of these topics.},
author = {Hoare, C. A. R.},
booktitle = {Communications of the ACM},
doi = {10.1145/363235.363259},
isbn = {0001-0782},
issn = {00010782},
number = {10},
pages = {576--580},
title = {{An axiomatic basis for computer programming}},
url = {http://portal.acm.org/citation.cfm?doid=363235.363259},
volume = {12},
year = {1969}
}

@article{Skovhedea,
abstract = {This paper introduces a multi-language simulation and code generation capability for programs written with Synchronous Message Exchange. We show how to use Synchronous Message Exchange to build and verify process-oriented networks that can be translated into C++ and VHDL. This approach gives the developer freedom in choosing the optimal implemen- tation, and enables experimentations with hardware/software co-design. The emitted C++ can also be used to simulate the FPGA implementation inside software, thus enabling a faster development and debugging workflow. We describe the translation process and evaluate the performance of the generated code.},
author = {Skovhede, Kenneth and Vinter, Brian},
pages = {8},
title = {{C ++ support for better hardware / software co-design in C {\#} with SME}}
}

@misc{Vardi1986,
abstract = {We describe an automata-theoretic approach to automatic verification of concurrent finite-state programs by model checking. The basic idea underlying this approach is that for any temporal formula we can construct an automaton that accepts precisely the computations that satisfy the formula. The model-checking algorithm that results from this approach is much simpler and cleaner than tableau-based algortihms. We use this approach to extend model checking to probabilistic concurrent finite-state programs.},
author = {Vardi, M Y and Wolper, P},
booktitle = {Lics},
doi = {10.1234/12345678},
isbn = {0818607203},
pages = {332--344},
title = {{An automata-theoretic approach to automatic program verification}},
url = {http://hdl.handle.net/2268/116609{\%}5Cnhttp://www.cs.utep.edu/sroach/F07-5383/AutomataTheoretic-Approach-SPIN-lics86.pdf},
year = {1986}
}
