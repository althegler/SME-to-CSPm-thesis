\section{Transpiling Channels}
In SMEIL when a process is reading from a bus channel, it is referencing the bus and channelname within the normal expression. Since the bus parameters for a SMEIL process is the bus name, the process itself must reference the specific channel within that bus. This is applied whether it is reads or writes.
An example of this can be seen in Listing \ref{lst:smeil_input_parameter}, where \texttt{input.val} indicates a read from the bus \texttt{input} and the channel \texttt{val} within that bus.
\begin{listing}
    \begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
        proc a (in input)
            bus abus {
                val: uint;
            }
        {
            abus.val = input.val + 1;
        }
    \end{minted}
    \caption{Example of a read and a write in SMEIL.}
    \label{lst:smeil_input_parameter}
\end{listing}
SMEIL does not seperate communication and calculation in the process statements which is of great advantage in SMEIL, but the translation becomes more difficult since TAPS has to be able to recognise the communication.
This means that TAPS can recognise communication by the structure of the assignment. If one of the elements in an assignment, right or left, contains a dot, then we can assume that this is communication. The original grammar of an assignment like the one seen above can be seen in Listing \ref{lst:smeil_assignment_grammar}. A communication is the \textit{hierarchical accessor} alternative in the \textit{statement} grammar. The communication can either be the right hand side of the assignment, which is a write, or part of the left hand side expression, which will then be a read. A write is simple to recognise, since it is not combined with other parts of the grammar. TAPS can search the \textit{name} of a right hand side assignment and see if it contains a dot. The read is a bit more complicated since it can be used like any internal variable in the expressions. This means that TAPS will have to search all names within the nested expression to find a potential read.
% TODO: Write something more about how TAPS actually achieve this.
\begin{listing}
\begin{grammar}
<statement> ::= <name> `=' <expression> `;' (assignment)

<name> ::= <ident>
\alt <name> `.' <name> (hierarchical accessor)
\alt <name> `[' <array-index> `]' (array element access)

<expression> ::= <name>
\alt <literal>
\alt <expression> <bin-op> <expression>
\alt <un-op> <expression>
\alt <name> `(' \{ <expression> \}  `)' (function call)
\alt `(' <expression> `)'


\end{grammar}
\caption{The original assignment, name and expression grammars defined in \cite{Asheim2018}.}
\label{lst:smeil_assignment_grammar}
\end{listing}

When translating an SMEIL bus channel to a \cspm{} channel it give channel names that will be unique in \cspm{} just like the formal name of a bus channel in SMEIL is unique.
\subsection{Naming Channels}
The simple way of translating the SMEIL channels into \cspm{} chanels are to use the formal name of the SMEIL bus channel already defined. The naming are created by concatinating the channel name, bus name and process name which will ensure that the generated code are more readable than if I had used random unique strings as naming, which is also a possible solution. A unique string might give more security than using a concatinated version, but in this case I decided to make use the allready defined names. This means that all calls using the syntax \texttt{bus.channel} in SMEIL will be translated to \texttt{bus\_channel} in \cspm{}.

There is however one situation where this naming might cause troubles. If a process is reused and instantiated twice in the network, the bus channels defined in the processes would have the same name in SMEIL, but because of the instance declarations in the SMEIL network, it is possible to separate the different channels in SMEIL. Therefore it is important to handle this in \cspm{} so there does not occur problems with having identical channel names.

In the example in Listing \ref{lst:Instance_variations} we see a network consisting of four instances where two of the instances are the same process. Each instance is defined by an instance name which is used for referencing the buses declared as parameters.
\begin{listing}
    \begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
    network net() {
        instance c of clock();
        instance a of A(c.output, val: 1);
        instance _ of A(c.output, val: 2);
        instance s of src(a.output);
    }
    \end{minted}
    \caption{Example of a network with four instances whereas two are instances of the same process.}
    \label{lst:Instance_variations}
\end{listing}

In SMEIL it is also possible to have a instance without an instance name as can be seen above. However, it is defined in SMEIL that two instances of the same process, cannot both be without an instance name.
% NOTE: Does not support!!
TAPS will need to name the channels so that no \cspm{} channels are identical. This can be done by looking at the data from the instances and append the instance name to the \cspm{} channel name. The restrictions to identical process instances in SMEIL ensures that even if there are channels without instance names in the SMEIL program there will never be two identical named  \cspm{} channels in the generated code. This however does mean that the naming of each channel quickly becomes long and chaotic, but it is still more readable than random generated names.
% NOTE! Currently TAPS does not support the naming of identical process busses.

%%% Calling the channel in the bus
It is also possible to have bus declarations within the network declaration in SMEIL. These bus channels will be named in the same manner as the other channels, however without a potential instance name appended.

\subsection{\cspm{} Channel Ranges}
When defining the channels in \cspm{} it is important, to defined a limited space of values accepted for the channel. If the channel is defined for the entire space of integers, which are within a signed or twos-complement 32-bit representation in FDR4, FDR4 would try to verify all possible integers which would result in the statespace becomming too large and FDR would run out of space. Therefore TAPS need to define some specific range of values for each channel but it must be values relevant to the channel and not some random ranges.
As explained in Chapter~\ref{chap:analysis}, all simulated SMEIL programs will include the observed range and restricted types for all channels and variables. The types represent the minimum observed width of the channels in bits, and by calculating the possible range from these types, we can create the corresponding channels in \cspm{}, and thereby avoid having a seemingly endless runtime in FDR4.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc seconds (in seconds_in)
    bus seconds_out {first_digit: u3 range 0 to 5;
                     second_digit: u4 range 0 to 9;};
    var seconds: u6 range 1 to 59;
    var seconds_first_temp: u3 range 0 to 5;
    var seconds_second_temp: u4 range 0 to 9;
{
    seconds = seconds_in.val % 60;
    seconds_first_temp = seconds / 10;
    seconds_second_temp = seconds % 10;
    seconds_out.first_digit = seconds_first_temp;
    seconds_out.second_digit = seconds_second_temp;
}
\end{minted}
\caption{Example of the \texttt{seconds} process from the SMEIL seven segment display example. See full example in Listing~\ref{lst:smeil} in the appendix.}
\label{lst:range_smeil}
\end{listing}


An example of simulated SMEIL code can be seen in Listing~\ref{lst:range_smeil}. Notice that the two channels are defined both with a type \texttt{u3} and \texttt{u4} and with a range 0 to 5 and 0 to 9. These are the observed types and value ranges the simulation has tracked for each specific channel. In order to create the \cspm{} channels based on the types, we need to convert \texttt{u3} and \texttt{u4} into the range of values that the types represents. For \texttt{u3} this is 0 through 7 and for \texttt{u4} it is 0 through 15. In Listing~\ref{lst:channel_range_cspm} the calculated ranges are used to define the \cspm{} channels.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}

Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP
\end{minted}
\caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:channel_range_cspm}
\end{listing}


Since the assertion we wish to make is to verify the widths of the channels, it might seem redundant to create \cspm{} channels with a limited range. FDR4 would always only check the values in the defined channel range and therefore there is no point in asserting if the values go beyond this range. After simulating the SMEIL network, the compiler provides us with both a type and a range of observed values. The type, as explained above, is used to create the restricted range for each \cspm{} channel and the observed values are used for the assertion. The range of values that the types represent will always represent equal or more values than the range of observed values, and by using these values the assertions becomes valuable.\\

When it comes to transpiling the data generator process into a \cspm{} channel, we also use the type of the outbus bus channel to define it. TAPS use this instead of the observed values because we cannot guarantee the precise input values of the system. If I used the observed values, the assertions will pass every time, since it will test the values already used to generate the rest of the observed values.

\section{Generating Monitor Processes}
When generating the monitor processes in the \cspm{} program we use the observed values for each channel, as described above.
In the SMEIL grammar defined in \cite{Asheim2018} it is optional to include a range to each bus channel definitions. In Listing \ref{lst:smeil_bus_grammar} the relevant grammar rules from \cite{Asheim2018} can be seen. The square brackets indicates optional parts.
\begin{listing}
    \begin{grammar}
    <bus-decl> ::= [ `exposed' ] `bus' <ident> `\{' <bus-signal-decls> `\}'  `;'

    <bus-signal-decls> ::= <bus-signal-decl> \{ <bus-signal-decl> \}

    <bus-signal-decl> ::= <ident> `:' <type> [ `=' <expression> ] [ <range> ] `;'
    \end{grammar}
    \caption{The bus grammar defined in \cite{Asheim2018}}
    \label{lst:smeil_bus_grammar}
\end{listing}
\begin{listing}
    \begin{grammar}
    <bus-decl> ::= `bus' <ident> `\{' <bus-signal-decls> `\}'  `;'

    <bus-signal-decls> ::= <bus-signal-decl> \{ <bus-signal-decl> \}

    <bus-signal-decl> ::= <ident> `:' <type> [ `=' <expression> ] <range> `;'
    \end{grammar}
    \caption{The bus grammar defined in \cite{Asheim2018} changed to match the demands of the translation.}
    \label{lst:smeil_bus_grammar_no_option}
\end{listing}
As explained in Chapter \ref{chap:design}, all channels except the input channels are verified in FDR4. This means that there will be created a monitor process for each channel and since TAPS use the observed values for each channel for the verification, I had to change the original grammar of SMEIL to suppport this. Therefore the grammar shown in Listing \ref{lst:smeil_bus_grammar} is changed to the grammar defined in Listing \ref{lst:smeil_bus_grammar_no_option}. The only difference is that ranges are no longer optional and that the keywork \texttt{exposed} are no longer allowed, since TAPS are not supporting co-simulation, which is what this keyword indicates. \\

The monitor process asserts that the observed values of the \cspm{} channels are actually what is communicated on the channels. In Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the \texttt{Seconds} process from the seven segment example can be seen. The values used for these statements are 0 through 5 for the first digit and 0 through 9 for the second which can be seen defined for each channel in Listing~\ref{lst:range_smeil}.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
\end{minted}
\caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:monitor_range_cspm}
\end{listing}
The naming of the monitor processes are the name of the channel they are asserting concatinated with \texttt{\_monitor}. This is very simple but very usefull since it means we can automatically find the name of the monitor process when we have the channel name, and vice versa. We also know that no two channel names will ever be equal in the generated \cspm{} code and therefore the monitor processes will also not have any duplicates when using this name scheme. \\

This monitor process structure is a simple but general solution which can be reused in many situations and due to the opserved ranges, TAPS can always provide a monitor process with this structure.
% TODO: Make sure that examples of the failure in the seven segment example are included somewhere, as well as a working example.



\section{Transpiling Networks}
% TODO: This headline is almost the same at it is in design chapter
When generating the process monitor network as described in Section \ref{sec:design_translating_network}, TAPS go through all writes within each process and generate the monitor processes for each channel. In order to generate the process monitor network TAPS firstly adds all the reads of the input parameters for the process. From the information given in the SMEIL network for each instance, TAPS knows which channel is the channel to read from for this specific process and then the value will be added as a process parameter, however there are several steps to this process. In the SMEIL instance declarations, the process name itself is not necessarily declared within the process parameter. The process parameter might be defined using the instance name possible to define for each instance in a network as explained with the example in Listing \ref{lst:Instance_variations}. Therefore TAPS first have to search the network to specify which process the input parameter is defined within. Since the channel itself is not declared directly in the instance declaration in SMEIL TAPS will then search through the data in order to see which channel are contained within the specified bus and then which channels are actually being read from within this specific process. This data are all gathered from different processes in the network, however, since we have generalised the process translation as well as the monitor process translation it is only within the network translation that it is necessary to search for data elsewhere in the system, which is an advantage.\\

% TODO: TAPS does not currently support more than one input channel
After TAPS have generated all reads for the process, TAPS start to generate the process monitor network. TAPS search through the created monitor processes and for each process it synhronise the process together with the monitor process over the channel it is asserting. TAPS builds an extra layer to the nested structure for each extra monitor processes. This is quite easy to auto generate since TAPS can simply run through the list of monitor processes or write channels, and loop over it. \\

In Listing \ref{lst:channel_range_cspm} the translated \texttt{Seconds} process is defined, and in Listing \ref{lst:monitor_range_cspm} the two monitor processes for the \texttt{Seconds} process are shown.
In Listing \ref{lst:network_example_cspm} the network generated for the \texttt{Seconds} process is shown where it is easy to see how the read is performed first in the process before the first digit monitor process is synchronised together with the \texttt{Seconds} process. Adding a parentheses around the first synhronisation to keep the structure, the second monitor process is synchronised on the second digit channel which completes the process monitor network.

Lastly the \texttt{assert} operator is used to specify to FDR4 that it should create a refinement check against the specification process \texttt{SKIP} and the implementation process \texttt{N\_seconds} and also that it should use the Failure model.

\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
N_seconds = clock_out_val ? variable ->
            (Seconds(variable)
            [| {| seconds_out_first_digit|} |]
            Seconds_out_first_digit_monitor(seconds_out_first_digit))
            [| {| seconds_out_second_digit|} |]
            Seconds_out_second_digit_monitor(seconds_out_second_digit)

assert SKIP [F= N_seconds \ Events
\end{minted}
\caption{Example of the \texttt{Seconds} network processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:network_example_cspm}
\end{listing}


% TODO: This might just belong in the new version!
% When the smaller process monitor networks have been created TAPS will then be able to synhronise other smaller monitor networks where there is shared communication. TAPS controls that all communication are handled within this new network. (Maybe it makes sense to generate smaller network which can then be synhronised. I mean where each smaller network is a process with a name, so it does not become so large nested.. )
% % TODO: Figure out how to make sure that all data are synchronised. It might be something about needing to have a linked list or something to keep all the data together. both stuff defined as parameter and communication defined by using the formal names.


\section{Technologies}

Usually when doing any form of translation either by a compiler or interpreter, the use of a symbol table is often needed in order to keep information about variable names, function names, classes, communication ect. Usually the translation, when reaching a symbol in the translation, use the symbol table to look up a symbol and retrieve its context if it has any information about said symbol. This can be to check that a variable have been declared or for type checking or similar. The symbol table is usually generated in the analysis section and are used for look ups througout the compilation or interpretation. When parsing the code, TAPS gathers all relevant information from the code, and since TAPS expect the SMEIL program to be well-formed, it does not need a symbol table to check if variables have been declared in the process declaration before being used in the body of the process.
TAPS use ANTLR4~\cite{antlr} as the parser generator with Python 2.7 as its source.
For the actual gode generation the templating language Jinja2~\cite{jinja2} have been used.

\subsection{ANTLR4}
For the transpiling between SMEIL source code and \cspm{} source code, I decided to use ANTLR4 for creating a parser and a lexer. ANTLR4 is a Java-based parser generator library that, based on a grammar, can generate parsers in Java or another target language. ANTLR is a well used tool with a lot of documentation and which have been updated to a new and improved version 4 recently. By using ANTLR4 I could easily transform the SMEIL grammar into a parser and lexer that could then immediately be used to transform into \cspm{}.
ANTLR4 supports Extended BNF (EBNF) and it must be defined in \texttt{.g4} file format, which is very similar to other standard grammars. The SMEIL grammar have been changed slightly either because it was more efficient to parse the programs if a grammar rule was removed. For instance the SMEIL grammar does not have a short way of representing "one or more" but only "zero or more". In ANTLR4 it is possible to define the rules as "one or more", and some of these SMEIL rules have been simplified to this. The grammar have also been changes in a few places, simply because there are things within the SMEIL grammar that TAPS does not allow, such as optional ranges, as described earlier.

% A lexical analysis, which is what a lexer , is a process of converting a string of characters into tokens, which is also called tokenization. Each token represents a lexer rule in the grammer, for instance, if the string is "123" and there is a lexer rule "INT: {0-9}+" which means one or more of 0-9 digits. Then the token would be an INT.
%
% A parser...%TODO: write more here
% Should I write something about what a lexer and a parser is? I am pretty sure Brian said no, that it is not a part of the job. The job is to describe how I generate the code, not how I parse it with an automatic parse generator. But I should explain what ANTLR do and how it is an advantage to me.

After parsing the code with ANTLR4, one can decide to traverse the parse tree itself or use either the listener or the visitor methods that ANTLR4 provides. The main difference between the listener and the visitor is that the listener provides methods which are called by the walker object directly, and the visitor methods must call its children explicitly to walk them. Both methods can provide the same results, and it often depends on preference. In my implemenation of TAPS I first tried the listener method, but realising that I do not need data from all parse rules, it was not necessary to walk the entire tree and therefore I shifted to the visitor method where I can be specific about which rules ANTLR4 should walk.

After ANTLR4 have walked the parse tree and collected all relevant information, the data is transformed to match the requirements of the \cspm{} code. For example, the names of a bus channel in SMEIL it transformed into a combined name for a \cspm{} channel. I have defined templates in Jinja2 that match these generalised structures in \cspm{} that I can use to represent the SMEIL code. These templates are then used together with the transformed data to generate the \cspm{} code. 

%
% With the visitor we gain the advantage that we decide which part of the parse tree we traverse, instead of having to traverse the entire parse tree as with the listener method. With the visitor, for each parser we have to explicitly call \texttt{visit()} on the children that we wish to visit, which, in some cases can make a tree traversal more complex, but in our case we wish to seperate concerns and this is done by having three different tree traversals which collect three differet pieces of data for the code generation.
% When restructuring the code for the visitor method, we have to implement the top parsers, \texttt{module} and \texttt{entity}, even though they dont have any real value for the data we need to collect. However, because of the visitor method having to call all children, we need to implement these two parsers, simply so they can call their children.
% This seem a little pointless compared to the listener, where we can ignore the parsers we do not care about, but if we use a listener we would have to use a stack system and that would cause problems, because a terminal node that we only want sometimes might push something on the stack that we did not want to. Because every time that terminal node is entered or exited the code is run. With the visitor we can control when the nodes are run which means that we avoid some messy stack problems.
% A visitor can return a value like other standard functions which means that we have directly access to the result from it or its children. However, if there are more than one child the result will have to be assigned in a list or similar, to access.
% If there are two expressions in one alternative, we can get the two seperate results by calling \texttt{self.visit(ctx.expression(0))} and \texttt{self.visit(ctx.expression(1))}. This simplifies the structure since we do not have to handle loops in this case, because we know that the structure would always be two expressions, not more and no less.\\
% Even though we update the data structure \texttt{data} by reference instead of returning it as a result from the tree traversals, it is still necessary to return values from some of the parsers. Parts of the data structure cannot be created before having specific data, and the top parser with all the information will then gather the results from its children and update the \texttt{data} dictionary with the new data.


% TODO: Maybe it is worth mentioning how I remove some sub-"parsers" in the grammer, because it made the parsing more complicated . Such like I removed the processdecl nonterminal because I could then call visit(ctx.busdecl) specificly. Otherwise I could also just do "if ctx.busdecl: ..." but, this gave one less step (however, now I am thinking about it, it might not be a good idea. It gives more complexity and maybe thats not good if other people need to understand the antlr grammar. )

% TODO: Write something about how I should just gather the data and then letting the transformation part do any data transformations. I am, for example, not doing that now since I am adding calculations and communications into two different lists.

% TODO: Write something about how smart it is that I can use labels in the grammar and that I can then much more easily control how to handle different alternatives.



