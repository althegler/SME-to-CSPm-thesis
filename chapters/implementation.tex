%!TEX root = ../main.tex
In this chapter I introduce some of the main challenges in translating from SMEIL to \cspm{} and how they have been solved in TAPS.

The requirements for TAPS are considerable because of the flexibility of SMEIL. Translating the different funcionalities of SMEIL have been priorities acccording to the requirements of the examples used within this thesis and due to time restrictions, the current version of TAPS does not support the entire SMEIL grammar. TAPS expect a well-formed legal SMEIL program as input and does not perform any type-checking. The best way to ensure an accurate translation to \cspm{} is to simulate the SMEIL program before using TAPS to ensure that the program comply with all the rules of the libsme compiler.
\section{Transpiling SMEIL Statements}
SMEIL statements are defining the functionality of the process and can consist of simple arithmetic operations, conditionals or communication.
The statements are translated into the \texttt{let within} structure as introduced in \ref{chap:design}.

When translating a constant from SMEIL to \cspm{} the constant is added to the \cspm{} program seperately from the process it was defined within.
The SMEIL programs must be well-formed and thus the constant will only be used by the process it was defined within. It is therefore not a problem to have the constant defined outside of the \cspm{} process.

If a constant is defined as a process parameter in the SMEIL program, will be translated as an initial value for the process and not as a seperate \cspm{} constant.
% NOTE Constants are currently not implemented in TAPS

Variables, in SMEIL, can be instantiated with an initial value and therefore TAPS must search through all the veriable declarations in the SMEIL process. If a variable is defined with an initial value, this information is gathered so that the initial value of the variable can be added to the generated \cspm{} process.
Variables with no initial value will be ignored be TAPS because they do not need instantiation in \cspm{} and will be translated along with the statements. With the current version of TAPS only values comunicated on channels are verified, and therefore the range and type of a variable have no purpose within the generated \cspm{} code. It would, however, be simple to gather this information if needed.\\

All assignments in SMEIL are translated directly into \cspm{} without much change, however if the assignment is consisting of communication either in or out, TAPS must handle these assignments differently, which will be explained later in this section.\\

% If-satements are translated into the \cspm{} version of an if-statement, which is very similar to the SMEIL version. As explained in Chapter \ref{chap:analysis} \cspm{} does not support \texttt{elif} and therefore the \cspm{} if-statements must be nested to form these expressions. This quickly becomes very complex and hard to read, but it is not a big problem to generate.\\
% NOTE: If-statements are currently not implemented in TAPS - %TODO: Figure out if it should be in analysis or implementation. Not both places

% Traces and assertions are, as explained in Chapter \ref{chap:analysis} not useful in the \cspm{} program and therefore we either throw them away or keep them as comments for the sake of understanding the generated code. Currently TAPS throw them away, but it would be a simple task to change this and add them as comments in the generated \cspm{} code.\\ -%TODO: Figure out if it should be in analysis or implementation. Not both places
% NOTE: Assertions are not curently implemented in TAPS. Trace is.

% Most expressions of SMEIL can be directly translated, like \texttt{+} and \texttt{-}, however there are a few differences in presendence for some of the operators. The unary \texttt{not} operator does not have the same presedence in the SMEIL as in \cspm{} and the equality comparison operators and comparison operators have the same presedence in \cspm{}, but they are seperated in the SMEIL grammar. Because of these small differences, TAPS must add parentheses around all nested expression to ensure the correct translations. %TODO: Figure out if it should be in analysis or implementation. Not both places

Bitwise operations does not exist in \cspm{}, so these would have to be transformed to standard arithmetics. % TODO: This is currently not implemented.
% TODO: Write more about how this could be done.

% TODO: Write more when I have more implemented for the processes (like arrays and stuff)

% TODO: Finish writing this when I have talked with Brian about what I should say
% As mentioned in Chapter \ref{chap:analysis}, floating point numbers are not supported by \cspm{} and the implementation of it in SMEIL have not been thoroughly tested. Technically TAPS does not distinguish between floating point or integer, but the verification in FDR4 will not be accurate.

\section{Transpiling Channels}
 The read and write syntax in SMEIL are used as a variable in SMEIL. In Listing \ref{lst:smeil_input_parameter}, the syntax \texttt{input.val} indicates a read to the channel \texttt{val} within the bus \texttt{input}. As can be seen, the read and write structures are used like they where simple variables representing a value.

\begin{listing}
\begin{minted}{smeil_lexer.py:SMEILLexer -x}
proc a (in input)
    bus abus {
        val: uint;
    }
{
    abus.val = input.val + 1;
}
\end{minted}
\caption{Example of a read and a write in SMEIL.}
\label{lst:smeil_input_parameter}
\end{listing}
SMEIL does not seperate the communication and calculation in a process statement as can also be seen in Listing \ref{lst:smeil_input_parameter}. This is of great advantage in SMEIL, but the translation becomes more complex because TAPS has to be able to recognise the communication.
TAPS must be able to recognise the communication in an assignment which is possible because both the bus and the channel must be specified in a read or write in SMEIL. If one of the elements in an assignment, right or left hand side, contains a dot, TAPS can assume that it is communication. The original grammar of an assignment like the one in Listing \ref{lst:smeil_input_parameter} can be seen in Listing \ref{lst:smeil_assignment_grammar}. A communication is the \textit{hierarchical accessor} alternative in the \textit{statement} rule. The communication can either be the right hand side of the assignment, which is a write, or part of the left hand side expression, which is a read. A write is simple to recognise, since it is not combined with other parts of the grammar. TAPS can search the \textit{name} of a right hand side assignment and see if it contains a dot. The read is a bit more complicated since it can be used like any internal variable in the expressions. This means that TAPS will have to search all names within the nested expression to find a potential read.
% TODO: Write something more about how TAPS actually achieve this.
\begin{listing}
\begin{grammar}
<statement> ::= <name> `=' <expression> `;' (assignment)

<name> ::= <ident>
\alt <name> `.' <name> (hierarchical accessor)
\alt <name> `[' <array-index> `]' (array element access)

<expression> ::= <name>
\alt <literal>
\alt <expression> <bin-op> <expression>
\alt <un-op> <expression>
\alt <name> `(' \{ <expression> \}  `)' (function call)
\alt `(' <expression> `)'


\end{grammar}
\caption{The original assignment, name and expression grammars defined in \cite{Asheim2018}.}
\label{lst:smeil_assignment_grammar}
\end{listing}
\subsection{Naming Channels}
When translating an SMEIL bus channel to a \cspm{} channel TAPS must define \cspm{} channel names that will be unique, the same way that the formal name of a bus channel in SMEIL is unique.\\

The simplest way of translating the SMEIL channels into \cspm{} chanels is to use the already defined formal name of the SMEIL bus channel. By concatinating the channel name, bus name, and process name into a single channel name in \cspm{} the naming becomes unique.
This means that all reads and writes using the syntax \texttt{bus.channel} from the process \texttt{A} in SMEIL will be translated to \texttt{A\_bus\_channel} in \cspm{}.
It is also possible to use random generated strings instead of using the original SMEIL names, but to ensure correct translation in TAPS it was necesary to have recognisable names for the \cspm channels.
\begin{listing}
\begin{minted}{smeil_lexer.py:SMEILLexer -x}
network net() {
    instance c of clock();
    instance a of A(c.output, val: 1);
    instance _ of A(c.output, val: 2);
    instance s of src(a.output);
}
\end{minted}
\caption{Example of a network with four instances whereas two are instances of the same process.}
\label{lst:Instance_variations}
\end{listing}
The example in Listing \ref{lst:Instance_variations} shows a network consisting of four instances where two of them are instantiating the same process with different constant parameter. All but one instance declaration also includes an instance name which can be used when referencing the process in the instance parameters. SMEIL enforce a rule that two instances of the same process, cannot both have an annonomous instance name which is defined as \texttt{\_}.\\

% NOTE: SMEIL does not support adding instance names to the cspm channel name
With two instances of the same process, in SMEIL, the \cspm{} channels of those processes, would have identical names. It is, of course, crucial to avoid duplicate channel names. TAPS look through the instances, in the SMEIL network, and append the instance name to the \cspm{} channel name. This is also assuming that no developer would assign two identical process instances the same instance name. If the instance name is anonymous, an \texttt{\_} is appended to the \cspm{} channel for simplicity. These restrictions to identical process instances in SMEIL ensures that there will never be two identical named \cspm{} channels in the generated code. The naming of each channel quickly becomes long and chaotic which is one of the compromises of generated code. It is also possible to have bus declarations within the network declaration in SMEIL. These bus channels are named in the same manner as other channels in \cspm{}, however without an instance name appended.

\subsection{\cspm{} Channel Range}
When defining channels in \cspm{} it is important to define a restricted range of acceptable communication for each channel. If the channel is defined with an unbounded range of integers, FDR4 would search through all possible integers which would result in the statespace becomming too large and FDR4 would run out of space. These restricted ranges must, of course, represent relevant values.

As explained in Chapter~\ref{chap:analysis}, all simulated SMEIL channels and variables are defined with a range of observed values and a restricted type.
Because FDR4 only supports integers, only signed and unsigned types are supported in TAPS. The integer following the type defined the bit size of the observed values. This bit size is used to generate a resticted range for the \cspm{} channel, and thereby avoid having a seemingly endless runtime in FDR4.

In Listing ~\ref{lst:range_smeil} the simulated \texttt{seconds} process from the seven segments display example can be seen. The types of the two channels are \texttt{u3} and \texttt{u4} and the observed valures are between 0 and 5 for the first digit and 0 and 9 for the second. TAPS converts the bit size of the type \texttt{u3} to the range \texttt{\{0..7\}} which are then used as the restricted range for the \cspm{} channel representing the first digit. The second digit channel type \texttt{u4} is converted to the range \texttt{\{0..15\}}.  In Listing~\ref{lst:channel_range_cspm} the converted ranges are defining the values of the \cspm{} channels.

\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}

Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP
\end{minted}
\caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:channel_range_cspm}
\end{listing}

It might seem redundant to create \cspm{} channels with a limited range when TAPS is also asserting the widths of the channels. FDR4 will always only perform refinement checks using the values defined for each channel in \cspm{} and therefore there seems to be no point in asserting if the values go beyond this range.

After simulating the SMEIL network, the compiler provides us with both a type and a range of observed values. The type, as explained above, is used to create the restricted range for each \cspm{} channel and the observed values are used for the FDR4 assertions. The range of values that the types represent will always be equal or larger than the range of observed values, and by using these values the assertions becomes valuable.\\

When it comes to transpiling the data generator process into a \cspm{} channel, TAPS also use the type of the bus channel to define the data input channel for the network in \cspm{}. TAPS use this instead of the observed values because it is not possible to guarantee the precise input values of the system. If TAPS used the observed values, the assertions will pass every time, since it will test the values already used to generate the rest of the observed values.

\section{Generating Monitor Processes}
When generating the monitor processes in the \cspm{} program we use the observed values for each channel, as described above.
In the SMEIL grammar defined in \cite{Asheim2018} it is optional to include a range to each bus channel definitions. In Listing \ref{lst:smeil_bus_grammar} the relevant grammar rules from \cite{Asheim2018} can be seen. The square brackets indicates optional parts.

As explained in Chapter \ref{chap:design}, all channels except the input channels are verified in FDR4. This means that there will be a monitor process for almost every channel and since TAPS use the observed values for each channel for the verification, I had to change the original grammar of SMEIL to suppport this. Therefore the grammar shown in Listing \ref{lst:smeil_bus_grammar} is changed to the grammar defined in Listing \ref{lst:smeil_bus_grammar_no_option}. The only difference is that ranges are no longer optional and that the keywork \texttt{exposed} are no longer allowed, since TAPS are not supporting co-simulation, which is what this keyword indicates. As a consequence hereof, the output bus within the data generator process must be defined with a range even though it is not necessary. This is a result of the data processes not being different from other processes in SMEIL.\\
\begin{listing}
    \begin{grammar}
    <bus-decl> ::= [ `exposed' ] `bus' <ident> `\{' <bus-signal-decls> `\}'  `;'

    <bus-signal-decls> ::= <bus-signal-decl> \{ <bus-signal-decl> \}

    <bus-signal-decl> ::= <ident> `:' <type> [ `=' <expression> ] [ <range> ] `;'
    \end{grammar}
    \caption{The bus grammar defined in \cite{Asheim2018}}
    \label{lst:smeil_bus_grammar}
\end{listing}
\begin{listing}
    \begin{grammar}
    <bus-decl> ::= `bus' <ident> `\{' <bus-signal-decls> `\}'  `;'

    <bus-signal-decls> ::= <bus-signal-decl> \{ <bus-signal-decl> \}

    <bus-signal-decl> ::= <ident> `:' <type> [ `=' <expression> ] <range> `;'
    \end{grammar}
    \caption{The bus grammar defined in \cite{Asheim2018} changed to match the demands of the translation.}
    \label{lst:smeil_bus_grammar_no_option}
\end{listing}
The monitor process asserts that the observed values of the \cspm{} channels are actually what is communicated on the channels. In Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the \texttt{Seconds} process from the seven segment example can be seen. The values used for these statements are 0 through 5 for the first digit and 0 through 9 for the second which can be seen defined for each channel in Listing~\ref{lst:range_smeil}.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Seconds_out_first_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
Seconds_out_second_digit_monitor(c) =
    c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
\end{minted}
\caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:monitor_range_cspm}
\end{listing}
The naming of the monitor processes are the name of the channel they are asserting concatinated with \texttt{\_monitor}. This is very simple but very usefull since it means we can automatically find the name of the monitor process when we have the channel name, and vice versa. We also know that no two channel names will ever be equal in the generated \cspm{} code and therefore the monitor processes will also not have any duplicates when using this name scheme. \\

This monitor process structure is a simple but general solution which can be reused in many situations and due to the requirement of opserved ranges, TAPS can always provide a monitor process with this structure for a channel.
\section{Generating a \cspm{} Network}
When generating the process monitor network as described in Section \ref{sec:design_translating_network}, TAPS first search through all writes within each process and generate a monitor processes for each channel.\\

The process monitor network cosists of three parts. Firstly if the process takes an input value, the value must be read from the channel. From the instance parameters defined in SMEIL, TAPS receive the name of the actual SMEIL process and bus that provides the input bus. Then within the process itself, TAPS get the information of which channel within the input bus it is reading from. All this information is gathered to clarify which \cspm{} channel the process monitor network should read from. If there are more input values, this is of course done several times, using prefixing to include more reads.

% NOTE: TAPS does not currently support more than one input channel
The second part is to add the process name with the expected parameters, both input values, output channels as well as constants and internal values.

In the last part, TAPS will have to synchronise the process with the monitor processes connected to its output buses.
TAPS synhronise the process together with each monitor process over the channel it is asserting.
TAPS adds an extra layer around the structure for each extra monitor processes.
This is quite easy to auto generate since TAPS can simply loop over the list of monitor processes or writes for the process. \\

In Listing \ref{lst:channel_range_cspm} the translated \texttt{Seconds} process is defined, and in Listing \ref{lst:monitor_range_cspm} the two monitor processes for the \texttt{Seconds} process are shown.
In Listing \ref{lst:network_example_cspm} the network generated from these two listing is shown where it is easy to see how the read is performed first in the process before the \texttt{first digit} monitor process is synchronised together with the \texttt{Seconds} process. Adding a parentheses around the first synhronisation to keep the structure, the \texttt{second digit} monitor process is synchronised on the \texttt{second digit} channel which completes the process monitor network.

Lastly the \texttt{assert} operator is used to specify to FDR4 that it should create a refinement check against the specification process \texttt{SKIP} and the implementation process \texttt{N\_seconds} and also that it should use the Failure model.\\
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
N_seconds = clock_out_val ? variable ->
            (Seconds(variable)
            [| {| seconds_out_first_digit|} |]
            Seconds_out_first_digit_monitor(seconds_out_first_digit))
            [| {| seconds_out_second_digit|} |]
            Seconds_out_second_digit_monitor(seconds_out_second_digit)

assert SKIP [F= N_seconds \ Events
\end{minted}
\caption{Example of the \texttt{Seconds} network processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:network_example_cspm}
\end{listing}

In SMEIL it is possible to create several networks within the same SMEIL program. This is not a problem for TAPS to translate as long as the program is still a well-formed SMEIL program. Each instance define a process and potentially communication. This communication will always refer to a specifc bus, defined in either a process or a network. This will not change no matter how many networks are defined within the program, since communication cannot span accross the networks.
In theory it is possible to create nested networks where a network can instantiate other networks, and thereby allowing communication across networks, but this has not yet been implemented in SMEIL and therefore TAPS also do not handle this case.
The only situation where seveal networks can become a problem for TAPS are if the networks have instances with the same instance names. As mentioned above, there might be cases where it is necessary to add the instance names to the generated \cspm{} channel names in order to tell the difference between to instanced of the same bus channels. Now if this is the case and there are more than one network using the same instance name for this specific process TAPS could add the network name to the generated \cspm{} channel name for another layer of seperation.

This is a corner case, and the current version of TAPS does not support this, but this is definitely a possible solution.


\section{The Technologies of TAPS}
The system TAPS consist of two parts, the parser and the code generator. The parser is created with ANTLR4~\cite{antlr}, which is described further below. The data transformation and code generation has been developed in Python 2.7 while also utilising the templating language Jinja2~\cite{jinja2}.\\

Usually when doing any form of translation either by a compiler or interpreter, the use of a symbol table is often needed in order to keep information about variable names, function names, classes, communication ect. Usually the translation, when reaching a symbol in the translation, use the symbol table to look up a symbol and retrieve its context if it has any information about said symbol. This can be to check that a variable have been declared or for type checking or similar. The symbol table is usually generated in the analysis section and are used for look ups througout the compilation or interpretation. When walking the parse tree, TAPS gathers all relevant information from the code, and since TAPS expect the SMEIL program to be well-formed, it does not need a symbol table to check if variables have been declared in the process declaration before being used in the body of the process.
\subsection{ANTLR4}
For the transpiling between SMEIL source code and \cspm{} source code, I decided to use a parser generator to create a parser for the SMEIL language.

The reason I choosed a parser generator libary was to simplify the parsing process so I could focus more on the development of correct code generation. Parser generators are tools that provides an automatically generated parser, interpreter or compiler from a specified grammar. Using a parser generator was an obvious choice since the SMEIL grammar was already in a well defined and simple EBNF format. It would also have been possible to create a parser from scratch but since I did not have many specific requirements for the parser, there seemed to be no reason to spend the time writing and debugging my own parser when I could generate it directly.

I decided to use the tool ANTLR4 for creating the parser and lexer. ANTLR4 is a Java-based parser generator library that, based on a grammar, can generate parsers in Java or another target language. ANTLR is a well used tool with a lot of documentation and have recently been used several times within the industry. ANTLR have recently been updated to a new and improved version 4. Other parser generators exists, one of the most known are probably Yacc or Bison. These tools did not seem to be very user friendly or intuitive and some had not been updated in years. ANTLR can also be used to generate tree parsers which can be used to walk the parse tree, which lessens the time working on the parser even more. ANTLR4 seemed to be the best choice in terms of usability and simplicity.

By using ANTLR4 I could easily transform the SMEIL grammar into a parser and lexer that could then immediately be used to transform into \cspm{}.
ANTLR4 supports Extended BNF (EBNF) and it must be defined in \texttt{.g4} file format, which is very similar to other standard grammars. The SMEIL grammar have been changed slightly either because it was more efficient to parse the programs if a grammar rule was removed. For instance the SMEIL grammar does not have a short way of representing "one or more" but only "zero or more". In ANTLR4 it is possible to define the rules as "one or more", and some of these SMEIL rules have been simplified to this. The grammar have also been changes in a few places, simply because there are things within the SMEIL grammar that TAPS does not allow, such as optional ranges, as described earlier.\\

After parsing the code with ANTLR4, one can decide to traverse the parse tree itself or use either the listener or the visitor methods that ANTLR4 provides. The main difference between the listener and the visitor is that the listener provides methods which are called by the walker object directly, and the visitor methods must call its children explicitly to walk them. Both methods can provide the same results, and it often depends on preference. In my implemenation of TAPS I first tried the listener method, but realising that I do not need data from all parse rules, it was not necessary to walk the entire tree and therefore I shifted to the visitor method where I can be specific about which rules ANTLR4 should walk.

After TAPS have walked the parse tree and collected all relevant information, the data is transformed to match the requirements of the \cspm{} code. For example, the names of a bus channel in SMEIL it transformed into a combined name for a \cspm{} channel. I have defined templates in Jinja2 that match these generalised structures in \cspm{} that I can use to represent the SMEIL code. These templates are then used together with the transformed data to generate the \cspm{} code.

Because TAPS only collect data during the tree walk it does not matter how the SMEIL code is structured. With this solution, the network can be defined first or last in the program without any difference to the translation.

%
% With the visitor we gain the advantage that we decide which part of the parse tree we traverse, instead of having to traverse the entire parse tree as with the listener method. With the visitor, for each parser we have to explicitly call \texttt{visit()} on the children that we wish to visit, which, in some cases can make a tree traversal more complex, but in our case we wish to seperate concerns and this is done by having three different tree traversals which collect three differet pieces of data for the code generation.
% When restructuring the code for the visitor method, we have to implement the top parsers, \texttt{module} and \texttt{entity}, even though they dont have any real value for the data we need to collect. However, because of the visitor method having to call all children, we need to implement these two parsers, simply so they can call their children.
% This seem a little pointless compared to the listener, where we can ignore the parsers we do not care about, but if we use a listener we would have to use a stack system and that would cause problems, because a terminal node that we only want sometimes might push something on the stack that we did not want to. Because every time that terminal node is entered or exited the code is run. With the visitor we can control when the nodes are run which means that we avoid some messy stack problems.
% A visitor can return a value like other standard functions which means that we have directly access to the result from it or its children. However, if there are more than one child the result will have to be assigned in a list or similar, to access.
% If there are two expressions in one alternative, we can get the two seperate results by calling \texttt{self.visit(ctx.expression(0))} and \texttt{self.visit(ctx.expression(1))}. This simplifies the structure since we do not have to handle loops in this case, because we know that the structure would always be two expressions, not more and no less.\\
% Even though we update the data structure \texttt{data} by reference instead of returning it as a result from the tree traversals, it is still necessary to return values from some of the parsers. Parts of the data structure cannot be created before having specific data, and the top parser with all the information will then gather the results from its children and update the \texttt{data} dictionary with the new data.


% TODO: Maybe it is worth mentioning how I remove some sub-"parsers" in the grammer, because it made the parsing more complicated . Such like I removed the processdecl nonterminal because I could then call visit(ctx.busdecl) specificly. Otherwise I could also just do "if ctx.busdecl: ..." but, this gave one less step (however, now I am thinking about it, it might not be a good idea. It gives more complexity and maybe thats not good if other people need to understand the antlr grammar. )

% TODO: Write something about how I should just gather the data and then letting the transformation part do any data transformations. I am, for example, not doing that now since I am adding calculations and communications into two different lists.

% TODO: Write something about how smart it is that I can use labels in the grammar and that I can then much more easily control how to handle different alternatives.

