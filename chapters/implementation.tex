








\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mysquare] (SME) at (0, 2.5) {$SME$};
    \node [mysquare] (SMEIL) at (0, 0) {$SMEIL$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (Q) at (2.5, 1.3){$Questions$};
    \draw [myarrow, smooth] (SME) to[out=270, in=90] (SMEIL);
    \draw [myarrow, dotted] (Q) to[out=180, in=90] (SMEIL);


    \node [mysquare] (Parser) at (3, -1) {$Parser$};
    \node [mysquare] (Codegen) at (5.5, -1) {$Code Gen$};
    \node [draw, red, thick, dotted, fit=(Parser)(Codegen), inner sep=0.5cm] (TAPS) {};
    \node [red] at (4.4,0.1) {$TAPS$};
    \draw [myarrow, smooth] (SMEIL) to[out=270, in=180] (TAPS);
    \draw [myarrow, smooth] (Parser) to[out=0, in=180] (Codegen);

    \node [mysquare] (cspm) at (8.5, 0) {$CSP_M$};
    \draw [myarrow, smooth] (TAPS) to[out=0, in=270] (cspm);
    \node [mysquare] (FDR) at (8.5, 2.5) {$FDR4$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (A) at (5.5, 2.5){$Answers$};
    \draw [myarrow, smooth] (cspm) to[out=90, in=270] (FDR);
    \draw [myarrow, dotted] (FDR) to[out=180, in=0] (A);

  \end{tikzpicture}
  \caption{System structure.}
  \label{fig:TAPS_network}
\end{figure}




\section{Transpiling Channels}

\section{Transpiling Networks}

\section{Generating Monitor Processes}

\section{Technologies}

Usually when doing any form of translation either by a compiler or interpreter, the use of a symbol table is often needed in order to keep information about variable names, function names, classes, communication ect. Usually the translation, when reaching a symbol in the translation, use the symbol table to look up a symbol and retrieve its context if it has any information about said symbol. This can be to check that a variable have been declared or for type checking ect.. The symbol table is usually generated in the analysis section and are used for look ups througout the compilation or interpretation.
....

\subsection{ANTLR4}
For the transpiling between SMEIL source code and \cspm{} source code, we decided to use ANTLR4~\cite{antlr} for creating a parser and a lexer. ANTLR4 is a Java-based parser generator library that, based on a grammar, can generate parsers in Java or another target language. ANTLR4 provided a tool that could easily transform the given grammar into a parser and lexer that could immediately be used to transform into \cspm{}.

ANTLR takes a grammar, defined in .g4 (BKNF?) and create the parser and lexer of the files.

A lexical analysis, which is what the lexer does, is a process of converting a string of characters into tokens, which is also called tokenization. Each token represents a lexer rule in the grammer, for instance, if the string is "123" and there is a lexer rule "INT: {0-9}+" which means one or more of 0-9 digits. Then the token would be an INT.

A parser...%TODO: write more here

Currently, only a subset of the SMEIL grammar have been implemented for translating and parts of the grammar have been changed slightly to match the expectations from a simulated SMEIL program, which varies a bit from a non-simulated SMEIL program. An example of this could be that in the original SMEIL grammar a channel declaration only includes an optional range, however, we are expecting a simulated SMEIL program and therefore the simulation would always have generated ranges of observed values for each channel. Therefore, in the grammar, created for ANTLR4, the range for each channel must always be defined.

The ANTRL4 grammar is provided in a filetype called \texttt{.g4} but the structure of the grammar is similar to standard grammar notation.
After running ANTLR4 and generating a parser and a lexer, one can decide to traverse the parse tree itself or use a listener or visitor that ANTLR4 provides. The main difference between the two is that the methods the listener provides are called by the walker object, which ANTLR4 provides, and the visitor methods must call their children explicitly to walk them.
For our implementation, we used the ANTLR4 listener along with Python. When generating a parser and lexer for another target language than Java, the programmer only has to specify this in the ANTLR4 command in the command-line.\\

% NOTE: This part below have been added mostly as a brain dump. Should be re-written or something

With this implementation, we have used the visitor method, which is a well known traversal method %TODO: Is that true?
With the visitor we gain the advantage that we decide which part of the parse tree we traverse, instead of having to traverse the entire parse tree as with the listener method. With the visitor, for each parser we have to explicitly call \texttt{visit()} on the children that we wish to visit, which, in some cases can make a tree traversal more complex, but in our case we wish to seperate concerns and this is done by having three different tree traversals which collect three differet pieces of data for the code generation.
When restructuring the code for the visitor method, we have to implement the top parsers, \texttt{module} and \texttt{entity}, even though they dont have any real value for the data we need to collect. However, because of the visitor method having to call all children, we need to implement these two parsers, simply so they can call their children.
This seem a little pointless compared to the listener, where we can ignore the parsers we do not care about, but if we use a listener we would have to use a stack system and that would cause problems, because a terminal node that we only want sometimes might push something on the stack that we did not want to. Because every time that terminal node is entered or exited the code is run. With the visitor we can control when the nodes are run which means that we avoid some messy stack problems.
A visitor can return a value like other standard functions which means that we have directly access to the result from it or its children. However, if there are more than one child the result will have to be assigned in a list or similar, to access.
If there are two expressions in one alternative, we can get the two seperate results by calling \texttt{self.visit(ctx.expression(0))} and \texttt{self.visit(ctx.expression(1))}. This simplifies the structure since we do not have to handle loops in this case, because we know that the structure would always be two expressions, not more and no less.\\
Even though we update the data structure \texttt{data} by reference instead of returning it as a result from the tree traversals, it is still necessary to return values from some of the parsers. Parts of the data structure cannot be created before having specific data, and the top parser with all the information will then gather the results from its children and update the \texttt{data} dictionary with the new data.


% TODO: Maybe it is worth mentioning how I remove some sub-"parsers" in the grammer, because it made the parsing more complicated . Such like I removed the processdecl nonterminal because I could then call visit(ctx.busdecl) specificly. Otherwise I could also just do "if ctx.busdecl: ..." but, this gave one less step (however, now I am thinking about it, it might not be a good idea. It gives more complexity and maybe thats not good if other people need to understand the antlr grammar. )

% TODO: Write something about how I should just gather the data and then letting the transformation part do any data transformations. I am, for example, not doing that now since I am adding calculations and communications into two different lists.

% TODO: Write something about how smart it is that I can use labels in the grammar and that I can then much mor easily control how to handle different alternatives.


% (About the read of the process happening outside in the network - from the paper)
% This ensures that we can generate the processes easily without having to traverse the network in the SMEIL program beforehand to find out which channel provides input for which process. An example of this is shown in Listing~\ref{lst:cspm} in the appendix on lines 61 to 66.
% "By using this structure it is not necessary to have a symbol table.. "


% (fra design)
% It is, however, important to give channel names that will be unique since a \cspm{} channel is global as opposed to the local channel within each SMEIL bus.
% %%%% Channel names
% The naming will be created by concatinating the channel name, bus name and process name along with underscore in order to generate human readable code. It would also be possible simply to generate a unique string, which might give more security than using a concatinated version, but in this case we decided to make it easier for humans to read and understand the generated code, since the system is still in a "new state"%
%%%% Calling the channel in the bus
% If the bus is generated in the network, then the naming will be the channel, bus and network name instead..
% % TODO: add an example of naming in SMEIL and then in CSPm. Both with process and network defined buses
% In the generated \cspm code, the reference to the each channel, whether it is defined in a process or in a network declaration, will be the specific name generated from the channel, bus and process/network name, as mentioned above. This means that all calls using the syntax \texttt{bus.channel} in SMEIL will be translated to \texttt{bus\_channel} in \cspm.


% TODO: Show an example of range for a channel. That is a type being translated into a range. Like this below:
% \begin{listing}
% \begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
% proc seconds (in seconds_in)
%     bus seconds_out {first_digit: u3 range 0 to 5;
%                      second_digit: u4 range 0 to 9;};
%     var seconds: u6 range 1 to 59;
%     var seconds_first_temp: u3 range 0 to 5;
%     var seconds_second_temp: u4 range 0 to 9;
% {
%     seconds = seconds_in.val % 60;
%     seconds_first_temp = seconds / 10;
%     seconds_second_temp = seconds % 10;
%     seconds_out.first_digit = seconds_first_temp;
%     seconds_out.second_digit = seconds_second_temp;
% }
% \end{minted}
% \caption{Example of the \texttt{seconds} process from the SMEIL seven segment display example. See full example in Listing~\ref{lst:smeil} in the appendix.}
% \label{lst:range_smeil}
% \end{listing}
%
%
% An example of simulated SMEIL code can be seen in Listing~\ref{lst:range_smeil}. Notice on lines 2 and 3 that the two channels are defined both with a type \texttt{u3} and \texttt{u4} and with a range 0 to 5 and 0 to 9. These are the observed types and value ranges the simulation tracked for the specific channel. In order to create the \cspm{} channels based on the types, we need to convert \texttt{u3} and \texttt{u4} into its corresponding range, which for \texttt{u3} is 0 through 7 and for \texttt{u4} is 0 through 15. In Listing~\ref{lst:channel_range_cspm} on lines 1 and 2, the calculated ranges are used to define the \cspm{} channels.
%
% \begin{listing}
% \begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
% channel seconds_out_first_digit : {0..7}
% channel seconds_out_second_digit : {0..15}
%
%     |$\vdots$|
%
% Seconds(seconds_in) =
% let
%     seconds = seconds_in % 60
%     seconds_first_temp = seconds / 10
%     seconds_second_temp = seconds % 10
% within
%     seconds_out_first_digit ! seconds_first_temp ->
%     seconds_out_second_digit ! seconds_second_temp ->
%     SKIP
% \end{minted}
% \caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
% \label{lst:channel_range_cspm}
% \end{listing}



% -----

% In the SMEIL grammar defined in \cite{Asheim2018} it is optional to include a range to the bus channel definitions. The square brackets are indicating optional part of the rule.
% \begin{listing}
%     \begin{grammar}
%     <bus-decl> ::= [ `exposed' ] `bus' <ident> `\{' <bus-signal-decls> `\}'  `;'
%
%     % <bus-decl> ::= [ `exposed' ] [ `unique' ] `bus' <ident> \\ `\{' <bus-signal-decls> `\}'  `;'
%
%     <bus-signal-decls> ::= <bus-signal-decl> \{ <bus-signal-decl> \}
%
%     <bus-signal-decl> ::= <ident> `:' <type> [ `=' <expression> ] [ <range> ] `;'
%     \end{grammar}
%     \caption{The bus grammar defined in \cite{Asheim2018}}
%     \label{lst:smeil_bus_grammar}
% \end{listing}
% The monitor process asserts the observed values of the \cspm{} channels and in Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the Seconds \texttt{time} process can be seen. The values used for these statements are the observed values from the SMEIL simulation, as can be seen at the end of lines 2 and 3 in Listing~\ref{lst:range_smeil}. In Listing~\ref{lst:monitor_range_cspm} the ranges are used to assert that the only values communicated on the channels are within 0 and 5, and 0 and 9 respectively.

% \begin{listing}
% \begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
% Seconds_out_first_digit_monitor(c) =
%     c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
% Seconds_out_second_digit_monitor(c) =
%     c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
% \end{minted}
% \caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
% \label{lst:monitor_range_cspm}
% \end{listing}
