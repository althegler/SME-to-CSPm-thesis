%!TEX root = ../main.tex
The goal of automatic translation is to create a general solution that can fit different types of problems. It is therefore necessary to generalise the different aspects of the translation to find a solution that fits all problems.\\

To achieve this I have designed the system TAPS which is a transpiler from SMEIL to \cspm{}. A transpiler is a source to source compiler which takes source code, written in one language, and outputs equivalent source code in another language.\\

TAPS consists of two main parts, the parser, and the code generator which will be introduced in the following chapters. Based on an SMEIL program, TAPS will generate an equivalent \cspm{} program. This can be loaded into FDR4, which can provide refinement checks on the properties specified by TAPS. An overview of the system can be seen in Figure \ref{fig:TAPS_network}.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mysquare] (SME) at (0, 2.5) {$SME$};
    \node [mysquare] (SMEIL) at (0, 0) {$SMEIL$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (Q) at (2.5, 1.3){$Questions$};
    \draw [myarrow, dashed] (SME) to[out=270, in=90] (SMEIL);
    \draw [myarrow, dotted] (Q) to[out=180, in=90] (SMEIL);


    \node [mysquare] (Parser) at (3, -1.3) {$Parser$};
    \node [mysquare] (Codegen) at (5.5, -1.3) {$Code Gen$};
    \node [draw, red, thick, dotted, fit=(Parser)(Codegen), inner sep=0.5cm] (TAPS) {};
    \node [red] at (4.4, -0.2) {$TAPS$};
    \draw [myarrow, smooth] (SMEIL) to[out=270, in=180] (Parser);
    \draw [myarrow, smooth] (Parser) to[out=0, in=180] (Codegen);

    \node [mysquare] (cspm) at (8.5, 0) {$CSP_M$};
    \draw [myarrow, smooth] (Codegen) to[out=0, in=270] (cspm);
    \node [mysquare] (FDR) at (8.5, 2.5) {$FDR4$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (A) at (5.5, 2.5){$Answers$};
    \draw [myarrow, smooth] (cspm) to[out=90, in=270] (FDR);
    \draw [myarrow, dotted] (FDR) to[out=180, in=0] (A);

  \end{tikzpicture}
  \caption{TAPS system structure.}
  \label{fig:TAPS_network}
\end{figure}

It can be difficult to generate code while still retaining the clean structure and organisation that a skilled developer can produce, but this is not the point of automatically generated code. TAPS comply with a set of predefined structures that is used to transform the specific program into a specific solution, using general structures. Because the code is generated using these standard structures, the resulting source code will often be large and awkward. This is one of the disadvantages of automatically generated code. However, these standard structures are also why auto-generated code is perfect for translating from SMEIL to \cspm{}. The work that lies in manually translating a hardware model to a specification model can be substantial. The code generated by TAPS will mostly be used by FDR4 to run refinement checks and so the complexity and efficiency or the code structure is of less importance.\\

In this chapter, I describe the main design decisions behind TAPS and address the challenges that lie in translating SMEIL to \cspm{}.
\section{Translating Processes}
In order to translate an SMEIL process into a \cspm{} process, it is necessary to create a general process structure in \cspm{}. The SME model enforces that each process reads, executes, and writes, in that order, for each clock cycle, so the \cspm{} structure must support this. To reduce complexity, it is preferable to have one \cspm{} process per SMEIL process, since it would simplify the translation. A simpler solution typically results in a less erroneous solution.\\

What first comes to mind in \cspm{} when a process must read and then write, is the simplest possible process structure using prefix and communication operators.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Proc = c ? x -> d ! x-> SKIP
\end{minted}
This is one of the simplest \cspm{} processes that match the SME model, however with this structure it is not possible to include all the possible computations that SMEIL support. By instead using the \texttt{let within} structure in \cspm{}, it is possible to keep the communication together with the computations in one \cspm{} process, while keeping a simple structure. All computations are performed inside the \texttt{let} clause which can be referenced to inside the \texttt{within} clause where each write is performed.
In Listing~\ref{lst:cspm_let_within_example}, an example of the \texttt{let within} structure can be seen. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes. Since all reads and computations must be performed before writing, this structure should always work for a well-structured SMEIL process.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..100}

P(input) =
    let
        x = input * 5
        y = input * 10
    within
        c ! x -> c ! y -> SKIP
\end{minted}
\caption{Example of the \texttt{let within} structure used to create the general process structure within \cspm{}.}
\label{lst:cspm_let_within_example}
\end{listing}
\section{Translating Data Generation}
It is important to make sure that TAPS can translate all the different methods of generating data in SMEIL, and it is therefore essential that TAPS can recognise a data generator process in SMEIL. As previously explained, a data generator process in SMEIL does not read any input value, neither through a process parameter nor by using the channels hierarchical name. Therefore TAPS must examine the process body, and if the process does not contain input communication, then TAPS will conclude that the process is a data generator process. \\

In \cspm{}, it is possible to create a process with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to synchronise the data generator process with all the processes reading the data. Otherwise, FDR4 would evaluate all values in the defined range of the channel, instead of what was actually communicated on the channel. This would make the data generator process redundant. This extra synchronisation and process added to the \cspm{} network will increase the complexity, and it might also increase the runtime of the verification.
\begin{figure}
    \centering
    \begin{tikzpicture}
       \node[main node] (1) {\small \texttt{data}};
       \node[main node] (2) [right = 4cm of 1] {\texttt{calc}};
       \draw[fill] (0.7,0) circle [radius=0.07];

       \path[draw,thick, ->]
       (1) edge node {} (2);

       \node[align=center, below, text width=1.7cm] at (3.27,0.83){\footnotesize\texttt{channel c : \{0..100\}}};
       \node[align=center, below, text width=1.7cm] at (1.3,0){\footnotesize\texttt{output o : \{0..10\}}};
   \end{tikzpicture}
    \caption{A \cspm{} network with two processes. The output \texttt{o} of the process \texttt{data} is within the range 0 through 10, and the channel \texttt{c} is defined for the range 0 through 100.}
    \label{fig:csp_data_generator_process}
\end{figure}
A figure to visualise this concept can be seen in Figure \ref{fig:csp_data_generator_process}. The channel \texttt{c} between the \texttt{data} process and the \texttt{calc} process is defined for the range \texttt{\{0..100\}}. If the two processes are not synchronised on this channel, the two processes do not have to agree on communication and therefore the search space for FDR4 includes all the values from 0 through 100, even though the \texttt{data} process only outputs 0 through 10. So, if the processes are not synchronised on the channel, the result would be the same as if the \texttt{data} process did not exist. \\

However, if the processes are synchronised, FDR4 will still allocate all 100 possible communications, but it only continues the search on the values actually communicated on the channel.
Adding a data generator process, the data generated for the network could be made more complex which, in some cases, could be an advantage. However, the current goals are to verify that the hardware model handles all communicated data as expected. For this kind of verification, it is necessary to have FDR4 search a larger value space to find potential problems. It is important to find a balance between verifying input values outside of the expected range space and verification runtime. The larger the state space in FDR4, the longer the verification time.

To summarise, when generating data in \cspm{} from an SMEIL data generator process, the two possibilities are either to define the data in \cspm{} by one or more data generator channels or by a data generator process and synchronisation.
Currently TAPS only support generating a data generator channel from the SMEIL network, but translating the SMEIL data generator process to a \cspm{} data generator process would be the same as translating other SMEIL processes to \cspm{}.\\

Listing \ref{lst:clock_data_generation_example_cspm} shows the translated code of the SMEIL network in Listing \ref{lst:clock_data_generation_example_smeil} from Chapter \ref{chap:analysis}. Here it can be seen that the \texttt{clock} process from the SMEIL network is translated into a data generator channel \texttt{clock} in \cspm{}. The translation of the range values defined for each channel is described later in this section.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel clock : {0..100}
channel minutes_outbus_val : {0..1}

Minutes(input) =
let
    from_clock = input / 60
within
    minutes_outbus_val ! from_clock ->
    SKIP

\end{minted}
\caption{Example of the translated \texttt{Minutes} process defined in Listing \ref{lst:clock_data_generation_example_smeil} from Chapter \ref{chap:analysis}.}
\label{lst:clock_data_generation_example_cspm}
\end{listing}
In the case where the SMEIL network does not have a data generator process but is instantiated with constants as parameters or internal values, the \cspm{} processes would also be instantiated with these values as parameters.\\

If there are several data generation processes in the SMEIL program, TAPS will not handle the processes any differently than if there was only one data generator process. Each data generator process will be translated into a \cspm{} channel, and the communication to the rest of the network will be kept intact because of the communication specified in the SMEIL network structure.

\section{Translating Buses and Channels}
As has previously been introduced, the SMEIL bus channel and the \cspm{} channel are equivalent, and can therefore be translated almost directly. However, when the bus is defined as a process parameter within the SMEIL process, the translation becomes more complex, because the parameter name, used inside the process, is a placeholder for the formal bus channel name. It is therefore not possible to translate the channel without either knowing the formal name of the bus channel or changing the structure of the SMEIL process.
When translating the SMEIL process to \cspm{}, it is important to design a well-formed structure to handle these processes parameters.\\

If a process contains an input bus parameter, there are several different methods for translating this input bus parameter to \cspm{}, each with its own advantages and disadvantages.\\

\begin{minipage}[t]{.98\linewidth}
    \centering
\begin{minipage}[t]{0.45\linewidth}
  \begin{minted}{smeil_lexer.py:SMEILLexer -x}
proc double (in inbus)
    bus outbus {
        val: uint;
    };
{
    outbus.val = inbus.val * 2;
}
  \end{minted}
  \captionof{listing}{An SMEIL process with an input bus as parameter.}
  \label{lst:smeil_input_parameter}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Double(input_val) =
    let
        result = input_val + 1
    within
        double_outbus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input value as parameter.}
\label{lst:cspm_input_value}
\end{minipage}
\hspace{0.6cm}
\vspace{0.5cm}
\newline
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Double() =
    other_outbus_val ? value ->
    let
        result = value + 1
    within
        double_outbus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with no input parameter. \texttt{other\_outbus\_val} is the formal name of the input bus, defined in the process \texttt{Other}.}
\label{lst:cspm_no_input}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Double(inbus_channel) =
inbus_channel ? value ->
    let
      result = value + 1
    within
      double_outbus_val ! result ->
      SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input channel as parameter.}
\label{lst:cspm_channel_reads_input}
\end{minipage}
\vspace{0.3cm}
\captionof{listing}{Three different methods of translating the input bus in an SMEIL process to a \cspm{} process input.}
\label{lst:cspm_input_values_examples}
\vspace{1cm}
\end{minipage}
Listing \ref{lst:smeil_input_parameter} shows a simple SMEIL process which takes an input bus as parameter. The three other examples in Listing \ref{lst:cspm_input_values_examples} show different translations.\\

In Listing \ref{lst:cspm_input_value} the value itself is the parameter, which means that the value can be used directly inside the \texttt{let} clause.
This translation results in a simpler translation process within TAPS, because all the information needed to translate lies within the SMEIL process itself. However, when using this structure, the channel read must happen outside of the process, which does not match the original SME model structure. \\

The \cspm{} process in Listing \ref{lst:cspm_no_input} does not have an input parameter. The input parameter from the SMEIL process has been translated directly to its formal channel name corresponding to the bus channel input seen in Listing \ref{lst:smeil_input_parameter}. This solution fits within the original SME model structure because the process itself reads a value before computing and writing. Translating the channel name directly leads to a more complex translation, and TAPS must search the SMEIL network declaration to find the formal channel name. Another downside with this translation is that it eliminates the reusability of the process. The generated code can become unnecessarily complex because similar processes must be defined several times instead of reusing the process and declaring it with different parameters in the network.\\

In Listing \ref{lst:cspm_channel_reads_input}, the channel name is given as input parameter to the \cspm{} process. This translation is the best match to the original SMEIL process structure. The channel name is provided as a parameter, so the process reads the value itself, which means that the process can be reused, as opposed to the solution in Listing \ref{lst:cspm_no_input}. This solution also has the advantage that TAPS does not have to search for information in the SMEIL network to translate the process.
The downside to this solution is that the internal structure of the process must be changed during the translation, as opposed to the solution in Listing \ref{lst:cspm_input_value}. In the original SMEIL program in Listing \ref{lst:smeil_input_parameter}, the \texttt{input} value is declared in the process parameter and used directly in the process body. In this solution, TAPS would have to change one of these and put in an intermediate step where the process reads a value and then uses the value in the process body. The process in Listing \ref{lst:cspm_channel_reads_input} is implemented with this intermediate step.\\

Out of these three solutions, it is clear that even though the solution in Listing \ref{lst:cspm_no_input} is the simplest version, the translation would become quite complex, which is a big disadvantage. In order to create the simplest solution possible, I decided to use the solution in Listing \ref{lst:cspm_input_value}. Even though it does not exactly match the SME model, this will not be a problem, since the read is performed in close relation to the process. This will be explained in Section \ref{sec:design_translating_network}. Using this solution results in a simpler translation for each process, and thus most of the translations can be performed easily without needing detailed information about the rest of the system.\\

If the SMEIL process contains an output bus parameter, the translation does not become as complex as translating an input bus parameter. The process must always write the value itself and therefore the method for translating the output bus parameter into \cspm{} is similar to the translation in Listing \ref{lst:cspm_channel_reads_input}, where the process receives the bus name as parameter. However, when using this method with output bus parameters, the process structure can be translated directly without an intermediate step, thus providing a less complex translation.\\

In the case where the process does not have any parameters but is communicating via the bus channels hierarchical names, TAPS will be able to translate the processes directly because the actual name of the bus channel is defined within the process itself.

\section{Verification in \cspm{}}
In order to create the assertions for the refinement checking, TAPS will create separate assert functions to keep the code structure clean. It is entirely possible to include the assertions within the processes, but to keep the seperation of concerns, I have decided to add this separately. This will increase the complexity of the generated \cspm{} network, but it is still preferable to more complex process structures. For each \cspm{} channel there must be an assertion, except for data generator channels. Consequently, TAPS creates a \textit{monitor} process for each channel. This monitor process will listen in on the channel communication, and assert the values communicated there. The monitor process is a process that is added specifically for asserting legal communication values in FDR4, and it does not affect the original SME network. The monitor process checks the values communicated on the channel, and if all values are within the expected range, the process behaves as the \texttt{SKIP} process to indicate successful termination. If all values are not within the expected range, the monitor process behaves as the \texttt{STOP} process to indicate failure. \\

For security and simplicity reasons, all channels, except data generator channels, are always verified. If only a subset of channels were verified, the verification might not catch all potential failures.
In Figure~\ref{fig:assertion_process}, the outline of the monitor process structure can be seen. I expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

For FDR4 to actually perform any refinement checking, an assertion must be added to the \cspm{} program by using the \texttt{assert} keyword.
To assert that the entire network terminates successfully the \texttt{SKIP} process is used as the specification process and the network as the implementation process to verify. An example of this can be seen below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
assert SKIP [F= Network \ Events
\end{minted}
By hiding all events, they become internal events which still complies with the rules and structures of the network, but the refinement check does not include them. This also means that the refinement check is between \texttt{SKIP} and the resulting process of the network. If the network terminates successfully, its resulting process is the \texttt{SKIP} process. Therefore the refinement check passes because the \texttt{SKIP} process failure-refines the \texttt{SKIP} process.\\

The assertion uses the \textit{failures} model described in Chapter \ref{chap:background}, since it is not possible to use the \textit{traces} model in this case. The \textit{traces} model cannot be used because \texttt{SKIP} is defined as $\tick \then \STOP$. Failures within the network are defined using \texttt{STOP}, so a failure in the network would also be accepted when using the \textit{traces} model because the traces of \texttt{STOP} and $\tick \then \STOP$ are the same. By using the \textit{failures} model, the refinement check fails if a monitor process does not terminate successfully. The failures of a \texttt{SKIP} process includes $\tick$, which is not included in the failures of the \texttt{STOP} process. Therefore, even though their traces are equal, the failures are not, thus providing the result needed for the verifications.
\section{Translating Network}
\label{sec:design_translating_network}
When translating a network in SMEIL to \cspm{}, it is crucial that the composition of the network is kept intact. As much as the network is a crucial part of the SMEIL program, it is also one of the most tricky structures to translate correctly. A generated network can quickly become very complex, making it harder to ensure correct translation. \\

An SMEIL network is separated into instances that each instantiates a single process and parameters. As mentioned in Chapter \ref{chap:analysis}, the closest equivalence to the SMEIL network in \cspm{}, are the parallel operators. To create a similar network in \cspm{}, TAPS will synchronise the two processes with the channels they are communicating on.
This is the only way in \cspm{} to enforce synchronised communication on channels, which is an essential part of the synchronised network in SMEIL. An example of a simple network in \cspm{} can be seen in Listing \ref{lst:general_parallel_operator}, where the process \texttt{P} is synchronised with the process \texttt{Q} over the channel \texttt{c}.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}

P = c ! 42 -> SKIP
Q = c ? x -> SKIP

Network = P [|{| c |}|] Q
\end{minted}
\caption{Example of synchronisation using the generalised parallel operator.}
\label{lst:general_parallel_operator}
\end{listing}
This example uses the generalised parallel operator, because both processes communicate only on the channel \texttt{c}.

Two processes that must synchronise on the same channels but also must communicate on other channels, can be synchronised using the alphabetised parallel operator. An example can be seen in Listing \ref{lst:alphabetised_parallel_operator}, where process \texttt{P} communicates both on channel \texttt{c} and \texttt{d}. Process \texttt{Q} does not communicate on channel \texttt{d}, and therefore if the generalised parallel operator was used in this case, then process \texttt{Q} would also have to agree on communication on channel \texttt{d}. In this example, the alphabetised parallel operator expresses that process \texttt{P} is allowed to perform events from the set on the left-hand side of the operator, which contains both channel \texttt{c} and \texttt{d}, and process \texttt{B} is only allowed to perform events on channel \texttt{c}, defined on the right-hand side.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}
channel d : {0..100}

P = c ! 4 -> d ! 50 SKIP
Q = c ? x -> SKIP

Network = P [{| c, d |} || {| c |}] Q
\end{minted}
\caption{Example of synchronisation using the alphabetised parallel operator.}
\label{lst:alphabetised_parallel_operator}
\end{listing}

The challenge when translating the network from SMEIL to \cspm{}, is to ensure that all processes are connected with the other processes on the correct channels.
Since it is only possible to synchronise two processes at a time in \cspm{}, it is a challenge to generate an entire network. The synchronisation of two processes becomes a new process which can then be synchronised with another process. This results in a lot of nested synchronisations, one for each process in the network, which quickly becomes very complex. However, since the \cspm{} code is generated automatically, this is not a problem.\\

Not only is it important that the network is generated to be equivalent to the original SMEIL network, but the monitor processes generated for each of the \cspm{} processes must also be included in the network. Since the monitor processes are only listening in on one specific channel, TAPS starts out by synchronising the monitor with the process by using the generalised parallel operator on the channel. The monitor process is synchronised with the writing process, since a potential erroneous value will emerge at the write end of the channel.\\

If there are several output channels from a process, the synchronisation of the monitor processes will be nested together. A structure like this can be seen in the example below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_P_monitor_network = (P [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
As mentioned above, if the SMEIL process contains an input parameter, the value must be read and added to the process as an input parameter. This is also included in this process monitor network before the processes are synchronised. This can be seen in the example below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_P_monitor_network =
    channel ? x -> (P(x) [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
This design ensures that the monitor processes are included correctly in the network, and also that each read for the processes is defined without too much complexity. This process monitor network can be considered a shell around process \texttt{P}, since it only contains process relevant information. Because of the structure of this process monitor network, TAPS is able to use this as a single process that reads and writes to other processes. After this small network has been generated, it can be synchronised with other similar networks that share communication.\\

As mentioned in Chapter \ref{chap:analysis}, it is possible to instantiate one SMEIL process several times within the SMEIL network. Since TAPS is creating the network in \cspm{} by synchronising processes on channels, it can synchronise the same process several times with different channels or parameters, creating the same functionality as the instances declaration in SMEIL. An example of this can be seen below.\\ \begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_P_monitor_network =
    (P(1) [|{| c |}|] P(2)) [|{| c |}|] P(3)
\end{minted}

Translating the SMEIL network into an equivalent \cspm{} network is difficult and will quickly become very complex. Adding extra monitor processes increase the complexity of the network, and it is crucial that it does not affect the functionality of the network, but by using the structure introduced above, TAPS can include the monitor processes without affecting the original SMEIL network.


\section{Translating the SME Clock}
CSP was not initially developed for hardware modeling, and therefore it is not evident how to handle the clock cycle in the translation. However, clock cycles is an essential part of hardware modeling and therefore it is crucial to design a solution that represents the simulated clock cycles from the SMEIL program. The observed values of the SMEIL simulation represents all values communicated in all the simulated clock cycles.
When using these observed values as ranges in the generated \cspm{} code, FDR4 will create a state space of all possible combinations of these values.
Therefore, even though the translation is between an SME model, where the clock is crucial, and a \cspm{} model, which do not have a clock structure, the translation will still represent the correct input in the state space for FDR4 to verify.




% TODO: Figure out if I should use this. It is not exactly how FDR4 represents these things, so maybe not? :/
% \begin{figure}[!ht]
%   \centering
%   \begin{tikzpicture}
%       \node[align=center, below, text width=1.7cm] at (0,3.5){SMEIL};
%     \node [mysquare] (sme_input) at (0, 2.5) {$x \in \{1,2,3\}$};
%     \node[align=center, below, text width=1.7cm] at (0.2,1.4){$x$};
%     \node [mysquare] (sme_proc) at (0, 0) {$y = x*4$};
%     \draw [myarrow, smooth] (sme_input) to[out=270, in=90] (sme_proc);
%     \node[align=center, below, text width=1.7cm] at (0.2,-0.7){$y$};
%     \draw [myarrow, smooth] (sme_proc) -- (0,-1.7);
%
%
%     \node[align=center, below, text width=1.7cm] at (5.2,3.5){\cspm};
%     \node [mysquare] (1) at (3, 2.5) {$1$};
%     \node[align=center, below, text width=1.7cm] at (3.2,1.4){$x$};
%     \node [mysquare] (1_proc) at (3, 0) {$y = x*4$};
%     \draw [myarrow, smooth] (1) to[out=270, in=90] (1_proc);
%     \node[align=center, below, text width=1.7cm] at (3.2,-0.7){$y$};
%     \draw [myarrow, smooth] (1_proc) -- (3,-1.7);
%
%     \node [mysquare] (2) at (5, 2.5) {$2$};
%     \node[align=center, below, text width=1.7cm] at (5.2,1.4){$x$};
%     \node [mysquare] (2_proc) at (5, 0) {$y = x*4$};
%     \draw [myarrow, smooth] (2) to[out=270, in=90] (2_proc);
%     \node[align=center, below, text width=1.7cm] at (5.2,-0.7){$y$};
%     \draw [myarrow, smooth] (2_proc) -- (5,-1.7);
%
%     \node [mysquare] (3) at (7, 2.5) {$3$};
%     \node[align=center, below, text width=1.7cm] at (7.2,1.4){$x$};
%     \node [mysquare] (3_proc) at (7, 0) {$y = x*4$};
%     \draw [myarrow, smooth] (3) to[out=270, in=90] (3_proc);
%     \node[align=center, below, text width=1.7cm] at (7.2,-0.7){$y$};
%     \draw [myarrow, smooth] (3_proc) -- (7,-1.7);
%   \end{tikzpicture}
%   \caption{TAPS system structure.}
%   \label{fig:TAPS_network}
% \end{figure}