%!TEX root = ../main.tex
% Description of the actual solutions
% TODO: Write something here
The goal of automatic translation is to be able to create a general solution which can fit different types of problems and therefore it is necessary to generalise the different aspects of the translation and find a solution that fits all.
\section{Designing TAPS}
In this section we describe all the design decisions included in creating TAPS so that it addresses all the challenges of the translation between SMEIL and \cspm{}. The section is divided in a similar way as Chapter \ref{chap:analysis}, and we will go through all the challenges described there.
\subsection{Behavioral}
%% - Behavioral description - hvad den enkelte funktion gør. det oversættes ret nemt. Jeg bekymre mig ikke om variable og sådan nogle ting. Det er allerede gjort før det gøres til SMEIL, og dem kan jeg genbruge i min code generation.  Funktionel indhold af processer/ opførsel af den enkelte process - det er rimelig nemt oversat direkte til CSPm. Her kan man beskrive hvis der er nogle sproglige udfordringer, fx hvis CSPm ikke har loops eller lign.

% NOTE: This version of the design chapter is only for the non-clocked version. I have to start somewhere and it seems silly not to talk about this solution at all. This way I will also be able to dicuss the differences i guess. However, it will require more writing and thereby lenghten the overall thesis. But I think I should be able to reuse most of the non-cloked version and then add some sections about the clocked structure and maybe add a bit about how the processes are changed.
\subsubsection{Processes}
In order to translate the SMEIL process to a \cspm{} process we had to create a general process structure in \cspm{}. We know that the SME model enforce that each process reads, calculates and writes, in that order, for each clock cycle, so we needed to create a \cspm{} structure that could support this. First of all we wished to have one \cspm{} process per SMEIL process, since it would simplify the translation and a simpler solution typically results in a less errornous solution.

What first comes to mind in \cspm{} when we want to read and then write, is a very simple process structure using prefix and communication operators.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Proc(x) = c ? x -> d ! x-> SKIP
\end{minted}
This is the simplest \cspm{} process that match the SME model, however with this structure it is not possible to include all the possible calculations that SMEIL support. It turned out that the tricky part of translating a general SMEIL process to \cspm{} was to be able to include the calculations properly.

By using the \texttt{let within} structure in \cspm{} we are able to keep the communication together with the arithmetics in one \cspm{} process while keeping a simple structure. The \cspm{} process does not do the actual read, but instead received the value as a parameter, then all arithmetics are performed inside the \texttt{let} clause while the writing will be put in the \texttt{within} part.
In Listing~\ref{lst:channel_range_cspm}, an example of the \texttt{let within} statement can be seen. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes. Since we know that all reads and calculations must be done before writing this structure should always work for a well-structured SMEIL process.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel seconds_out_first_digit : {0..7}
channel seconds_out_second_digit : {0..15}

    |$\vdots$|

Seconds(seconds_in) =
let
    seconds = seconds_in % 60
    seconds_first_temp = seconds / 10
    seconds_second_temp = seconds % 10
within
    seconds_out_first_digit ! seconds_first_temp ->
    seconds_out_second_digit ! seconds_second_temp ->
    SKIP
\end{minted}
\caption{Example of the \texttt{Seconds} process from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
\label{lst:channel_range_cspm}
\end{listing}
% TODO: Maybe this example should be shortened a bit (we simply want to show the let within statements). Also change the label to match what it is

Since \cspm{} does not need us to declare variables beforehand, we can ignore the variable declarations in the SMEIL process and simply translate all the arithmetic statements, with the variables, directly. The input bus from the SMEIL process is transformed to a variable containing a value instead but this does not change the structure of the arithmetic statements.
% Constants are simply defined in the \cspm program, seperate from the process. Since the SMEIL programs must be well-formed, we know that only the processes that define the constant will use it, and therefore it is not a problem that
% NOTE Constants are currently not implemented in TAPS
% TODO: How to handle variables with predefined values

The types and ranges of variables and constants are not translated, and unless we need the information for verification, it is completely ignored. We can do this because we know the SMEIL program is well-formed and since the variables are not used for verification, it does not matter what types and values the SMEIL program expects of these.

All assignments that are not communication are simply translated directly into \cspm{} without much change, however if the assignment is to or from a bus, then TAPS have to differentiate and handle these assignments differently, which will be explained later in this section.
If-satements are translated into the \cspm{} version of an if statement, however since \cspm{} does not support \texttt{elif}, the if statements are nested to form these expressions. This quickly becomes very complex and hard to read, but since it is auto generated, it is not a problem to create.
% NOTE: If-statements are currently not implemented in TAPS

Traces and assertions are, as explained in Chapter \ref{chap:analysis} not useful in the \cspm{} program and therefore we either throw them away or keep them as comments for the sake of the overview of the code. Currently TAPS throw them away, but it would be a simple task to change this and add them as comments.
% NOTE: Assertions are not curently implemented in TAPS. Trace is.

Most expressions of SMEIL can be directly translated, like \texttt{+}, \texttt{-}, \texttt{/} and \texttt{\%} etc. however there are a few differences in the presendence
% TODO: Be exactly sure about this and write more.

% TODO: Write about the expressions not possible in \cspm{}


% TODO: Write more when I have more implemented for the processes (like arrays and stuff)
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\

\subsubsection{Generating data}
%%% Generator processes
It is important to make sure that TAPS can handle the different kind of data generation possible in SMEIL. A data generator process in SMEIL does not read any input value, no matter if it is through a process parameter or by using the channels hierarchical name. \\

In \cspm it is necessary to define the space of data that FDR4 search through. It is a possibility to create a process in \cspm with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to syncronise the data process with the processes receiving the data, otherwise FDR4 would simply evaluate all values within the defined range of the channels, making the data generator process obsolete. This extra syncronisation will increase the complexity of the system and it might also increase the runtime of the verification, since the \cspm{} network would include more states.

\begin{figure}
    \centering
    \begin{tikzpicture}
       \node[main node] (1) {\small \texttt{data}};
       \node[main node] (2) [right = 4cm of 1] {\texttt{calc}};
       \draw[fill] (0.7,0) circle [radius=0.07];

       \path[draw,thick, ->]
       (1) edge node {} (2);

       \node[align=center, below, text width=1.7cm] at (3.27,0.83){\footnotesize\texttt{channel c : \{0..100\}}};
       \node[align=center, below, text width=1.7cm] at (1.3,0){\footnotesize\texttt{output o : \{0..10\}}};
   \end{tikzpicture}
    \caption{A \cspm{} network with two processes. The output \texttt{o} of the process \texttt{data} is within the range 0 through 10, and the channel \texttt{c} is defined for the range 0 through 100.}
    \label{fig:csp_data_generator_process}
\end{figure}
An figure of this can be seen in Figure \ref{fig:csp_data_generator_process}. Here, the channel \texttt{c} between the \texttt{data} process and the \texttt{calc} process is defined for range of \texttt{\{0..100\}}. If the two processes are not syncronised on this channel, the two processes do not have to agree on communication and therefore the search space for FDR4 includes all the values from 0 through 100. This means that if we just have the channel \texttt{c} as an input channel for the process \texttt{calc}, then we get the same result, since the processes are not syncronised on the channel.
However, if the processes are syncronised, FDR4 will still allocate all 100 posibilities, but it only continues the search on the values actually communicated on the channel. In this case, the only values FDR4 would actually continue searching will be from 0 through 10.
When adding a data generator process as well as syncronisation, the data generator process would be able to define specific data for the search space and that might prove to be an advantage when interested in more complex data.

So when generating data in \cspm{} from a SMEIL data generator process, the two possibilities are either to define the data in \cspm by a single channel or by a data generator process and syncronisation, just like in SMEIL.
Currently TAPS only support one of the two options, which are to generate an input channel from the SMEIL network.
% NOTE: Only one type of data generator process are supported right now.
Listing \ref{lst:clock_data_generation_example_cspm} is the translated version of the SMEIL network from Listing \ref{lst:clock_data_generation_example_smeil}. How TAPS translate the values of the channels are described later in this section. 
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock : ...
channel minutes_output_val : ...

Minutes(input) =
let
    from_clock = input / 60
within
    output_val ! from_clock ->
    SKIP
\end{minted}
\caption{Example of the translated \texttt{Minutes} process defined in Listing \ref{lst:clock_data_generation_example_smeil}.}
\label{lst:channel_range_cspm}
\end{listing}


In the case where the SMEIL network does not have a data generator process but are instantiated with constants or internal values, the \cspm processes would also have to be instantiated with values as their parameters.


%%% Generator processes - input bus with const declared
If there is an input bus in all processes, the job of locating the data or generator process becomes more difficult. In Figure %TODO: Create a figure with an example of a process like AddOne, where there is an input bus an a const. Also add how it should be translated in a subfigure next to it.
an example of a process with an input bus, but where the process also works as the data instantiation point. In this case the constant that are communicated to the process from the network instance declaration indicates what value the network should start with and the process then communicates it on its output bus and then acts as an integral part of the communication of the network for the rest of the clock cycles. This means that the process has a task to perform after the instatiation of the data and therefore the transpiler cannot simply translate it into a \cspm channel, because that would mean that the task the process performs after the data initialization, will not be possible afterwards. One way of solving this problem would be for the programmer to avoid these "two-task" processes, however that is also not a neat solution and it will be a hindrance for the programmer to structure the network in a certain way in order to verify the code later on. However, in the case of the \texttt{AddOne} example, the easy solution would simply be for the programmer to create an extra process which initialized the data and then communicated it once to the process which then would loop for each clock cycle.
%TODO: Figure out how I can handle this in a better way than simply ask the programmer not to create processes like this, and write about it.

%% Generator processes - More than one process
If there are several processes in the SMEIL program that acts as a data generator process, the transpiler will not handle the processes different than if there were one data generator process. If the processes consists only of generating data, then the processes will be translated into a \cspm channel for each process, and the comunication to the rest of the network will still be kept intact since all the communicated are specified by the SMEIL network structure.
%TODO: Find an example with more than one data generation process.
If the processes are not simple data generator processes, then the transpiler will have to handle it differently %TODO: Figure out how I can handle this in a better way than simply ask the programmer not to create processes like this, and write about it. - Same as with one process but if it becomes more complicated with more than one, then write it here!






% Buses
As explained above, the input for the process is recieved as a process parameter in \cspm{} and therefore TAPS will have to recognise the input parameter. Since the bus parameters for a SMEIL process is the bus name, the process itself must reference the specific channel within the bus. This is applied whether it is reads or writes.
This means that TAPS can recognise communication simply by the structure of the assignment. If one of the elements in an assignment, right or left, contains a dot, then we can assume that this is communication.






\subsection{Structural}
% - Strukturel information: hvilke proceser er der og hvilke buser er de limet sammen med. hvordan hænger tingene sammen. Det er også forholdsvis nemt fordi FDR har processer på samme måde som SMEIL har. de har en historisk afhængighed ift. SME og CSP.

% TODO: Write about two networks and how it will be translated to a network and therefore we should be able to have them seperated easily and the communication is what combines them, and that is the same in cspm. TODO: But ask Truls if this would even make sense. To have to networks.

% TODO: Write about how one process can be defined in SMEIL several times and how it does not matter, since the process will be defined the same in CSPm but that the network will simply be generated twice with two different names and inputs or similar. (Does that also work if it is different output?)

% (moved from analysis: )
%  % None of these two posssible usecases are currently implemented in TAPS, and thus the keyword \texttt{exposed} will cause an error in the transpiler. %TODO: Will it cause an error? And should I add more info to this?



% %%%% Generating the network
We can standardize the network generation by creating a two-step communication part. Instead of having the actual processes receive the incoming data, they receive the data by their process parameter. The process parameter is then set by the network process which receives the communication from the channels and provides the process with the communicated value.
This ensures that we can generate the processes easily without having to traverse the network in the SMEIL program beforehand to find out which channel provides input for which process. An example of this is shown in Listing~\ref{lst:cspm} in the appendix on lines 61 to 66.

% %%%% Instances and two networks.
% TODO: Add an example showing two different networks and how it translates.
When translating the instances of a SMEIL network, the transpiler does not need to keep the instances together in a certain way. Each instance will be translated into a seperate \cspm network and even though the networks might have communication in common, they do not need to be connected in \cspm. If the networks/instances have communication in common, it will be handled by the communication in \cspm. When translating from an instance into a network in \cspm it is simply to map the communication from the correct channels and to the correct channels in \cspm. If the process is connected to a monitor process this is also in the network that the monitor process is added to the communication it will be listening in on.
In a SMEIL program it is possible to have several networks in one program. There is not much of a point in doing so, since it will result in the same as having all instances in one network %TODO: Am I 100\% sure that two networks is the same as one? ask Truls
, but never the less, if there is two networks it will not matter in the \cspm translation. One SMEIL instance represents one \cspm network, and all these networks or instances are combined via communications on channels or buses. The only thing we are interested in when translating the SMEIL instances are the communication defined in each instance. And that is what creates the network. This means that we can generate the \cspm networks without looking at what SMEIL network that specific SMEIL instance came from, because the important thing, the communication, is defined in the instance and therefore all data about how the SMEIL network is combined together we still keep intact even though we translate the instances without considering the rest of that SMEIL network.
% %%%% Instances with the same process twice
% TODO: Add an example showing one process added twice and hwo it translates.
When defining instances in the SMEIL network, it is possible to define the same process several times and have it receive different input or send different output or constants. When translating this to a \cspm network, the process itself will be generated as all other processes, but simply the network will be two seperate network, as if it was two SMEIL instances calling two different SMEIL processes. The only difference between the two networks are that the input channel will be different, if that is the difference between the two SMEIL instances.



% %%%% Channels %%%%%
When generating the channels that represents bus channels in SMEIL, each SMEIL channel will be generated into an \cspm channel.
% TODO: write more here above. Why can we do this. Add something about ranges.
% TODO: What if I need to translate a bus with letters, or something else? what kind of channel does that become?

% %%%% Channel names
The naming will be created by concatinating the channel name, bus name and process name along with underscore in order to generate human readable code. It would also be possible simply to generate a unique string, which might give more security than using a concatinated version, but in this case we decided to make it easier for humans to read and understand the generated code, since the system is still in a "new state".
% %%%% Calling the channel in the bus
If the bus is generated in the network, then the naming will be the channel, bus and network name instead.
% TODO: add an example of naming in SMEIL and then in CSPm. Both with process and network defined buses
In the generated \cspm code, the reference to the each channel, whether it is defined in a process or in a network declaration, will be the specific name generated from the channel, bus and process/network name, as mentioned above. This means that all calls using the syntax \texttt{bus.channel} in SMEIL will be translated to \texttt{bus\_channel} in \cspm.
% %%%% Bus only defined as parameter
If the bus is only defined as a parameter in the process, the process will still have to call the bus channels in order to receive or send data on the bus. This is up to the programmer to make sure that the channel name used, are the channel names that the bus have been defined with, no matter where in the program the bus is defined. When generating the \cspm code, the calls to the channels will be the same, no matter where the buses was defined in the original SMEIL program. The channels will all be defined as global channels and the references will be the same as mentioned above (maybe add reference)
% TODO: Maybe add a refernece to a figure here.
% %%%% Bus used as input bus with more that one channel
If a bus is used as input bus in a process, the process will have to call the specific channel of the bus in order to access the data, comunicated on that specific bus. If the channel have more that one channel, the method of calling does not change, and it is up to the programmer to make sure that the channel called, are actually a channel within that specific input bus.



% channels from SMEIL to CSPm
Channels within an SMEIL bus can be translated directly to \cspm{} channels. Since a SMEIL bus consist of channels, the translation is quite simple. It is, however, important to give channel names that will be unique since a \cspm{} channel is global as opposed to the local channel within each SMEIL bus. Because there are several different ways to define a bus in SMEIL %TODO: see the analysis chapter,
the translation will have to recognize the different types and generate the \cspm channels no matter how they where defined.


\subsection{Meta and verification}
% - Opserverede værdier - "known limits". Meta information i SMEIL, og det skal oversættes til faktiske processer med faktiske semantic i FDR der også er en del af topologien. (Det er essensen for mig).

% %%%% Monitor processes %%%%%
When creating the assertions, we decided to create separate assert functions to keep the code structure clean. We know that for each \cspm{} channel there must be an assertion, except for the input channel.
% TODO: Only in the case where we assert channel ranges.. maybe add something about that.
Consequently, we create a \textit{monitor} process for each channel and its only job is to listen in on the channel communication and assert the values communicated there. The monitor process is a process that we add specifically for asserting legal communication values in FDR4 and it does not affect the original SME network.
In Figure~\ref{fig:assertion_process} the outline of this kind of structure can be seen and we expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.

% The monitor process asserts the observed values of the \cspm{} channels and in Listing~\ref{lst:monitor_range_cspm} the two monitor processes for the Seconds \texttt{time} process can be seen. The values used for these statements are the observed values from the SMEIL simulation, as can be seen at the end of lines 2 and 3 in Listing~\ref{lst:range_smeil}. In Listing~\ref{lst:monitor_range_cspm} the ranges are used to assert that the only values communicated on the channels are within 0 and 5, and 0 and 9 respectively.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

% \begin{listing}
% \begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
% Seconds_out_first_digit_monitor(c) =
%     c ? x -> if 0 <= x and x <= 5 then SKIP else STOP
% Seconds_out_second_digit_monitor(c) =
%     c ? x -> if 0 <= x and x <= 9 then SKIP else STOP
% \end{minted}
% \caption{Example of the \texttt{Seconds} monitor processes from the generated \cspm{} code in the seven segment display example. See full example in Listing~\ref{lst:cspm} in the appendix.}
% \label{lst:monitor_range_cspm}
% \end{listing}

% %%%% Monitor processes: More that one monitor process for a channel
It is possible to have as many monitor processes as needed in the network. Since they dont change the functionality of the system, they can be added without problems. In both \cspm and SMEIL a channel has an input and an output, but the output is not for a specific process. all processes can acces the data on a bus in SMEIL, as long as the network describes the communication, and the same in \cspm.
% %%%% Monitor processes: Monitor observed ranges

% %%%% Monitor processes: monitor something else that ranges





% It is important to mention that the FDR version of the SMEIL program are represented as one clock cycle and therefore we do not have to handle implicit clock cycle issues. we can just translate one-to-one, because FDR models one clock cycle and the input represents all possible input in one clock cycle.


\section{Clock cycle problem}
\input{chapters/clock_cycle_problem}

CSP was not initially developed for hardware modeling, and therefore it is not evident how to handle the clock cycle, which is an essential part of hardware modeling. When we transpile the SME network into \cspm{}, the SMEIL simulation have provided the ranges of all values from the simulation and therefore all clock cycles. This means that when FDR4 asserts a property it asserts on all possible communication combinations for all the simulated clock cycles. Therefore, even though we are transpiling from an SME model, where the clock is crucial, we can simply translate ``one-to-one" from the SMEIL program and still get an accurate assertion on the properties.



% TODO: Async vs. sync processes

%%% Generator processes - clock cycles
%TODO: Write something here?