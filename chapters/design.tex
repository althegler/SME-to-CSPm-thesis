%!TEX root = ../main.tex
The goal of automatic translation is to create a general solution that can fit different types of problems. It is therefore necessary to generalise the different aspects of the translation to find a solution that fits all problems.\\
To achieve this I designed the system TAPS which is a transpiler from SMEIL to \cspm{}. A transpiler is a source to source compiler which takes source code, written in one language, and outputs equivalent source code in another language.\\

TAPS consists of two main parts, the parser, and the code generator which will be introduced in the next couple of chapters. Based on the SMEIL program TAPS will generate equivalent \cspm{} code. This can be loaded into FDR4 which can provide refinement checks on the properties specified by TAPS. An overview of the system can be seen in Figure \ref{fig:TAPS_network}.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mysquare] (SME) at (0, 2.5) {$SME$};
    \node [mysquare] (SMEIL) at (0, 0) {$SMEIL$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (Q) at (2.5, 1.3){$Questions$};
    \draw [myarrow, dashed] (SME) to[out=270, in=90] (SMEIL);
    \draw [myarrow, dotted] (Q) to[out=180, in=90] (SMEIL);


    \node [mysquare] (Parser) at (3, -1.3) {$Parser$};
    \node [mysquare] (Codegen) at (5.5, -1.3) {$Code Gen$};
    \node [draw, red, thick, dotted, fit=(Parser)(Codegen), inner sep=0.5cm] (TAPS) {};
    \node [red] at (4.4, -0.2) {$TAPS$};
    \draw [myarrow, smooth] (SMEIL) to[out=270, in=180] (Parser);
    \draw [myarrow, smooth] (Parser) to[out=0, in=180] (Codegen);

    \node [mysquare] (cspm) at (8.5, 0) {$CSP_M$};
    \draw [myarrow, smooth] (Codegen) to[out=0, in=270] (cspm);
    \node [mysquare] (FDR) at (8.5, 2.5) {$FDR4$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (A) at (5.5, 2.5){$Answers$};
    \draw [myarrow, smooth] (cspm) to[out=90, in=270] (FDR);
    \draw [myarrow, dotted] (FDR) to[out=180, in=0] (A);

  \end{tikzpicture}
  \caption{System structure.}
  \label{fig:TAPS_network}
\end{figure}

It can be difficult to generate code while still retaining the clean structure and organisation that a skilled developer can produce, but this is also not the point of automatically generated code. \\

TAPS comply with a set of predefined structures that is used to transform the specific program into a specific solution, using general structures. Because the generated code is generated using these standard structures the resulting source code will often become large and awkward. This is one of the disadvantages of automatically generated code. However, these standard structures are also why auto-generated code is perfect for translating from SMEIL to \cspm{}. The work that lies in manually translating a hardware model to a specification model can be substantial. The code generated by TAPS will mostly be used by FDR4 to run refinement checks and therefore it is not important how complex or inefficient the code structure is. \\

In this chapter, we describe the main design decisions included in creating TAPS and address the challenges that lie in translating SMEIL to \cspm{}.
\section{Translating Processes}
In order to translate an SMEIL process into a \cspm{} process it was necessary to create a general process structure in \cspm{}. The SME model enforces that each process reads, execute, and writes, in that order, for each clock cycle, so the \cspm{} structure must support this. To reduce complexity it is preferable to have one \cspm{} process per SMEIL process since it would simplify the translation. A simpler solution typically results in a less erroneous solution.\\

What first comes to mind in \cspm{} when a process must read and then write, is a very simple process structure using prefix and communication operators.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Proc = c ? x -> d ! x-> SKIP
\end{minted}
This is one of the simplest \cspm{} processes that match the SME model, however with this structure it is not simple to include all the possible calculations that SMEIL support. In \cspm{} it is not easy to add larger computations in prefixing and therefore it was necessary to find another solution. By using the \texttt{let within} structure in \cspm{} it is possible to keep the communication together with the computations in one \cspm{} process while keeping a simple structure. All computations are performed inside the \texttt{let} clause which can be referenced to inside the \texttt{within} clause where each write is performed.
In Listing~\ref{lst:cspm_let_within_example}, an example of the \texttt{let within} structure can be seen. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes. Since I know that all reads and calculations must be done before writing, this structure should always work for a well-structured SMEIL process.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..100}

P(input) =
    let
        x = input * 5
        y = input * 10
    within
        c ! x -> c ! y -> SKIP
\end{minted}
\caption{Example of the \texttt{let within} structure used to create the process structure within \cspm{}.}
\label{lst:cspm_let_within_example}
\end{listing}
\section{Translating Data Generation}
It is important to make sure that TAPS can translate all the different methods of generating data in SMEIL and it is therefore essential that TAPS can recognise a data generator process in SMEIL. As previously explained, a data generator process in SMEIL does not read any input value, no matter if it is through a process parameter or by using the channels hierarchical name. Therefore TAPS can look through the parameters and process body and if there is no input bus or if the process does not contain input communication, then TAPS will assume the process is a data generator process. In \cspm{} it is possible to create a process with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to synchronise the data generator process with all the processes reading the data. Otherwise, FDR4 would evaluate all values in the defined range of the channel instead of what was actually communicated on the channel. This would make the data generator process obsolete. This extra synchronisation and process added to the \cspm{} network will increase the complexity, and it might also increase the runtime of the verification.
\begin{figure}
    \centering
    \begin{tikzpicture}
       \node[main node] (1) {\small \texttt{data}};
       \node[main node] (2) [right = 4cm of 1] {\texttt{calc}};
       \draw[fill] (0.7,0) circle [radius=0.07];

       \path[draw,thick, ->]
       (1) edge node {} (2);

       \node[align=center, below, text width=1.7cm] at (3.27,0.83){\footnotesize\texttt{channel c : \{0..100\}}};
       \node[align=center, below, text width=1.7cm] at (1.3,0){\footnotesize\texttt{output o : \{0..10\}}};
   \end{tikzpicture}
    \caption{A \cspm{} network with two processes. The output \texttt{o} of the process \texttt{data} is within the range 0 through 10, and the channel \texttt{c} is defined for the range 0 through 100.}
    \label{fig:csp_data_generator_process}
\end{figure}
A figure to visualise this concept can be seen in Figure \ref{fig:csp_data_generator_process}. The channel \texttt{c} between the \texttt{data} process and the \texttt{calc} process is defined for the range \texttt{\{0..100\}}. If the two processes are not synchronised on this channel, the two processes do not have to agree on communication and therefore the search space for FDR4 includes all the values from 0 through 100, even though the \texttt{data} process only outputs 0 through 10. If the processes are not synchronised on the channel, the result would be the same as if the \texttt{calc} process did not exist. However, if the processes are synchronised, FDR4 will still allocate all 100 possible reads and writes, but it only continues the search on the values actually communicated on the channel.
Adding a data generator process and the extra synchronisation, the data generated for the network could be made more complex which, in some cases, could be an advantage. However, the current goals are to verify that the hardware model handles all communicated data as expected. Therefore, for this kind of verification, it is necessary to have FDR4 search a larger value space to find potential problems. It is important to find a balance between verifying input values outside of the expected range space and verification runtime. The larger the state space in FDR4, the longer the verification time.

To summarise, when generating data in \cspm{} from a SMEIL data generator process, the two possibilities are either to define the data in \cspm by one or more input channels or by a data generator process and synchronisation.
Currently TAPS only support generating an input channel from the SMEIL network, but translating the SMEIL data generator process to a \cspm{} data generator process would be the same as translating other SMEIL processes to \cspm{}.\\

Listing \ref{lst:clock_data_generation_example_cspm} shows the translated code of the SMEIL network in Listing \ref{lst:clock_data_generation_example_smeil}. Here it can be seen that the \texttt{clock} process from the SMEIL network, is translated into an input channel \texttt{clock} in \cspm{}. The translation of the range values defined for each channel is described later in this section.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel clock : {0..100}
channel minutes_output_val : {0..1}

Minutes(input) =
let
    from_clock = input / 60
within
    minutes_output_val ! from_clock ->
    SKIP

\end{minted}
\caption{Example of the translated \texttt{Minutes} process defined in Listing \ref{lst:clock_data_generation_example_smeil}.}
\label{lst:clock_data_generation_example_cspm}
\end{listing}
In the case where the SMEIL network does not have a data generator process but are instantiated with constants as parameters or internal values, the \cspm{} processes would also be instantiated with these values as parameters.

If there are several data generation processes in the SMEIL program, TAPS will not handle the processes differently than if there were one data generator process. Each data generator process will be translated into a \cspm channel, and the communication to the rest of the network will still be kept intact because of the communication specified in the SMEIL network structure.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: The problem is that in the unclocked version there are two ways of defining the read. Either the network reads and the process gets the value as a parameter or the process reads itself.
% The advantage of the network reading is that I avoid having to transform the data a lot. I can simply use the name from the parameter. However, since I am already transforming the data, I should be able to find the data that gives what channel name that is. The disadvantage of the network reading is that in other problems it might not work well in that way. Maybe the network suddenly have to read a bunch of times because all different processes have to read different channels. It works for the seven segment example but not necessarily for others.
% The advantage of the process reading itself, it that we get a cleaner structure and separation of concerns. The reading does not really belong with the network but within the process. However, as mentioned above, the problem is that I have to transform the data more. But in the clocked version, I would have to do that no matter what.

% It would be possible to introduce both solutions and then discuss why I chose the other one. Or if I decide to only write about the new version of the system I can write something about why the reading was done differently in the paper than in the report.

% The second problem is if I should even write about the "first" version at all. Even though I havent implemented it yet, a lot of the things can be reused in the code and even more so, in the report. A lot of the stuff that I have written about the "first version" is also applicable for this new version and I would be able to reuse this text. It will also cut down the length of the report if I dont have to write a lot about it. And I would be able to write a lot before I start implementing, because the design process is not necessarily implementation, so I can design it and then implement it.
% On the other hand it seems weird to have written a paper about it, and then do something completely different in the report. However, it is not all of it that is changed, and it is all a process. I would be able to write in the report that I have published a paper which represents an early version of the system (and the advantage of that version is that i did not have to transform the data a lot) and that I since then have updated it to be able to do clock cycles and therefore I am writing about this, but that a lot of the basics in the paper are the same as in this version. It would also shorten the length of the report emensely.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Translating Buses and Channels}
As have already been introduced, the SMEIL bus channel and the \cspm{} channel are equivalent and can therefore be translated almost directly. However, when the bus is defined as a process parameter within the SMEIL process, the translation becomes more complex, because the parameter name, used inside the process, is a placeholder for the formal bus channel name. It is therefore not possible to translate the channel without either knowing the formal name of the bus channel or changing the structure of the SMEIL process.
When translating the SMEIL process to \cspm{} it is important to design a well-formed structure to handle these processes parameters.\\

If a process contains an input bus parameter, there are several different methods for translating this input bus parameter to \cspm{}, each with its own advantages and disadvantages.
In Listing \ref{lst:cspm_input_values_examples} there are three \cspm{} examples of how to translate an SMEIL input bus into an input for a \cspm{} process.\\

\begin{minipage}[t]{.98\linewidth}
    \centering
\begin{minipage}[t]{0.45\linewidth}
  \begin{minted}{smeil_lexer.py:SMEILLexer -x}
proc a (in input)
    bus abus {
        val: uint;};
{
    abus.val = input.val + 1;
}
  \end{minted}
  \captionof{listing}{An SMEIL process with an input bus as parameter.}
  \label{lst:smeil_input_parameter}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}

A(input_val) =
    let
        result = input_val + 1
    within
        a_abus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input value as parameter.}
\label{lst:cspm_input_value}
\end{minipage}
\hspace{0.6cm}
\vspace{0.5cm}
\newline
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
A() =
    b_bbus_val ? value ->
    let
        result = value + 1
    within
        a_abus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with no input parameter.}
\label{lst:cspm_no_input}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
A(input_bus_channel) =
input_bus_channel ? value ->
    let
      result = value + 1
    within
      a_abus_val ! result ->
      SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input channel as parameter.}
\label{lst:cspm_channel_reads_input}
\end{minipage}
\vspace{0.3cm}
\captionof{listing}{Three different methods of translating the input bus in an SMEIL process to a \cspm{} process input.}
\label{lst:cspm_input_values_examples}
\vspace{1cm}
\end{minipage}

Listing \ref{lst:smeil_input_parameter} shows a simple SMEIL process which takes an input bus as parameter. The three other examples in Listing \ref{lst:cspm_input_values_examples} shows different translations.

In Listing \ref{lst:cspm_input_value} the value itself is the parameter which means that the value can be used directly inside the \texttt{let} clause.
This translation results in a simpler translation process within TAPS because all the information needed to translate lies within the SMEIL process itself. However, using this structure the channel read must happen outside of the process, which does not match the original SME model structure. \\

The \cspm{} process in Listing \ref{lst:cspm_no_input} does not have an input parameter. The input parameter from the SMEIL process has been translated directly to its formal channel name corresponding to the bus channel input seen in Listing \ref{lst:smeil_input_parameter}. This solution fits within the original SME model structure because the process itself reads a value before computing and writing, opposite to the solution in Listing \ref{lst:cspm_input_value}. Translating the channel name directly leads to a more complex translation and TAPS must search the SMEIL network to find the formal channel name. Another downside with this translation is that it eliminates the reusability of the process. The generated code can become unnecessarily complex because similar processes must be defined several times instead of reusing the process and declaring it with different parameters in the network.\\

In Listing \ref{lst:cspm_channel_reads_input} the channel name is given as input parameter to the \cspm{} process. This translation is the best match to the original SMEIL process structure. The channel name is provided as a parameter, so the process reads the value itself, which means that the process can be reused as opposed to the solution in Listing \ref{lst:cspm_no_input}. This solution also has the advantage that TAPS does not have to search for information in the SMEIL network to translate the process.
The downside to this solution is that the internal structure of the process must be changed during the translation. In the original SMEIL program in Listing \ref{lst:smeil_input_parameter} the \texttt{input} value is declared in the process parameter and used directly in the process body. In this solution, TAPS would have to change one of these and put in an intermediate step where the process read a value and then use the value in the process body. The process in Listing \ref{lst:cspm_channel_reads_input} is implemented with this intermediate step.\\

Out of these three solutions, it is clear that even though the solution in Listing \ref{lst:cspm_no_input} are the simplest version, the translation would become too complex, which is a big disadvantage. In order to create the simplest solution possible, I decided to use the solution in Listing \ref{lst:cspm_input_value}. Even though it does not exactly match the SME model it will not be a problem, since the read is performed in close relation to the process. This will be explained in Section \ref{sec:design_translating_network}. Using this solution results in a simpler translation for each process and thus most of the translations can be performed swiftly without needing much information about the rest of the system. Only the network translation becomes slightly more complex.\\

If the SMEIL process contains an output bus parameter, the translation does not become as complex. The process must always write the value itself and therefore the method for translating the output bus parameter into \cspm{} is similar to the translation in Listing \ref{lst:cspm_channel_reads_input} where the process receives the bus name as parameter. However, when using this method with output bus parameters, the process structure can be translated directly, thus providing a less complex translation.\\

In the case where the process does not have any parameters but are communicating via the bus channels hierarchical names, this problem will not occur. TAPS will be able to translate the processes directly because the actual name of the bus channel is defined within the process itself.

\section{Verification in \cspm{}}
In order to create the assertions for the refinement checking, TAPS will create separate assert functions to keep the code structure clean. It would have been possible to include the assertions within the processes, but it is important to keep separations of concerns and therefore I decided to add this extra assertion process. This will increase the complexity of the generated \cspm{} network, but it will be a minor difference and it is still preferable to more complex process structures. For each \cspm{} channel there must be an assertion, except for data generator channels. Consequently, TAPS create a \textit{monitor} process for each channel. This monitor process will listen in on the channel communication and assert the values communicated there. The monitor process is a process that is added specifically for asserting legal communication values in FDR4 and it does not affect the original SME network. The monitor process checks the values communicated on the channel and if all values are within the expected range, the process behaves as the \texttt{SKIP} process to indicate successful termination. If all values are not within the expected range, the monitor process behaves as the \texttt{STOP} process to indicate failure. \\

For security and simplicity reasons, all channels, except data generator channels, are always verified. If only a subset of channels are verified the verification might not catch all potential failures.\\

In Figure~\ref{fig:assertion_process} the outline of the monitor process structure can be seen. I expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

For FDR4 to actually perform any refinement checking, an assertion must be added to the \cspm{} program by using the \texttt{assert} keyword.
To assert that the entire network terminates successfully the \texttt{SKIP} process is used as the specification process and the network as the implementation process to verify. An example of this can be seen below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
assert SKIP [F= Network \ Events
\end{minted}
By hiding all events, the events become internal events which still complies with the rules and structures of the network, but the refinement check does not include them. This also means that the refinement check is between \texttt{SKIP} and the resulting process of the network. In this case, if the network behaves like the \texttt{SKIP} process it terminated successfully and the refinement check passes.\\

The assertion uses the \textit{failures} model described in Chapter \ref{chap:background} since it is not possible to use the \textit{traces} model in this case. The reason the \textit{traces} model cannot be used is because \texttt{SKIP} is defined as $\tick \then \STOP$. Failures within the network are defined using \texttt{STOP}, so a failure in the network would also be accepted when using the \textit{traces} model because the traces of \texttt{STOP} and $\tick \then \STOP$ are the same. By using the \textit{failures} model, the refinement check fails if a monitor process does not terminate successfully. The failures of a \texttt{SKIP} process includes $\tick$, which is not included in the failures of the \texttt{STOP} process. Therefore, even though their traces are equal, the failures are not, thus providing the result needed for the verifications.
\section{Translating Network}
\label{sec:design_translating_network}
When translating a network in SMEIL to \cspm{} it is crucial that the composition of the network are kept intact. As much as the network is a crucial part of the SMEIl program it is also one of the most tricky structures to translate correctly. A generated network can quickly become very complex which can make it harder to ensure correct translation. \\

An SMEIL network is separated into instances that each instantiates a single process and parameters. As mentioned in Chapter \ref{chap:analysis} the closest equivalence to the SMEIL network in \cspm{}, are the parallel operators. To create a similar network in \cspm{} TAPS will synchronise the two processes with the channels they are communicating on.
This is the only way in \cspm{} to enforce synchronised communication on channels, which is an essential part of the synchronised network in SMEIL. An example of a simple network in \cspm{} can be seen in Listing \ref{lst:general_parallel_operator} where the process \texttt{A} are synchronised with the process \texttt{B} over the channel \texttt{c}.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}

A = c ! 42 -> SKIP
B = c ? x -> SKIP

Network = A [|{| c |}|] B
\end{minted}
\caption{Example of synchronisation using the generalised parallel operator.}
\label{lst:general_parallel_operator}
\end{listing}
This example uses the generalised parallel operator because both processes communicate only on the channel \texttt{c}.

Two processes that must synchronise on the same channels but also must communicate on other channels can be synchronised using the alphabetised parallel operator. An example can be seen in Listing \ref{lst:alphabetised_parallel_operator} where process \texttt{A} communicates both on channel \texttt{c} and \texttt{d}. Process \texttt{B} does not communicate on channel \texttt{d} and therefore if the generalised parallel operator was used in this case then process \texttt{B} would also have to agree on communication on channel \texttt{d}. In this example, the alphabetised parallel operator expresses that process \texttt{A} is allowed to perform events from the set on the left-hand side of the operator, which contains both channel \texttt{c} and \texttt{d}, and process \texttt{B} is only allowed to perform events on channel \texttt{c}, defined on the right-hand side.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}
channel d : {0..100}

A = c ! 4 -> d ! 50 SKIP
B = c ? x -> SKIP

Network = A [{| c, d |} || {| c |}] B
\end{minted}
\caption{Example of synchronisation using the alphabetised parallel operator.}
\label{lst:alphabetised_parallel_operator}
\end{listing}


The challenge, when translating the network from SMEIL to \cspm{}, is to ensure that all processes are connected with the other processes on the correct channels.
Since it is only possible to synchronise two processes at a time in \cspm{} it is a challenge to generate an entire network. The synchronisation of two processes becomes a new process which can then be synchronised with another process. This will quickly result in a lot of nested synchronisations, one for each process in the network. This quickly becomes very complex. It is an advantage that the \cspm{} networks are automatically generated, since, even smaller networks quickly become too large for easy hand translation.\\

Not only is it important that the network is generated to be equivalent to the original SMEIL network, but the monitor processes generated for each of the \cspm{} processes must also be included in the network. Since the monitor processes are only listening in on one specific channel, TAPS start out by synchronising the monitor together with the process by using the generalised parallel operator on the channel. The monitor process is synchronised with the writing process since a potential erroneous value will emerge at the write end of the channel. Since the monitor process can currently only assert one channel for each monitor the synchronisation is simple but crucial to the assertions in FDR4.\\

If there are several output channels from a process the synchronisation of the monitor processes will be nested together. A structure like this can be seen in the example below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_A_monitor_network = (A [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
As mentioned above, if the SMEIL process contains an input parameter the value must be read of the process itself. This is also included in this process monitor network before the processes are synchronised. This can be seen in the example below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_A_monitor_network =
    channel ? x -> (A(x) [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
This design ensures that the monitor processes are included correctly in the network and also that each read for the processes is defined without too much complexity. This process monitor network can be considered a shell around process \texttt{A} since it is only containing process relevant information. Because of the structure of this process monitor network, TAPS is able to use this as a single process that reads and writes to other processes. After this small network has been generated, it can be synchronised with other similar networks that share communication.

As mentioned in Chapter \ref{chap:analysis}, it is possible to instantiate one SMEIL process several times within the SMEIL network. Since TAPS is creating the network in \cspm{} by synchronising processes on channels, it can synchronise the same process several times with different channels or parameters, creating the same functionality as the instances declaration in SMEIL.\\

