%!TEX root = ../main.tex
% Description of the actual solutions
% TODO: Write something here
The goal of automatic translation is to be able to create a general solution which can fit different types of problems and therefore it is necessary to generalise the different aspects of the translation and find a solution that fits all.
\section{Designing TAPS}
% TODO: Reference meeting with Brian 26/9-2018 around 6:00-8:00. Talk in general about how the design of the entire system is.

In this section we describe all the design decisions included in creating TAPS and address all the challenges of the translation between SMEIL and \cspm{}. The section is divided in a similar way as Chapter \ref{chap:analysis}.
\subsection{Behavioral}
%% - Behavioral description - hvad den enkelte funktion gør. det oversættes ret nemt. Jeg bekymre mig ikke om variable og sådan nogle ting. Det er allerede gjort før det gøres til SMEIL, og dem kan jeg genbruge i min code generation.  Funktionel indhold af processer/ opførsel af den enkelte process - det er rimelig nemt oversat direkte til CSPm. Her kan man beskrive hvis der er nogle sproglige udfordringer, fx hvis CSPm ikke har loops eller lign.

\subsubsection{Translating Processes}
In order to translate the SMEIL process to a \cspm{} process we had to create a general process structure in \cspm{}. We know that the SME model enforce that each process reads, computes and writes, in that order, for each clock cycle, so we needed to create a \cspm{} structure that could support this. First of all we wished to have one \cspm{} process per SMEIL process, since it would simplify the translation and a simpler solution typically results in a less errornous solution.

What first comes to mind in \cspm{} when we want to read and then write, is a very simple process structure using prefix and communication operators.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Proc(x) = c ? x -> d ! x-> SKIP
\end{minted}
This is the simplest \cspm{} process that match the SME model, however with this structure it is not possible to include all the possible calculations that SMEIL support. It turned out that the tricky part of translating a general SMEIL process to \cspm{} was to be able to include the calculations properly.

By using the \texttt{let within} structure in \cspm{} we are able to keep the communication together with the arithmetics in one \cspm{} process while keeping a simple structure. The \cspm{} process does not do the actual read, but instead received the value as a parameter, then all arithmetics are performed inside the \texttt{let} clause while the writing will be put in the \texttt{within} clause.
In Listing~\ref{lst:cspm_let_within_example}, an example of the \texttt{let within} structure can be seen. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes. Since we know that all reads and calculations must be done before writing, this structure should always work for a well-structured SMEIL process.

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel c : {0..100}

P(input) =
let
    x = input * 5
    y = input * 10
within
    c ! x -> c ! y -> SKIP
\end{minted}
\caption{Example of the \texttt{let within} structure used to create the proper structure within the \cspm{} processes.}
\label{lst:cspm_let_within_example}
\end{listing}

Since \cspm{} does not need to declare variables beforehand, we can ignore the variable declarations in the SMEIL process and translate all the arithmetic statements, with the variables, directly.

% Constants are simply defined in the \cspm program, seperate from the process. Since the SMEIL programs must be well-formed, we know that only the processes that define the constant will use it, and therefore it is not a problem that
% NOTE Constants are currently not implemented in TAPS
% TODO: How to handle variables with predefined values

The types and ranges of variables are not translated, and unless we need the information for verification, it is completely ignored. We can only do this because we know the SMEIL program must be well-formed and since the variables are not used for verification, it does not matter what types and values the SMEIL program expects of these.

All assignments are translated directly into \cspm{} without much change, however if the assignment is to or from a bus, TAPS have to differentiate and handle these assignments differently, which will be explained later in this section.

If-satements are translated into the \cspm{} version of an if-statement, which is very similar to the SMEIL version. However, since \cspm{} does not support \texttt{elif}, the \cspm{} if-statements can be nested to form these expressions. This quickly becomes very complex and hard to read, but since it is auto generated, it is not a problem to create.
% NOTE: If-statements are currently not implemented in TAPS


Traces and assertions are, as explained in Chapter \ref{chap:analysis} not useful in the \cspm{} program and therefore we either throw them away or keep them as comments for the sake of understanding the generated code. Currently TAPS throw them away, but it would be a simple task to change this and add them as comments in the generated \cspm{} code.
% NOTE: Assertions are not curently implemented in TAPS. Trace is.

Most expressions of SMEIL can be directly translated, like \texttt{+}, \texttt{-}, \texttt{/} and \texttt{\%} etc. however there are a few differences in the presendence. The unary \texttt{not} operator does not have the same presedence in the SMEIL as in \cspm{}. This means that the programmer needs to be aware of this, and include parentheses when using the operator to ensure the correct translation. The programmar also needs to be aware of the fact that in \cspm{} the equality comparison operators and comparison operators have the same presedence, but they are seperated in the SMEIL grammar.
Bitwise operations does not exist in \cspm{}, so these would have to be transformed to standard arithmetics. % TODO: This is currently not implemented.
% TODO: Write more about how this could be done.
% TODO: Write more when I have more implemented for the processes (like arrays and stuff)

\subsubsection{Translating Data Generation}
%%% Generator processes
It is important to make sure that TAPS can translate all the different ways of data generation. The first problem is to recognise the data generator process in SMEIL. We know that a data generator process in SMEIL does not read any input value, no matter if it is through a process parameter or by using the channels hierarchical name. Therefore TAPS can look through the process body and if the process does not contain input communication, then it will assume that the process it a data generator process. \\

In \cspm it is necessary to define the space of data that FDR4 search through when running the refinement checking. It this space becomes unecessarily large, the runtime of the verification will also become unecessarily long, and therefore it is important to be carefull when defining the space of input values for the generated system.

It is possible to create a process in \cspm with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to syncronise the data process with all the processes receiving the data. Otherwise FDR4 would evaluate all values within the defined range of the channel instead of what was actually communicated on the channel, making the data generator process obsolete. This extra syncronisation will increase the complexity of the \cspm{} network, and it might also increase the runtime of the verification since the \cspm{} network would include more states.

\begin{figure}
    \centering
    \begin{tikzpicture}
       \node[main node] (1) {\small \texttt{data}};
       \node[main node] (2) [right = 4cm of 1] {\texttt{calc}};
       \draw[fill] (0.7,0) circle [radius=0.07];

       \path[draw,thick, ->]
       (1) edge node {} (2);

       \node[align=center, below, text width=1.7cm] at (3.27,0.83){\footnotesize\texttt{channel c : \{0..100\}}};
       \node[align=center, below, text width=1.7cm] at (1.3,0){\footnotesize\texttt{output o : \{0..10\}}};
   \end{tikzpicture}
    \caption{A \cspm{} network with two processes. The output \texttt{o} of the process \texttt{data} is within the range 0 through 10, and the channel \texttt{c} is defined for the range 0 through 100.}
    \label{fig:csp_data_generator_process}
\end{figure}
A figure of this concept can be seen in Figure \ref{fig:csp_data_generator_process}. Here, the channel \texttt{c} between the \texttt{data} process and the \texttt{calc} process is defined for range of \texttt{\{0..100\}}. If the two processes are not syncronised on this channel, the two processes do not have to agree on communication and therefore the search space for FDR4 includes all the values from 0 through 100. This means that if we just have the channel \texttt{c} as an input channel for the process \texttt{calc}, without a process writing to the channel, we get the same result because the processes are not syncronised on the channel.
However, if the processes are syncronised, FDR4 will still allocate all 100 posibilities, but it only continues the search on the values actually communicated on the channel. In this case, the only values FDR4 would actually continue searching will be from 0 through 10.
When adding a data generator process as well as syncronisation, the data generator process would be able to define specific data for the search space and that might prove to be an advantage when interested in more complex data. However, we are interested in verifying that the hardware circuits also can handle data outside of the expected range of input. Therefore, for this kind of verification, it is an advantage that FDR4 will search a larger space. However, it is important to find a balance between verifying input values outside of the expected range space, and verification runtime.

To summarise, when generating data in \cspm{} from a SMEIL data generator process, the two possibilities are either to define the data in \cspm by a single channel or by a data generator process and syncronisation, just like in SMEIL.
Currently TAPS only support generating an input channel from the SMEIL network.
% NOTE: Only one type of data generator process are supported right now - having the input as a input parameter
Listing \ref{lst:clock_data_generation_example_cspm} is the translated version of the SMEIL network from Listing \ref{lst:clock_data_generation_example_smeil}. Here it can be seen that the \texttt{clock} process from the SMEIL network, is translated into a channel in \cspm{}
The translation of the range values defined for each channel are described later in this section.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel clock : ...
channel minutes_output_val : ...

Minutes(input) =
let
    from_clock = input / 60
within
    output_val ! from_clock ->
    SKIP

\end{minted}
\caption{Example of the translated \texttt{Minutes} process defined in Listing \ref{lst:clock_data_generation_example_cspm}.}
\label{lst:channel_range_cspm}
\end{listing}
% TODO: Not sure if this example makes sense here, since we have not introduced the network generation yet and therefore there is no connection between the channel \texttt{clock} and the input in the process.

In the case where the SMEIL network does not have a data generator process but are instantiated with constants or internal values, the \cspm processes would also have to be instantiated with the values as parameters. This means that the the \cspm{} network would not contain an input channel, but that the processes that are instantiated with a constant or internal value, must be translated to contain this information as well.
% TODO: Maybe add a short two column example of the parameter variables here
If the SMEIL process are defined with an internal value, the \cspm{} process must also be defined with this initial value. This is a bit more tricky since we usually ignore the value declarations, but since the value are defined with a specific value, we have to include this in the process.
% TODO: Figure out what happens when a value is instantiated within the SMEIL process. and then continue writing this.


% TODO: The Addone example does not make much sense to show here, since it does not work for the non-clocked system. I could talk about how a programmer might just add a data generation process. But this does not really make sense since i have a solution (clocked version) which I will explain later in the report.


%% Generator processes - More than one process
If there are several data generation processes in the SMEIL program, TAPS will not handle the processes different than if there were one data generator process. The processes will be translated into a \cspm channels for each data generator process, and the comunication to the rest of the network will still be kept intact since all the communication are specified by the SMEIL network structure.


% (moved from analysis: )
%  % None of these two posssible usecases are currently implemented in TAPS, and thus the keyword \texttt{exposed} will cause an error in the transpiler. %TODO: Will it cause an error? And should I add more info to this?
%
\subsection{Structural}
% - Strukturel information: hvilke proceser er der og hvilke buser er de limet sammen med. hvordan hænger tingene sammen. Det er også forholdsvis nemt fordi FDR har processer på samme måde som SMEIL har. de har en historisk afhængighed ift. SME og CSP.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: The problem is that in the unclocked version there are two ways of defining the read. Either the network reads and the process gets the value as a parameter or the process reads itself.
% The advantage of the network reading is that I avoid having to transform the data a lot. I can simply use the name from the parameter. However, since I am already transforming the data, I should be able to find the data that gives what channel name that is. The disadvantage of the network reading is that in other problems it might not work well in that way. Maybe the network suddenly have to read a bunch of times because all different processes have to read different channels. It works for the seven segment example but not necessarily for others.
% The advantage of the process reading itself, it that we get a cleaner structure and seperation of concerns. The reading does not really belong with the network but within the process. However, as mentioned above, the problem is that I have to transform the data more. But in the clocked version, I would have to do that no matter what.

% It would be possible to introduce both solutions and then discuss why I chose the other one. Or if I decide to only write about the new version of the system I can write something about why the reading was done differently in the paper than in the report.

% The second problem is if I should even write about the "first" version at all. Even though I havent implemented it yet, a lot of the things can be reused in the code and even more so, in the report. A lot of the stuff that I have written about the "first version" is also applicable for this new version and I would be able to reuse this text. It will also cut down the length of the report if I dont have to write a lot about it. And I would be able to write a lot before I start implementing, because the design process is not necessarily implementation, so I can design it and then implement it.
% On the other hand it seems weird to have written a paper about it, and then do something completely different in the report. However, it is not all of it that is changed, and it is all a process. I would be able to write in the report that I have published a paper which represents an early version of the system (and the advantage of that version is that i did not have to transform the data a lot) and that I since then have updated it to be able to do clock cycles and therefore I am writing about this, but that a lot of the basics in the paper are the same as in this version. It would also shorten the length of the report emensely.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Translating Network}
In SMEIL, the network is consisting of instances which are instantiating processes while also defining the communication of the network. As mentioned in Chapter \ref{chap:analysis} the equivalence to this in \cspm{} are the parallel operators. To create a similar network in \cspm{} TAPS will synchronise the processes together with the channels they are communicating on.
This is the only way in \cspm{} to enforce communication on channels which is the essential part of the network in SMEIL.

An example of a simple network in \cspm{} can be seen below where the process \texttt{A} are synchronised with the process \texttt{B} over the channel \texttt{c}.
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}

A = c ! 42 -> SKIP
B = c ? x -> SKIP

Network = A [| {| c |} |] B
\end{minted}
This example use the generalised parallel operator, since both processes only communicate on the channel \texttt{c}.
Since it is only possible to synchronise two processes at a time in \cspm{} it is a challenge to generate entire network. The syncronisation of two processes becomes a new process which can then be synchronised with another process. This will continue for every process in the network and therefore, quickly become very complex. It is an advantage that the \cspm{} networks are generated, since it quickly becomes too large for easy hand translation, even for smaller examples. With this method of translating the SMEIL networks, it is a challenge to ensure that all processes connect with the other processes on the correct channels.

As mentioned in Chapter \ref{chap:analysis}, it is possible to instantiate one SMEIL process several times within the SMEIL network. Since TAPS is creating the network in \cspm{} by synchronising processes with each other via channels, it can synchronise the same process several times with different channels or parameters, creating the same functionality as the instances in SMEIL.\\

% %%%% Generating the network
We can standardise the network generation by creating a two-step communication part. Instead of having the actual processes read the incoming data, they receive the data by their process parameter, as mentioned above. The network reads the communication from the channels and provides the process with the communicated value as a process parameter. The reason for this design decision is that we wish to be able to translate the processes directly. By using this structure TAPS do not need any other information from the rest of the program, to generate the translated \cspm{} processes.


% TODO: Figure out if this entire subsubsection actually belongs in implementation
\subsubsection{Translating Buses and Channels}
We know that SMEIL defines all channels within buses and that \cspm{} is only channel based. Fortunately the buses in SMEIL is a shell, containing the channel definitions and an idenfifier. This means that TAPS can translate all SMEIL bus channels into a corresponding \cspm{} channel rather easily.\\

When generating the channels in \cspm{}, it is necessary to define its range of possible values. If a channel is only defined by having the integer type, FDR4 would try to verify for all possible integers, which results in a seemingly unbounded runtime. As explained in Chapter~\ref{chap:analysis}, all simulated SMEIL programs will include the observed range and restricted types for all channels and variables. The types represent the observed width of the channels in bits, and by calculating the possible range from these types, we can create the corresponding channels in \cspm{}, and thereby avoid having a seemingly endless runtime in FDR4.\\

Since the assertion we wish to make is to verify the widths of the channels, it might seem redundant to create \cspm{} channels with a limited range. FDR4 would always only check the values in the defined channel range and therefore there is no point in asserting if the values go beyond this range. After simulating the SME network, SMEIL provides us with both a type and a range of observed values. The type is used to create the \cspm{} channel range and the observed values are used for the assertion. The type will always represent equal or more values than the range of observed values, and by using these values the assertions becomes valuable.
\\

When it comes to transpiling the data generator process into a \cspm{} channel, we also use the types of the SMEIL simulation to define it. We use this instead of the observed values because we cannot guarantee the precise input values of the system. If we used the observed values, the assertions will pass every time, since it will test the values already used to generate the rest of the observed values.

% Because there are several different ways to define a bus in SMEIL %TODO: see the analysis chapter,
% the translation will have to recognize the different types and generate the \cspm channels no matter how they where defined.
%

% TODO: What if I need to translate a bus with letters, or something else? what kind of channel does that become?


% % Buses
% TODO: Maybe this belongs in the implementation part? I dont really feel like this is a design choice as much as an implementation choice.
As explained above, the input for the \cspm{} processes is the value read from the input channel which is included as a parameter of the process.
In SMEIL when a process is reading from a bus channel, it is referencing the bus and channelname within the normal expression. Since the bus parameters for a SMEIL process is the bus name, the process itself must reference the specific channel within the bus. This is applied whether it is reads or writes.
An example of this can be seen below, where \texttt{input.val} are the bus \texttt{input} and the channel \texttt{val} within that bus. SMEIl does not seperate communication and calculation in the process statements which is of great advantage in SMEIL, but the translation becomes more difficult since TAPS have to be able to recognise the communication.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
    proc A (in input)
        bus a_bus {
            val: uint;
        }
    {
        a_bus.val = input.val + 1;
    }
\end{minted}

This means that TAPS can recognise communication by the structure of the assignment. If one of the elements in an assignment, right or left, contains a dot, then we can assume that this is communication. The original grammar of an assignment like the one seen above can be seen in Listing \ref{lst:smeil_assignment_grammar}. Here is it clear that a communication is the \textit{hierarchical accessor} alternative in the \textit{statement} grammar. The communication can either be the right hand side of the assignment, which is a write, or part of the left hand side expression, which then will be a read. A write is simple to recognise, since it is not combined with other parts of the grammar. TAPS can search the \textit{name} of a right hand side assignment and see if it contains a dot. The read is a bit more complicated since it can be used like any internal variable in the expressions. This means that TAPS will have to search all names within the nested expression to find a potential read.
\begin{listing}
    \begin{grammar}
      <statement> ::= <name> `=' <expression> `;' (assignment)

      <name> ::= <ident>
  \alt <name> `.' <name> (hierarchical accessor)
  \alt <name> `[' <array-index> `]' (array element access)

  <expression> ::= <name>
  \alt <literal>
  \alt <expression> <bin-op> <expression>
  \alt <un-op> <expression>
  \alt <name> `(' \{ <expression> \}  `)' (function call)
  \alt `(' <expression> `)'


    \end{grammar}
    \caption{The original assignment, name and expression grammars defined in \cite{Asheim2018}.}
\end{listing}


\subsection{Meta and verification}
% - Opserverede værdier - "known limits". Meta information i SMEIL, og det skal oversættes til faktiske processer med faktiske semantic i FDR der også er en del af topologien. (Det er essensen for mig).

% %%%% Monitor processes %%%%%
In order to create the assertions for the refinement checking, I decided to create separate assert functions to keep the code structure clean. I know that for each \cspm{} channel there must be an assertion, except for input channels.
Consequently, we create a \textit{monitor} process for each channel and its only job is to listen in on the channel communication and assert the values communicated there. The monitor process is a process that we add specifically for asserting legal communication values in FDR4 and it does not affect the original SME network.

There might be a case where we are not interested in verifying all channels, but we add assertions to all channels, to simplify the code generation. If TAPS was to handle only including assertions on some channels, then there must be introduced a specific notation for which channels the assertions should be included. This is definitely possible, and might be relevant for future work, but adding this functionality might also have the consequence that some errors would not be caught, since the programmar would be responsible for asserting which channels was worth checking.

In Figure~\ref{fig:assertion_process} the outline of this kind of structure can be seen and we expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

The meta information that I am using to create the assertions on each channel are meta information in the SMEIL program. TAPS use the observed range of values for each channel to define the range of acceptable values in the assertions. TAPS then translates these values, not into meta data in \cspm{} but as an actual process with actual real semantics which is included as a part of the topology of the \cspm{} network.

% %%%% Monitor processes: monitor something else that ranges

------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\



\section{Clock cycle problem}
% \input{chapters/clock_cycle_problem}

CSP was not initially developed for hardware modeling, and therefore it is not evident how to handle the clock cycle, which is an essential part of hardware modeling. When we transpile the SME network into \cspm{}, the SMEIL simulation have provided the ranges of all values from the simulation and therefore all clock cycles. This means that when FDR4 asserts a property it asserts on all possible communication combinations for all the simulated clock cycles. Therefore, even though we are transpiling from an SME model, where the clock is crucial, we can simply translate ``one-to-one" from the SMEIL program and still get an accurate assertion on the properties.




% It is important to mention that the FDR version of the SMEIL program are represented as one clock cycle and therefore we do not have to handle implicit clock cycle issues. we can just translate one-to-one, because FDR models one clock cycle and the input represents all possible input in one clock cycle.



% TODO: Async vs. sync processes

%%% Generator processes - clock cycles
%TODO: Write something here?


% TODO: Write that the read of a process does not make sense in the network and that we move it to be internal inside the process.