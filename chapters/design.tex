%!TEX root = ../main.tex
The goal of automatic translation is to be able to create a general solution which can fit different types of problems and therefore it is necessary to generalise the different aspects of the translation and find a solution that fits all.\\
To achieve this I designed the system TAPS which is a transpiler from SMEIL to \cspm{}. A transpiler is a source to source compiler which takes some source code written in one language, in this case it is SMEIL and it translates it to equivalent source code in another language, in this case \cspm{}.\\

TAPS consists of two main parts, the parser and the code generator. TAPS does have some specific requirements for the SMEIL programs that the original SMEIL grammar does not. These requirement can be achieved either by simulating the networks or enrich the code manually. These requirements will be introduced further in this chapter.

An overview of the system can be seen in Figure \ref{fig:TAPS_network}. The generated \cspm{} code can be loaded into FDR4 which can provide refinement checks on the properties specified.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
    \node [mysquare] (SME) at (0, 2.5) {$SME$};
    \node [mysquare] (SMEIL) at (0, 0) {$SMEIL$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (Q) at (2.5, 1.3){$Questions$};
    \draw [myarrow, dashed] (SME) to[out=270, in=90] (SMEIL);
    \draw [myarrow, dotted] (Q) to[out=180, in=90] (SMEIL);


    \node [mysquare] (Parser) at (3, -1.3) {$Parser$};
    \node [mysquare] (Codegen) at (5.5, -1.3) {$Code Gen$};
    \node [draw, red, thick, dotted, fit=(Parser)(Codegen), inner sep=0.5cm] (TAPS) {};
    \node [red] at (4.4, -0.2) {$TAPS$};
    \draw [myarrow, smooth] (SMEIL) to[out=270, in=180] (Parser);
    \draw [myarrow, smooth] (Parser) to[out=0, in=180] (Codegen);

    \node [mysquare] (cspm) at (8.5, 0) {$CSP_M$};
    \draw [myarrow, smooth] (Codegen) to[out=0, in=270] (cspm);
    \node [mysquare] (FDR) at (8.5, 2.5) {$FDR4$};
    \node [draw, black, thick, rounded corners, dotted, inner sep=0.2cm] (A) at (5.5, 2.5){$Answers$};
    \draw [myarrow, smooth] (cspm) to[out=90, in=270] (FDR);
    \draw [myarrow, dotted] (FDR) to[out=180, in=0] (A);

  \end{tikzpicture}
  \caption{System structure.}
  \label{fig:TAPS_network}
\end{figure}

In this section we describe the main design decisions included in creating TAPS and address the challenges that lies in translating SMEIL to \cspm{}.
\section{Translating Processes}
In order to translate an SMEIL process to a \cspm{} process I had to create a general process structure in \cspm{}. I know that the SME model enforce that each process reads, execute, and writes, in that order, for each clock cycle, so I needed to create a \cspm{} structure that could support this. First of all I wanted to attempt to have one \cspm{} process per SMEIL process, since it would simplify the translation and a simpler solution typically results in a less errornous solution.

What first comes to mind in \cspm{} when a process must read and then write, is a very simple process structure using prefix and communication operators.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Proc = c ? x -> d ! x-> SKIP
\end{minted}
This is one of the simplest \cspm{} process that match the SME model, however with this structure it is not simple to include all the possible calculations that SMEIL support. It turned out that the tricky part of translating a general SMEIL process to \cspm{} was to be able to include the executions properly.

By using the \texttt{let within} structure in \cspm{} it is possible to keep the communication together with the arithmetics in one \cspm{} process while keeping a simple structure. All arithmetics are performed inside the \texttt{let} clause while the writing will be put in the \texttt{within} clause.
In Listing~\ref{lst:cspm_let_within_example}, an example of the \texttt{let within} structure can be seen. This structure will work as a general translation structure from SMEIL processes to \cspm{} processes. Since I know that all reads and calculations must be done before writing, this structure should always work for a well-structured SMEIL process.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..100}

P(input) =
    let
        x = input * 5
        y = input * 10
    within
        c ! x -> c ! y -> SKIP
\end{minted}
\caption{Example of the \texttt{let within} structure used to create the process structure within \cspm{}.}
\label{lst:cspm_let_within_example}
\end{listing}
\section{Translating Data Generation}
It is important to make sure that TAPS can translate all the different ways of data generation. The first problem is to recognise the data generator process in SMEIL. We know that a data generator process in SMEIL does not read any input value, no matter if it is through a process parameter or by using the channels hierarchical name. Therefore TAPS can look through the process body and if the process does not contain input communication, then it will assume that the process is a data generator process. \\

It is possible to create a process in \cspm with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to syncronise the data process with all the processes receiving the data. Otherwise FDR4 would evaluate all values within the defined range of the channel instead of what was actually communicated on the channel, making the data generator process obsolete. This extra syncronisation will increase the complexity of the \cspm{} network, and it might also increase the runtime of the verification since the \cspm{} network would include more states.

\begin{figure}
    \centering
    \begin{tikzpicture}
       \node[main node] (1) {\small \texttt{data}};
       \node[main node] (2) [right = 4cm of 1] {\texttt{calc}};
       \draw[fill] (0.7,0) circle [radius=0.07];

       \path[draw,thick, ->]
       (1) edge node {} (2);

       \node[align=center, below, text width=1.7cm] at (3.27,0.83){\footnotesize\texttt{channel c : \{0..100\}}};
       \node[align=center, below, text width=1.7cm] at (1.3,0){\footnotesize\texttt{output o : \{0..10\}}};
   \end{tikzpicture}
    \caption{A \cspm{} network with two processes. The output \texttt{o} of the process \texttt{data} is within the range 0 through 10, and the channel \texttt{c} is defined for the range 0 through 100.}
    \label{fig:csp_data_generator_process}
\end{figure}
A figure of this concept can be seen in Figure \ref{fig:csp_data_generator_process}. Here, the channel \texttt{c} between the \texttt{data} process and the \texttt{calc} process is defined for range of \texttt{\{0..100\}}. If the two processes are not syncronised on this channel, the two processes do not have to agree on communication and therefore the search space for FDR4 includes all the values from 0 through 100 but the\texttt{data} process only outputs 0 through 10. Becasue the processes are not synchronised on the channel, it would be the same results if the the input data for the \texttt{calc} channel was only the channel \texttt{c} without any process writing to it.
However, if the processes are syncronised, FDR4 will still allocate all 100 posibilities, but it only continues the search on the values actually communicated on the channel.
When adding a data generator process as well as syncronisation, the data generator process would be able to define more specific data for the network and that might prove to be an advantage when interested in more complex data. However, we are interested in verifying that the hardware model ensures that all communicated data are handled as expected. Therefore, for this kind of verification, it is an advantage that FDR4 will search a larger space than expected, to find potential problems. However, it is important to find a balance between verifying input values outside of the expected range space, and verification runtime.

To summarise, when generating data in \cspm{} from a SMEIL data generator process, the two possibilities are either to define the data in \cspm by one or more input channels or by a data generator process and syncronisation.
Currently TAPS only support generating an input channel from the SMEIL network.
% NOTE: Only one type of data generator process are supported right now - having the input as a input parameter
Listing \ref{lst:clock_data_generation_example_cspm} is the translated version of the SMEIL network from Listing \ref{lst:clock_data_generation_example_smeil}. Here it can be seen that the \texttt{clock} process from the SMEIL network, is translated into an input channel \texttt{clock} in \cspm{}.
The translation of the range values defined for each channel are described later in this section.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel clock : ...
channel minutes_output_val : ...

Minutes(input) =
let
    from_clock = input / 60
within
    output_val ! from_clock ->
    SKIP

\end{minted}
\caption{Example of the translated \texttt{Minutes} process defined in Listing \ref{lst:clock_data_generation_example_smeil}.}
\label{lst:clock_data_generation_example_cspm}
\end{listing}
In the case where the SMEIL network does not have a data generator process but are instantiated with constants or internal values, the \cspm processes would also have to be instantiated with these values as parameters. This means that the the \cspm{} network would not necessarily contain an input channel, but that the processes that are instantiated with a constant or internal value, must be translated to contain this information as well.

If there are several data generation processes in the SMEIL program, TAPS will not handle the processes different than if there were one data generator process. The processes will be translated into a \cspm channels for each data generator process, and the comunication to the rest of the network will still be kept intact since all the communication are specified by the SMEIL network structure.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: The problem is that in the unclocked version there are two ways of defining the read. Either the network reads and the process gets the value as a parameter or the process reads itself.
% The advantage of the network reading is that I avoid having to transform the data a lot. I can simply use the name from the parameter. However, since I am already transforming the data, I should be able to find the data that gives what channel name that is. The disadvantage of the network reading is that in other problems it might not work well in that way. Maybe the network suddenly have to read a bunch of times because all different processes have to read different channels. It works for the seven segment example but not necessarily for others.
% The advantage of the process reading itself, it that we get a cleaner structure and seperation of concerns. The reading does not really belong with the network but within the process. However, as mentioned above, the problem is that I have to transform the data more. But in the clocked version, I would have to do that no matter what.

% It would be possible to introduce both solutions and then discuss why I chose the other one. Or if I decide to only write about the new version of the system I can write something about why the reading was done differently in the paper than in the report.

% The second problem is if I should even write about the "first" version at all. Even though I havent implemented it yet, a lot of the things can be reused in the code and even more so, in the report. A lot of the stuff that I have written about the "first version" is also applicable for this new version and I would be able to reuse this text. It will also cut down the length of the report if I dont have to write a lot about it. And I would be able to write a lot before I start implementing, because the design process is not necessarily implementation, so I can design it and then implement it.
% On the other hand it seems weird to have written a paper about it, and then do something completely different in the report. However, it is not all of it that is changed, and it is all a process. I would be able to write in the report that I have published a paper which represents an early version of the system (and the advantage of that version is that i did not have to transform the data a lot) and that I since then have updated it to be able to do clock cycles and therefore I am writing about this, but that a lot of the basics in the paper are the same as in this version. It would also shorten the length of the report emensely.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Translating Buses and Channels}
When translating the SMEIL process to \cspm{} it is important to design a well-formed structure to handle the input bus parameters of the SMEIL processes.
In SMEIL the parameters for each process can be input or output buses as well as constant values. The bus channel are then directly referenced in the expression within the SMEIL process body to access the value from the bus channel. The name used in the parameters of the process, is not the formal name of the bus, but simply a placeholder for the formal name which is defined in the network when instantiating the process. \\

There are several different ways to translate this particular part of the SMEIL process, each with its own advantage and disadvantage.
In Listing \ref{lst:cspm_input_values_examples} we can see three \cspm{} examples of how to translate an SMEIL input bus into an input for a \cspm{} process.\\

\begin{minipage}[t]{.98\linewidth}
    \centering
\begin{minipage}[t]{0.45\linewidth}
  \begin{minted}{smeil_lexer.py:SMEILLexer -x}
proc a (in input)
    bus abus {
        val: uint;};
{
    abus.val = input.val + 1;
}
  \end{minted}
  \captionof{listing}{An SMEIL process with an input bus as parameter.}
  \label{lst:smeil_input_parameter}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}

A(input_val) =
    let
        result = input_val + 1
    within
        a_abus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input value as parameter}
\label{lst:cspm_input_value}
\end{minipage}
\hspace{0.6cm}
\vspace{0.5cm}
\newline
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
A() =
    b_bbus_val ? value ->
    let
        result = value + 1
    within
        a_abus_val ! result ->
        SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with no input parameter}
\label{lst:cspm_no_input}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[t]{0.45\linewidth}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
A(input_bus_channel) =
input_bus_channel ? value ->
    let
      result = value + 1
    within
      a_abus_val ! result ->
      SKIP
\end{minted}
\captionof{listing}{A \cspm{} process with input channel as parameter}
\label{lst:cspm_channel_reads_input}
\end{minipage}
\vspace{0.3cm}
\captionof{listing}{Three different example of ways to translate the input in an SMEIL process to a \cspm{} process.}
\label{lst:cspm_input_values_examples}
\vspace{1cm}
\end{minipage}

Listing \ref{lst:smeil_input_parameter} shows a simple SMEIL process which takes an input bus as parameter. The three other examples in Listing \ref{lst:cspm_input_values_examples} shows different ways to translate this.

In Listing \ref{lst:cspm_input_value} the value itself is the parameter which means that the value can be used directly in the \texttt{let} clause.
This way of translating results in simpler process generation in TAPS, since all the information needed to translate to this process structure lies within the SMEIL process itself.
When adding the value itself as a process parameter, reading the value must happen somewhere else, which does not match the original SME model structure. \\

In Listing \ref{lst:cspm_no_input} the process does not have an input parameter and the input parameter from the SMEIL process have been translated directly to the formal channel name corresponding to the bus channel input in Listing \ref{lst:smeil_input_parameter}. This solution fits within the original SME model since the process itself reads a value before computing and writing, opposite to the solution in Listing \ref{lst:cspm_input_value}. Having to translate the channel name directly does lead to a more complex translation and TAPS will have to search the network to find the exact name of the channel. Another downside with this structure is that it removes the reusability that the SMEIL \texttt{instance} declaration provides. Therefore the generated code can become unnecessary complex because we have to define the processes several times instead of simply reusing the process and declaring it with different parameters in the network.\\

In Listing \ref{lst:cspm_channel_reads_input} the channel name are given as parameter. This solution is the best match to the original SMEIL process structure. The process reads the value itself, but the channel name is provided as a parameter, which means that the process can be reused as opposed to the solution in Listing \ref{lst:cspm_no_input}. This solution also have the advantage that TAPS does not have to search for information outside the process to translate the process.
The small downside to this solution is that the internal structure of the process must be changed on translation, since the name of the input value cannot be used directly in the \texttt{let} clause. In the original SMEIL program in Listing \ref{lst:smeil_input_parameter} the \texttt{input} value are declared in the process parameter and used directly in the process body. In this solution, TAPS would have to change one of these and put in an intermediate step where the process read a value and then use the value in the process body.\\

Out of these three solutions, it is clear that even though the solution in Listing \ref{lst:cspm_no_input} are the simplest version, the translation would become much more complex, which is a big disadvantage.

In order to create the simplest solution possible, I decided to use the solution in Listing \ref{lst:cspm_input_value}. Even though it does not exactly match the SME model it will not be a problem, since the network that reads from the channel will be very closely connected to the process. Using this solution results in a simpler translation of each process and leaves the more complex information to be translated in the network. This means that most of the translations in the program can be done swiftly without needing much information about the rest of the system. Only the network translation becomes complex.

In the case where the process does not have any parameters and are using the bus channels hierarchical names to communicate, this problem will not occur and TAPS will be able to translate the processes directly, since the actual name of the bus channel are defined within the process.

\section{Verification in \cspm{}}
In order to create the assertions for the refinement checking, I decided to create separate assert functions to keep the code structure clean. It would have been possible to include the assertions within the processes, but it is important to keep seperations of concerns and therefore I decided to add this extra process. This will increase the complexity of the generated \cspm{} network, but it will be a minor difference and it is still preferable to more complex process structures.

I know that for each \cspm{} channel there must be an assertion, except for input channels. Consequently, TAPS create a \textit{monitor} process for each channel and its only job is to listen in on the channel communication and assert the values communicated there. The monitor process is a process that is aadded specifically for asserting legal communication values in FDR4 and it does not affect the original SME network.

The monitor process checks the values communicated on the channel and if all values are within the expected range the process behaves as the \texttt{SKIP} process. If all values are not within the expected range, the monitor process behaves as the \texttt{STOP} process.

There might be a case where the developer is not interested in verifying all channels, but TAPS still add assertions to all channels, to simplify the code generation. If TAPS should only include monitor proceses for some channels, then a specific notation for which channels the monitor processes should be included, must be introduced. This is definitely possible, and might be relevant for future work, but adding this functionality might also have the consequence that some errors would not be caught, since the developer would be responsible for asserting which channels is worth checking.

In Figure~\ref{fig:assertion_process} the outline of the monitor process structure can be seen. I expect that this structure can be used for several different types of problems and thereby ensure a cleaner code structure.
\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[auto]
    \node[mycircle] (P) at (-1.5, 0.0) {$P$};
    \node[mycircle] (Q) at ( 2.5, 0.0) {$Q$};
    \node[mycircle, shape=rectangle] (M) at ( 0.5, 1.5) {$M$};

    \node[draw, shape=circle, inner sep=0pt, minimum size=5pt] (m) at (0.5, 0.0) {};


    \draw (M) -- (P -| M) [black!50];
    \draw [myarrow] (P) -- (Q);
  \end{tikzpicture}
  \caption{The monitor process \textit{M} listens in on the communication between \textit{P} and \textit{Q} in order to assert the communicated values.}
  \label{fig:assertion_process}
\end{figure}

For FDR4 to actually perform any refinement checking, an assertion must be added to the network by using the \texttt{assert} keyword. The assertion I wish to make is to check if the entire network terminates successfully. This is done by using the \texttt{SKIP} process as the specification process of a refinement check as well as the network to verify.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
assert SKIP [F= Network \ Events
\end{minted}
The example seen above shows a \cspm{} assertion which informs FDR4 what kind of refinement checking to do.
It is necessary to hide all events of the system since it would otherwise not be possible to verify the system unless I already had the exact failures or traces of the network. By hiding all events, all events become internal, and would still comply with the rules and structures of the network, but the refinement check would not include them. This also means that the end result of the network is what is checked and in this case we wish to verify that the network behaves like the \texttt{SKIP} process, which means that it will have terminated successfully.

I am using the \textit{failures} model described in Chapter \ref{chap:background} since I am not able to use the \textit{traces} model here. The reason I can not use the \textit{traces} model is because \texttt{SKIP} is defined as $\tick \then \STOP$. Since failures in the network are defined using \texttt{STOP}, the failures would simply also be accepted when using the \textit{traces} model, since the traces are the same. By using the \textit{failures} model, the refinement check does fail if a monitor process does not terminate successfully. This is because the failures of a \texttt{SKIP} process includes $\tick$, which the failures of a \texttt{STOP} process does not. Therefore, even though their traces are similar, the failures are not.


So the meta information that I am using to create the assertions on each channel are meta information within the SMEIL program. TAPS use the observed range of values for each channel to define the range of acceptable values in the assertions. TAPS then translates these values, not into meta data in \cspm{} but as an actual process with actual real semantics which is included as a part of the topology of the \cspm{} network.
\section{Translating Network}
\label{sec:design_translating_network}
When translating networks in SMEIL to \cspm{} it is crucial that the composition of the network are kept intact. As much as the network is a crucial part of the SMEIl program it is also one of the most tricky thing to translate correctly. The generated network quickly become large and complex which makes it harder to understand but also harder to ensure correct translation. \\

The SMEIL network are seperated into instances that each instantiates a single process its parameters. As mentioned in Chapter \ref{chap:analysis} the equivalence to the SMEIL network in \cspm{}, are the parallel operators. To create a similar network in \cspm{} TAPS will synchronise the processes together with the channels they are communicating on.
This is the only way in \cspm{} to enforce synchronised communication on channels which is the essential part of the synchronised network in SMEIL.

An example of a simple network in \cspm{} can be seen in Listing \ref{lst:general_parallel_operator} where the process \texttt{A} are synchronised with the process \texttt{B} over the channel \texttt{c}.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}

A = c ! 42 -> SKIP
B = c ? x -> SKIP

Network = A [|{| c |}|] B
\end{minted}
\caption{Example of synchronisation using the generalised parallel operator.}
\label{lst:general_parallel_operator}
\end{listing}
This example use the generalised parallel operator, since both processes communicate on the channel \texttt{c} and no other channels.

Two processes that must synchronise on the same channels but also must communicate on other channels can be synchronised using the alphabetised parallel operator. An example can be seen in Listing \ref{lst:alphabetised_parallel_operator} where process \texttt{A} communicates both on channel \texttt{c} and \texttt{d}. If the generalised parallel operator was used in this case including channel \texttt{d} in the synchronisation, then process \texttt{B} would also have to agree on communication on channel \texttt{d}, which would never happen since it does not communicate on channel \texttt{d}.
In this example the alphabetised parallel operator express that process \texttt{A} is allowed to perform events from the set on the left hand side of the operater, which contains both channel \texttt{c} and \texttt{d} and process \texttt{B} is only allowed to perform events on channel \texttt{c}, defined on the right hand side.
\begin{listing}
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
channel c : {0..10}
channel d : {0..100}

A = c ! 4 -> d ! 50 SKIP
B = c ? x -> SKIP

Network = A [{| c, d |} || {| c |}] B
\end{minted}
\caption{Example of synchronisation using the alphabetised parallel operator.}
\label{lst:alphabetised_parallel_operator}
\end{listing}


The challenge, when translating the network from SMEIL to \cspm{}, is to ensure that all processes connect with the other processes on the correct channels.
Since it is only possible to synchronise two processes at a time in \cspm{} it is a challenge to generate an entire network. The syncronisation of two processes becomes a new process which can then be synchronised with another process. This will continue for every process in the network and therefore, it quickly becomes very complex. It is an advantage that the \cspm{} networks are automatically generated, since it quickly becomes too large for easy hand translation, even for smaller examples.

Not only is it important that the network is generated to be equivalent to the original SMEIL network, but the monitor processes generated for each of the \cspm{} processes must also be included in the network. Since the monitor processes are only listining in on one specific channel, TAPS start out by synchronising it together with the writing process by using the generalised parallel operator.
The monitor process must always be synchronised with the writing process and not the process reading from the channel, since the synchronisation requires the two processes to agree on communication. If the monitor process was synchronised with the reading process, both would want to read, which would fail.

Since the monitor processes are currently only asserting one channel the synchronisation is simple but crucial to the assertions in FDR4.\\

If there are several output channels from a process the synchronisation of the monitor processes will be nested together. A structure like this can be seen in the excample below.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_A_monitor_network = (A [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
As mentioned above, if the process contains an input parameter the read must happen outside of the process itself. This is also included in this proces monitor network before the processes are synchronised.
\begin{minted}{cspm_lexer.py:CSPmLexer -x}
Process_A_monitor_network =
    channel ? x -> (A(x) [|{| c1 |}|] monitor1) [|{| c2 |}|] monitor2
\end{minted}
This design structure ensures that the monitor processes are included correctly in the network and also that each read for the processes are defined without too much complexity. This process monitor network can be considered a \texttt{shell} around the process, only containing process relevant information. Because of the structure of this process monitor network, TAPS is able to use this as was it a single process that reads and writes to other processes.

After this small network have been generated, it can then be synchronised together will other similar networks that share communication.

As mentioned in Chapter \ref{chap:analysis}, it is possible to instantiate one SMEIL process several times within the SMEIL network. Since TAPS is creating the network in \cspm{} by synchronising processes with each other via channels, it can synchronise the same process several times with different channels or parameters, creating the same functionality as the instances in SMEIL.\\

