%!TEX root = ../main.tex
In 1954 Martin Davis created the first computer generated mathematical proof, which proved that the product of two even numbers, is even. However simple the proof, it was a beginning to automated theorem provers and computer verification.
In the late 1960s, first-order theorem provers were applied to verification problems in Pascal, Ada and Java. One of these verification systems was the Stanfort Pascal Verifier\cite{Verifier1979} which was the first system to automatically solve a mathematical problem given by the American Mathematical Society before any official solutions had been published.
In 1972, Sir Robin Milner introduced an automated theorem prover which also introduced the ML programming language. The theorem prover was called Logic for Computable Functions, LCF~\cite{Milner1972}, and Milners work in automated reasoning have been the foundation for a lot of other theorem provers, like the proof assistant HOL (Higher Order Logic) by Mike Gordon, which was originally developed for reasoning about hardware. The formal proof management system Coq~\cite{coq} is also a descendent of LCF.
Automatic theorem provers have been very valuable in many different ways, but one problem have always been that if the theorem prover found a problem within a theorem, the prover could not provide a reason for the failure of the theorem. It was hard to solve the problems within the theorems when the error was unknown. A solution would be to have systems that could provide a counter example or some other explanation for the failure of the theorem. \\

In 1967, the paper \textit{Assigning meaning to programs}\cite{Floyd1967} by Robert W. Floyd was published. Floyd provided argumentation for formal definitions of the meaning of programs which could be used for proving correctness, equivalence and termination of computer programs. By using flowcharts, he argued that when a command is reached, all previous commands will have been true as well.\\ C.A.R Hoare was inspired by Floyd and in 1969 his paper \textit{An axiomtic basis for computer programming}\cite{Hoare1969} was published. The logic he presented there, which was later known as \textit{Hoare logic}, was build on Floyd's ideas and proposed the notation \textit{Partial correctness specification}; $\{P\} C \{Q\}$ where $C$ is a command and $P$ and $Q$ are conditions on the program variables in $C$. Hoare showed, that whenever $C$ is executed in a state that satisfies the condition $P$, and if the execution terminates, then the state that $C$ terminates in, will satisfy $Q$. Hoares method can be used to prove correctness properties of sequential programs. Hoare logic has also been the basis of several different formal languages and have contributed to the continuous work on formal verification. \\
Since the original Hoare logic was not thought as to model concurrent programs, Leslie Lamport extended Hoare's logic in the paper \textit{The 'Hoare logic' of concurrent programs}\cite{Lamport1980} in 1980. In it, it was discussed why Hoare logic, as proposed by C.A.R Hoare, did not adapt to concurrent programs and proposed a "generalized Hoare logic" that is generalized to concurrency. \\

In 1978, Hoares paper \textit{Communicating Sequential Processes}~\cite{Hoare1978} was published and with it, CSP was born.
CSP was introduced as a model to describe patterns in concurrent systems and communication between sequential processes running in parallel. CSP is a process algebra which, describes methods to formally model concurrent systems.\\
It have been widely used in many different types of work and have also been expanded since Hoare initially described it in 1978, which have been described in the book\cite{Abdallah2005} published for the 25th anniversary of CSP.
The first version of CSP was a simple programming language that had quite a different syntax than todays CSP. In 1984, Brookes, Hoare and Roscoe published their continued work on CSP with the paper \textit{A Theory of Communicating Sequential Processes}\cite{Brookes1984}, and created the modern process algebra it is today. Only a few minor changes have been made to CSP since then, and they are described in Roscoe's book; \textit{The Theory and Practice of Concurrency}\cite{Roscoe1997}.\\

A number of tools have been developed in order to analyse, verify and understand systems written in CSP. The orignal CSP process algebra is mostly a blackboard language and it can be difficult to use on a large scale. Different types of machine-readable CSP syntaxes have been created over the years, in order to make it easier and more accessible for companies and resarchers that does not have a large understanding of process algebra. Most of todays CSP tools supports a version of machine-readble CSP called \cspm{}  which was created by Bryan Scattergood\cite{Scattergood1998}. Scattergood created \cspm{}  as a combination of the standard CSP algebra and a functional programming language which provided a better baseline for tools to work with CSP.\\
Here is a subset of the different CSP tools:
\begin{itemize}
\item One of the most known CSP tools is the Failure-Divergence Refinement tool (FDR), build by Formal Systems (Europe) Ltd., and is currently at version 4.2.3\cite{fdr}. FDR4 is a model-checking tool for state machines which is based on the theory of CSP. CSP's method for evaluating if a property holds, is to test the refinement of a system against a specified model.
FDR is able to run in parallel as well as do state compression in order to avoid a very large state space.
\item ProBE (Process Behaviour Explorer)\cite{probe} is a tool to animate CSP programs in order to explore the state space of CSP processes in an interactive way. It provides the user a hierarchical structure of the possible actions and states of the process.
Is based on the same \cspm{}  version as FDR4 is and was also created by Formal Systems (Europe) Ltd. ProBE is integrated into the current version of FDR, version 4.
\item At Adelaide University, The Adelaide Refinement Checker (ARC)\cite{Parashkevov1996} is an automatic verification tool for CSP. It uses Ordered Binary Decision Diagrams (OBDDs) to represent the internal representation of data structures. This lessen the state explosion problem that other model checker tools have had.
\item The ProB project\cite{ProB}\cite{Leuschel2003} was originally created as an animation and model checker tool for the B-Method\cite{Abrial1988} but it also supports other languages, \cspm{}  included. Newer versions of ProB can perform refinement checking of \cspm{}  scripts as well as animate the process like the ProBE tool. ProB is an active project with continuous updates and impovements.
\item Jun Sun, Yang Liu, J.Dong et al. presented the Process Analysis Toolkit (PAT) in their 2009 paper\cite{Sun2009}. PAT is a model and refinement checker for concurrent and real-time systems. Models in PAT are interpreted as labeled transition systems (LTS) and the system can perform Linear Temporal Logic (LTL) model checking, refinement checking and simulation of CSP processes.
% \item CSP-Prover\cite{Isobe2005} is a theorem prover for CSP and based on the theorem prover Isabelle. It is an LCF style theorem prover and  entirely different way to check programs than model checking. It attempts to prove some general results based on specific theory. It is better at proving general results where model checkers are better at proving combinatorial problems. \todo{make this more clear}
\end{itemize}
The programming language Occam\cite{Occam1995}, which was first released in 1983, is a concurrent programming language that is based on the CSP process algebra. Occams strong basis in CSP makes it a great choice when formal proof of correctness are required.
% Inmos, the company that developed Occam, also developed a hardware chip, based on the Occam model, called the Transputer. Occam
Occam have been continuously developed during the years and at Kent University the Kent Retargetable occam Compiler (KRoC) team created the Occam-$\pi$\cite{UniveristyofKent} variant of the Occam programming language.
Occam-$\pi$ is a occam variant that extends the ideas of CSP from the original Occam language but adding mobility features from pi-calculus~\cite{Milner1992}.
\\
In the paper \textit{The symbiosis of concurrency and verification: teaching and case studies}\cite{Pedersen2018} Jan Pedersen and Peter Welch uses Occam-$\pi$ along with \cspm{} to present a workflow methodology for the development and verification of concurrent systems. By using an executable language like Occam-$\pi$, which is based on the concurrency model of CSP, it becomes easier to understand the logic of \cspm{} and thereby understanding the verification of a program with FDR4.\\

Another type of verification tool is SPIN\cite{spin}, that use process interactions to prove correctness of a system. The systems are described in the formal language \texttt{PROMELA}(PROcess MEta LAnguage)\cite{Holzmann1991} and, in contrast to \cspm, the correctness properties are not specified within the same language, in SPIN it is defined in Linear Temporal Logic (LTL)\cite{Pnueli1977}.
% In the paper \textit{Reasoning About Infinite Computations}\cite{Vardi1994}, Vardi and Wolper showed that all LTL formulas can be translated into a B\"uchi automata.
Spin performs verification on concurrent software and can prove correctness of process interactions which can be specified in several different ways, one being asynchronous message passing through buffered channels.
Spin was developed at Bell Labs, starting in 1980. Gerard J. Holzmann gives an introduction to the theoretical foundations, the design and structure and examples of applications in the paper \textit{The model checker SPIN}\cite{Holzmann1997}. \\
Another verification tool was developed as a collaboration between the Department of Information Technology at Uppsala University (UPP) in Sweden and the Department of Computer Science at Aalborg University (AAL) in Denmark. Larsen et al. first proposed the ideas for UPPAAL\cite{Larsen1995} in 1995 and further introduced it in the paper \textit{UPPAAL - a Tool Suite for Automatic Verifcation of Real-Time Systems}\cite{Bengtsson1995}.
UPPAAL is a verification tool for modelling, simulating and verifying real-time systems. It is based on the theory of timed automata~\cite{Hopcroft2001}~\cite{Alur1990} and systems that gain the most advantage of UPPAAL are systems where timing aspects are critical and where the communication goes through channels or shared variables.\\
As other model checkers, UPPAAL has a modelling language, wherein the system is specified, and a query language that is used to specify the properties to check against the system. The query language is a subset of CTL (computational tree logic) that applies to real-time systems~\cite{Henzinger1994}~\cite{Larsen1995}. The model checking is done by making a reachability analysis and checking the state-space. The current version of UPPAAL is called UPPAAL2K and was released in 1999\cite{Amnell2001}.\\

In 1981, Edmund M. Clarke and E. Allen Emerson managed to combine temporal logic with the state-space exploration in order to provide the first automated model checking algorithm\cite{Clarke1981}. It was capable of proving properties of programs as well as producing counter examples.
J. Burch, E. Clarke, K. McMillan et al.\cite{Burch1992} used, in 1992, Ordered Binary Decision Diagrams (BDDs) in \textit{symbolic model checking} which represents the state space symbolically. The symbolic model checking can verify systems with an extremely large number of states and thus creating a solution to the problems of state space explosion.\\
SPIN, as well as other model checker tools, have been build on the pioneering work Clarke and Emerson\cite{Clarke1981}, and Sifakis and Queille\cite{Queille1982}. Their work have provided a research area that are still active today. Vardi and Wolper extended the work with an automata-theoretic approach to automatically verify programs\cite{Vardi1986}.\\\\
% In the mid 1980s it was shown how model checking could be applied to hardware verification. However, it quickly became clear that model checking on hardware was very limited due to the state-space explosion that occurs especially on hardware. \\

Because of the state-space explosion problem and the increasing complexity of digital electronic circuits, there was a need to be able to model the timing and data flow of a ciruit with a certain amount of abstraction. This became Hardware Description Languages (HDL) and one of the most popular HDLs today is VHDL (VHSIC Hardware Description Language)~\cite{VHDL}.VHDL was initially ordered by the United States Department of Defence in 1981, to help with the growing problem of hardware life cycles. It is based on the Ada programming language and in 1987 it became an IEEE standard, known as VHDL-87. Several revisions have been released since VHDL-87, current version was released in 2009.\\

Another very used HDL is the language Verilog which was published by Gateway Design Automation in 1985 and are, along with VHDL, the two main HDL's used for modelling circuits. Cadence Design Systems received the rights to Verilog-XL which is the HDL simulator that would end up being the de-facto standard Verilog simulator. \\
VHDL as well as Verilog is used to write executable specifications for hardware, which can then be run in a simulation program in order to test the logic design before building it in hardware. An essential part of HDL design is the ability to simulate the programs. This allows the model to pass design criteria and validate the design functionality and intended purpose. The posibility of simulate the HDL programs also give the opportunity of exploring the possibilities within the language and hardware modelling. The programmer is able to test muliple versions of a solution and compare results before the hardware is produced. Thus, the posibility of simulating the HDL programs is essential for hardware design. \\


% However, VHDL and Verilog share many of the same limitations: neither is suitable for analog or mixed-signal circuit simulation; neither possesses language constructs to describe recursively-generated logic structures. Specialized HDLs (such as Confluence) were introduced with the explicit goal of fixing specific limitations of Verilog and VHDL, though none were ever intended to replace them. (From WIKI)

% TODO: Look at Property Specification Language also look at SVA (two property languages that are derived from LTL) (used for Hardware) - NOTE: It might be interesting, but I also have to draw a line as to how much I include, so for now I will leave it out.


Both theorem provers and model checkers have been, and are still, widely used for both software and hardware. There is a third form of formal verification that is also being used more often now. This is equivalence checking, which compares two models of a design and produces an outcome that either shows that they are equal or provides a counter-example to show when they disagree. It is beginning to become common practice for hardware designers to use equvalence checking to compare the design of an optimized digital design and an unoptimized digital design. This way it is possible for the designer to check that the optimizations did not change the functionality of the design.\\

Even though the translation between a specification language and a HDL or other programming language is usually quite problematic, it is still needed.
\cspm can specify the model and FDR4 can verify it, but to transfer this to hardware can be error-prone. Therefore several different researchers have,  over the years, presented systems for translating \cspm{} or subsets of \cspm{} into different hardware description languages:\\

In 2000 Zhou and Stiles presented the paper \textit{The Automated Serialization of Concurrent CSP Scripts using Mathematica}\cite{Zhou2000} where they present a package of Mathematica based tools to translate concurrent CSP into equivalent sequential code. In relation to this, Raju,
Rong, and Stiles presented the paper \textit{Automatic Conversion of CSP to CTJ, JCSP, and CCSP}~\cite{Raju2003} in 2003. They present a tool that can generate executable C or Java code from a \cspm{} program. In both cases, the implementation presented in the papers, are using a subset of the CSP algebra. In the paper by Raju,
Rong, and Stiles, they use the packages CTJ, JCSP and CCSP to resemble CSP structure. The packages are all Java or C packages which are created with the purpose of adding CSP-like features to C and Java.\\
In the paper \textit{An Automatic Translation of CSP to Handel-C}~\cite{Phillips2004} Jonathan D. Phillips and G. S. Stiles describe how their translator, the \texttt{CSPtoHC} translator, can translate a small subset of \cspm{} to Handel-C\cite{Celoxia2002} code which can then be compiled into files for programming an FPGA. \\
Another example of translating CSP into Handel-C was presented by Marcel Oliveria and Jim Woodcock in 2007 in the paper \textit{Automatic Generation of Verified Concurrent
Hardware}~\cite{Oliveira2007}. Oliveria and Woodcock present the system \texttt{csp2hs}, an automatic translator from \cspm{} to Handel-C, which according to Oliveria and Woodcock, have a very similar methodology to the \texttt{CSPtoHC} translator by Phillips and Stiles, however the subset of \cspm{} supported by the two solutions seems to be different.\\
Another example of translation between specification languages and hardware description languages are the translation between CSP\textbar\textbar B~\cite{Schneider2002a} to Handel-C. CSP\textbar\textbar B is an approach that combines the descriptions of events from CSP and the state from the B-method. The ProB system\cite{ProB}\cite{Leuschel2003} directly supports simulating CSP\textbar\textbar B models. In the paper,  Schneider et al. presents two different case studies which introduces different aspect of translating from CSP\textbar\textbar B to Handel-C. The translations, presented in the paper, are carried out by hand and are thus not automatic generated.\\
Lastly James Dibley and Karen Bradshaw presents the CSPIDER tool in their paper \textit{Deriving Reusable Go Components from Verified CSP Prototypes}~\cite{Dibley2018}. The CSPIDER tool is a software tool for automatic deriving reusable Go~\cite{Go} components from verified \cspm{} prototypes, where all the \cspm{} prototypes must be verified with FDR4. The tool is able to implement prototypes constructed from a subset of \cspm{} including recursively-defined proocesses, alphabetised parallel composition, channel input/output, external choice.