%!TEX root = ../main.tex
In 1954 Martin Davis created the first computer-generated mathematical proof. It proved that the product of two even numbers is even. In spite of its simplicity, it was the beginning to theorem provers and automatic verification.
In the late 1960s, first-order theorem provers were applied to verification problems in Pascal, Ada, and Java. One of these verification systems was the Stanford Pascal Verifier\cite{Luckham1979} which was the first system to automatically solve a mathematical problem given by the American Mathematical Society before any official solutions had been published.
In 1972, Sir Robin Milner introduced an automated theorem prover, along with the ML programming language. The theorem prover was called Logic for Computable Functions (LCF)~\cite{Milner1972}, and Milner's work in automated reasoning have been the foundation for a lot of other theorem provers, like the proof assistant Higher Order Logic (HOL) by Mike Gordon, which was originally developed for reasoning about hardware. The formal proof management system Coq~\cite{coq} is also a descendant of LCF.\\

Automatic theorem provers have been very valuable in many different ways, but especially one limitation caused problems. The theorem provers could not provide a reason for a failure. If a problem was found a problem within a theorem, the theorem prover could not provide a reason for the failure. It was hard to solve the problems within the theorems when the reason for the error was unknown. A solution to this limitation was to build systems that could provide a counterexample or some other explanation for the failure of the theorem. \\

In 1967, the paper \textit{Assigning meaning to programs}\cite{Floyd1967} by Robert W. Floyd was published, and in it, Floyd provided argumentation for formal definitions of the meaning of programs which could be used for proving correctness, equivalence, and termination of computer programs. By using flowcharts, he argued that when a command is reached, all previous commands will have been true as well.\\

C.A.R Hoare was inspired by Floyd and in 1969 his paper \textit{An axiomatic basis for computer programming}\cite{Hoare1969} was published. The logic he presented there, which was later known as Hoare Logic, was built on Floyd's ideas and proposed the notation Partial Correctness Specification; $\{P\} C \{Q\}$ where $C$ is a command and $P$ and $Q$ are conditions on the program variables in $C$. Hoare showed, that whenever $C$ is executed in a state that satisfies the condition $P$, and if the execution terminates, then the state that $C$ terminates in, will satisfy $Q$.
Hoare's method can be used to prove correctness properties of sequential programs. Hoare Logic has also been the basis of several different formal languages and has contributed to the continuous work on formal verification.\\

Since the original Hoare Logic was not developed to model concurrent programs, Leslie Lamport extended it, in the paper \textit{The 'Hoare logic' of concurrent programs}\cite{Lamport1980} in 1980. In it, it was discussed why Hoare Logic, as proposed by C.A.R Hoare, did not adapt to concurrent programs and proposed a "generalized Hoare Logic" that is generalized to concurrency. \\

In 1978, Hoare's paper \textit{Communicating Sequential Processes}~\cite{Hoare1978} was published and with it, CSP was born.
CSP was introduced as a model to describe patterns in concurrent systems and communication between sequential processes running in parallel. Today, CSP is a process algebra which describes a formal method for modeling concurrent systems.
CSP has been widely used in many different types of work and has also been expanded since Hoare initially presented it in 1978, which has been described in the book\cite{Abdallah2005} published for the 25th anniversary of CSP.
The first version of CSP was a simple programming language that had a quite different syntax than today's CSP. In 1984, Brookes, Hoare, and Roscoe published their continued work on CSP with the paper \textit{A Theory of Communicating Sequential Processes}\cite{Brookes1984} and introduced the modern process algebra it is today. Only a few minor changes have been made to CSP since then, and they are described in Roscoe's books \textit{The Theory and Practice of Concurrency}\cite{Roscoe1997} and \textit{Understanding Concurrent Systems}~\cite{Roscoe2010}.
\section{CSP Tools}
A number of tools have been developed in order to analyse, verify and understand systems written in CSP. The original CSP process algebra is mostly a blackboard language which can be difficult to use on a large scale. Different types of machine-readable CSP syntaxes have been created over the years, in order to make it easier and more accessible for both the industry and academia. Most of today's CSP tools supports a version of machine-readable CSP called \cspm{} which was created by Bryan Scattergood\cite{Scattergood1998}. Scattergood created \cspm{} as a combination of the standard CSP algebra and a functional programming language which provided a better baseline to create tools for CSP.
Here is a subset of the different CSP tools:
\begin{itemize}
\item One of the most known CSP tools is the Failure-Divergence Refinement tool (FDR)~\cite{fdr}, built by Formal Systems (Europe) Ltd. and is currently at version 4.2.3. FDR4 is a model-checking tool for state machines which is based on the theory of CSP. FDR4's method for evaluating whether a property holds, is to test the refinement of a system against a specified model.
FDR is able to run in parallel as well as do state compression in order to avoid a very large state space.
\item ProBE (Process Behaviour Explorer)\cite{probe} is a tool to visualise CSP programs in order to explore the state space of CSP processes in an interactive way. It provides the user with a hierarchical structure of the possible actions and states of the process. It is based on the same \cspm{} version as FDR4 is and it was also created by Formal Systems (Europe) Ltd. ProBE is integrated into the current version of FDR~\cite{fdr}.
\item At Adelaide University, The Adelaide Refinement Checker (ARC)\cite{Parashkevov1996} is an automatic verification tool for CSP. It uses Ordered Binary Decision Diagrams (OBDDs) to represent the internal representation of data structures. This lessens the state explosion problem that other model checker tools have had.
\item The ProB project\cite{ProB}\cite{Leuschel2003} was originally created as a visualisation and model checker tool for the B-Method\cite{abrial2005b} but it also supports other languages, \cspm{} included. Newer versions of ProB can perform refinement checking of \cspm{} scripts as well as visualise the process like the ProBE tool. ProB is an active project with continuous updates and improvements.
\item Jun Sun, Yang Liu, J.Dong et al. presented the Process Analysis Toolkit (PAT) in their paper from 2009~\cite{Sun2009}. PAT is a model and refinement checker for concurrent and real-time systems. Models in PAT are interpreted as labeled transition systems (LTS) and the system can perform Linear Temporal Logic (LTL) model checking, refinement checking and simulation of CSP processes.
\end{itemize}

\section{Verification Tools}
The programming language Occam\cite{Occam1995}, which was first released in 1983, is a concurrent programming language that is also based on the CSP process algebra. Occam's strong basis in CSP makes it a well suited choice for formal proof of correctness.
Occam have been continuously developed during the years, and at Kent University the Kent Retargetable occam Compiler (KRoC) team created the Occam-$\pi$\cite{UniveristyofKent} variant of the Occam programming language.
Occam-$\pi$ is an Occam variant that extends the ideas of CSP from the original Occam language but adding mobility features from pi-calculus~\cite{Milner1992}.
\\

In the paper \textit{The symbiosis of concurrency and verification: teaching and case studies}\cite{Pedersen2018} Jan Pedersen and Peter Welch use Occam-$\pi$ along with \cspm{} to present a workflow methodology for the development and verification of concurrent systems. By using an executable language like Occam-$\pi$, which is based on the concurrency model of CSP, it becomes easier to understand the logic of \cspm{} and thereby understanding the verification of a program with FDR4.\\

Another type of verification tool is SPIN\cite{spin}, that uses process interactions to prove the correctness of a system. The systems are described in the formal language PROcess MEta LAnguage (PROMELA)\cite{Holzmann1991} and, in contrast to \cspm, the correctness properties are not specified within the same language, in SPIN it is defined in Linear Temporal Logic (LTL)\cite{Pnueli1977}.
SPIN performs verification on concurrent software and can prove the correctness of process interactions which can be specified in several different ways, one being asynchronous message passing through buffered channels.
SPIN was developed at Bell Labs, starting in 1980. Gerard J. Holzmann gives an introduction to the theoretical foundations, the design and structure and examples of applications in the paper \textit{The model checker SPIN}\cite{Holzmann1997}.\\

Another verification tool was developed as a collaboration between the Department of Information Technology at Uppsala University in Sweden and the Department of Computer Science at Aalborg University in Denmark. Kim G. Larsen et al. first proposed the idea for UPPAAL~\cite{Larsen1995} in 1995, and it was further introduced by Bengtsson et al. in the paper \textit{UPPAAL - a Tool Suite for Automatic Verification of Real-Time Systems}~\cite{Bengtsson1995}.
UPPAAL is a tool for modelling, validating and verifying real-time systems based on the theory of timed automata~\cite{Alur1990}.
The systems that gain the most advantage of being verified with UPPAAL, are systems where timing aspects are critical.
As many other model checkers, UPPAAL has a description language wherein the system behavior is described. It also consists of a simulator and a model-checker. The simulator provides the opportunity to examine the system and validate possible executions while the model-checker checks invariant and reachability properties by performing a reachability analysis of the state space. The model-checker can also provide a trace which can explain failures or successes, and can be visualised for further trace examination.
The current version of UPPAAL is called UPPAAL2K and was released in 1999\cite{Amnell2001}.\\

In 1981, Edmund~M.~Clarke and E.~Allen Emerson managed to combine temporal logic with the state-space exploration in order to provide the first automated model checking algorithm\cite{Clarke1981}. It was capable of proving properties of programs as well as producing counterexamples.
J.~Burch, E.~Clarke, K.~McMillan et al. used, in 1992, Binary Decision Diagrams (BDDs) in \textit{symbolic model checking}~\cite{Burch1992} to represent the state space symbolically. The symbolic model checking can verify systems with an extremely large number of states and thus creating a solution to the problems of state space explosion.\\

SPIN, as well as other model checker tools, have been built on the pioneering work of Clarke and Emerson\cite{Clarke1981}, and Sifakis and Queille\cite{Queille1982}. Their works have provided a research area that is still active today. Vardi and Wolper extended the work with an automata-theoretic approach to automatically verify programs\cite{Vardi1986}.
\section{Hardware Description Languages}
Due to the increasing complexity of digital electronic circuits in the 1970s, a need arose for systems to be able to model the timing and data flow of a circuit with a certain amount of abstraction. This led to the introduction of Hardware Description Languages (HDLs). One of the most popular HDLs today is VHSIC Hardware Description Language (VHDL)~\cite{VHDL} which was ordered by the United States Department of Defence in 1981. It is based on the Ada programming language and in 1987 the first IEEE standard was released. Initially, it was developed to be a pure specification language, simulators for VHDL were developed later.\\

Another very used HDL is the language Verilog which was published by Gateway Design Automation in 1985 and are, along with VHDL, the two main HDL's used for modelling circuits.
Verilog, as well as VHDL, is used to write executable specifications for hardware, which can then be run in a simulation program in order to test the logic design before building it in hardware. An essential part of HDL design is the ability to simulate the programs. This allows the model to pass design criteria and validate the design functionality and intended purpose. The possibility of simulating the HDL programs also give the opportunity of exploring the possibilities within the language and within hardware modelling. The programmer is able to test multiple versions of a solution and compare results before the hardware is produced. Thus, the possibility of simulating the HDL programs is essential for hardware design.
\section{Translations from \cspm{}}
Even though the translation between a specification language and an HDL or other programming language is usually nontrivial, it is still an advantage over manual translation.
\cspm{} can specify a model and FDR4 can verify it, but to manually translate a model to hardware can be error-prone. Therefore several different researchers have, over the years, presented systems for translating \cspm{} or subsets of \cspm{} into different HDLs:\\

In 2000 W. Zhou and G. S. Stiles presented the paper \textit{The Automated Serialization of Concurrent CSP Scripts using Mathematica}\cite{Zhou2000} where they present a package of Mathematica based tools to translate concurrent CSP into equivalent sequential code.
In relation to this, V. Raju, L. Rong, and G. S. Stiles presented the paper \textit{Automatic Conversion of CSP to CTJ, JCSP, and CCSP}~\cite{Raju2003} in 2003. They present a tool that can generate executable C or Java code from a \cspm{} program. In both cases, the implementation presented in the papers are using a subset of the CSP algebra. Raju,
Rong, and Stiles use the packages CTJ, JCSP, and CCSP to resemble CSP structure in their paper. The packages are all Java or C packages which are created with the purpose of adding CSP-like features to C and Java. Neither of these systems have, to my knowledge, been extended or used in the industry.\\

In the paper \textit{An Automatic Translation of CSP to Handel-C}~\cite{Phillips2004} Jonathan D. Phillips and G. S. Stiles describe how their translator, CSPtoHC, can translate a small subset of \cspm{} to Handel-C\cite{Celoxia2002}, which can then be compiled into files for programming a FPGA.
Marcel Oliveria and Jim Woodcock present, in the paper \textit{Automatic Generation of Verified Concurrent Hardware}~\cite{Oliveira2007}, the system csp2hc. It is an automatic translator from \cspm{} to Handel-C which, according to Oliveria and Woodcock, have a very similar methodology to the \texttt{CSPtoHC} translator by Phillips and Stiles, however the subset of \cspm{} supported by the two solutions is different which makes comparisons impossible.\\

Another example of translation between specification languages and HDLs is the translation between CSP\textbar\textbar B to Handel-C~\cite{Schneider08}. CSP\textbar\textbar B~\cite{Schneider2002a} is an approach that combines the descriptions of events from CSP and the state from the B-method. The ProB system\cite{Leuschel2003} directly supports simulating CSP\textbar\textbar B models. In the paper, Schneider et al. present two different case studies which introduce different aspects of translating from CSP\textbar\textbar B to Handel-C. The translations, presented in the paper, are carried out by hand and are thus not automatically generated.\\

Finally, James Dibley and Karen Bradshaw present the CSPIDER tool in their paper \textit{Deriving Reusable Go Components from Verified CSP Prototypes}~\cite{Dibley2018}. The CSPIDER tool is a software tool for automatic deriving reusable Go~\cite{Go} components from verified \cspm{} prototypes. The tool is able to implement prototypes constructed from a subset of \cspm{} including recursively-defined processes, alphabetised parallel composition, channel input/output, and external choice. The CSPIDER tool is, to my knowledge, the newest system working with the translation of \cspm{}.