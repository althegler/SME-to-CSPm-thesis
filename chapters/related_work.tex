%!TEX root = ../main.tex
In 1954 Martin Davis created the first computer-generated mathematical proof. It proved that the product of two even numbers is even. In spite of its simplicity, it was the beginning to theorem provers and automatic verification.
In the late 1960s, first-order theorem provers were applied to verification problems in Pascal, Ada, and Java. One of these verification systems was the Stanford Pascal Verifier\cite{Luckham1979} which was the first system to automatically solve a mathematical problem given by the American Mathematical Society before any official solutions had been published.
In 1972, Sir Robin Milner introduced an automated theorem prover, along with the ML programming language. The theorem prover was called Logic for Computable Functions, LCF~\cite{Milner1972}, and Milners work in automated reasoning have been the foundation for a lot of other theorem provers, like the proof assistant HOL (Higher Order Logic) by Mike Gordon, which was originally developed for reasoning about hardware. The formal proof management system Coq~\cite{coq} is also a descendant of LCF.

Automatic theorem provers have been very valuable in many different ways, but one limitation theorem provers had was, if the theorem prover found a problem within a theorem, the prover could not provide a reason for the failure of the theorem. It was hard to solve the problems within the theorems when the reason for the error was unknown. A solution to this limitations was to build systems that could provide a counterexample or some other explanation for the failure of the theorem. \\

In 1967, the paper \textit{Assigning meaning to programs}\cite{Floyd1967} by Robert W. Floyd was published, and in it, Floyd provided argumentation for formal definitions of the meaning of programs which could be used for proving correctness, equivalence, and termination of computer programs. By using flowcharts, he argued that when a command is reached, all previous commands will have been true as well.

C.A.R Hoare was inspired by Floyd and in 1969 his paper \textit{An axiomatic basis for computer programming}\cite{Hoare1969} was published. The logic he presented there, which was later known as \textit{Hoare logic}, was built on Floyd's ideas and proposed the notation \textit{Partial correctness specification}; $\{P\} C \{Q\}$ where $C$ is a command and $P$ and $Q$ are conditions on the program variables in $C$. Hoare showed, that whenever $C$ is executed in a state that satisfies the condition $P$, and if the execution terminates, then the state that $C$ terminates in, will satisfy $Q$.

Hoare's method can be used to prove correctness properties of sequential programs. Hoare logic has also been the basis of several different formal languages and has contributed to the continuous work on formal verification.

Since the original Hoare logic was not developed to model concurrent programs, Leslie Lamport extended Hoare's logic in the paper \textit{The 'Hoare logic' of concurrent programs}\cite{Lamport1980} in 1980. In it, it was discussed why Hoare's logic, as proposed by C.A.R Hoare, did not adapt to concurrent programs and proposed a "generalized Hoare logic" that is generalized to concurrency. \\

In 1978, Hoare's paper \textit{Communicating Sequential Processes}~\cite{Hoare1978} was published and with it, CSP was born.
CSP was introduced as a model to describe patterns in concurrent systems and communication between sequential processes running in parallel. Today, CSP is a process algebra which, describes methods to formally model concurrent systems.

CSP has been widely used in many different types of work and has also been expanded since Hoare initially described it in 1978, which have been described in the book\cite{Abdallah2005} published for the 25th anniversary of CSP.
The first version of CSP was a simple programming language that had quite a different syntax than today's CSP. In 1984, Brookes, Hoare, and Roscoe published their continued work on CSP with the paper \textit{A Theory of Communicating Sequential Processes}\cite{Brookes1984} and introduced the modern process algebra it is today. Only a few minor changes have been made to CSP since then, and they are described in Roscoe's book; \textit{The Theory and Practice of Concurrency}\cite{Roscoe1997}.\\

\section{CSP Tools}
A number of tools have been developed in order to analyse, verify and understand systems written in CSP. The original CSP process algebra is mostly a blackboard language and it can be difficult to use on a large scale. Different types of machine-readable CSP syntaxes have been created over the years, in order to make it easier and more accessible for both the industry and academia. Most of today's CSP tools supports a version of machine-readable CSP called \cspm{} which was created by Bryan Scattergood\cite{Scattergood1998}. Scattergood created \cspm{} as a combination of the standard CSP algebra and a functional programming language which provided a better baseline to create tools for CSP.\\
Here is a subset of the different CSP tools:
\begin{itemize}
\item One of the most known CSP tools is the Failure-Divergence Refinement tool (FDR), build by Formal Systems (Europe) Ltd. and is currently at version 4.2.3\cite{fdr}. FDR4 is a model-checking tool for state machines which is based on the theory of CSP. CSP's method for evaluating if a property holds is to test the refinement of a system against a specified model.
FDR is able to run in parallel as well as do state compression in order to avoid a very large state space.
\item ProBE (Process Behaviour Explorer)\cite{probe} is a tool to animate CSP programs in order to explore the state space of CSP processes in an interactive way. It provides the user with a hierarchical structure of the possible actions and states of the process. It is based on the same \cspm{} version as FDR4 is and it was also created by Formal Systems (Europe) Ltd. ProBE is integrated into the current version of FDR, FDR4.
\item At Adelaide University, The Adelaide Refinement Checker (ARC)\cite{Parashkevov1996} is an automatic verification tool for CSP. It uses Ordered Binary Decision Diagrams (OBDDs) to represent the internal representation of data structures. This lessens the state explosion problem that other model checker tools have had.
\item The ProB project\cite{ProB}\cite{Leuschel2003} was originally created as an animation and model checker tool for the B-Method\cite{Abrial1988} but it also supports other languages, \cspm{}  included. Newer versions of ProB can perform refinement checking of \cspm{}  scripts as well as animate the process like the ProBE tool. ProB is an active project with continuous updates and improvements.
\item Jun Sun, Yang Liu, J.Dong et al. presented the Process Analysis Toolkit (PAT) in their 2009 paper\cite{Sun2009}. PAT is a model and refinement checker for concurrent and real-time systems. Models in PAT are interpreted as labeled transition systems (LTS) and the system can perform Linear Temporal Logic (LTL) model checking, refinement checking and simulation of CSP processes.
% \item CSP-Prover\cite{Isobe2005} is a theorem prover for CSP and based on the theorem prover Isabelle. It is an LCF style theorem prover and  entirely different way to check programs than model checking. It attempts to prove some general results based on specific theory. It is better at proving general results where model checkers are better at proving combinatorial problems. \todo{make this more clear}
\end{itemize}

\section{Verification Tools}
The programming language Occam\cite{Occam1995}, which was first released in 1983, is a concurrent programming language that is also based on the CSP process algebra. Occam's strong basis in CSP makes it a great choice when formal proof of correctness is required.
% Inmos, the company that developed Occam, also developed a hardware chip, based on the Occam model, called the Transputer. Occam
Occam have been continuously developed during the years, and at Kent University the Kent Retargetable occam Compiler (KRoC) team created the Occam-$\pi$\cite{UniveristyofKent} variant of the Occam programming language.
Occam-$\pi$ is an Occam variant that extends the ideas of CSP from the original Occam language but adding mobility features from pi-calculus~\cite{Milner1992}.
\\
In the paper \textit{The symbiosis of concurrency and verification: teaching and case studies}\cite{Pedersen2018} Jan Pedersen and Peter Welch use Occam-$\pi$ along with \cspm{} to present a workflow methodology for the development and verification of concurrent systems. By using an executable language like Occam-$\pi$, which is based on the concurrency model of CSP, it becomes easier to understand the logic of \cspm{} and thereby understanding the verification of a program with FDR4.\\

Another type of verification tool is SPIN\cite{spin}, that use process interactions to prove the correctness of a system. The systems are described in the formal language PROcess MEta LAnguage (\texttt{PROMELA})\cite{Holzmann1991} and, in contrast to \cspm, the correctness properties are not specified within the same language, in SPIN it is defined in Linear Temporal Logic (LTL)\cite{Pnueli1977}.
% In the paper \textit{Reasoning About Infinite Computations}\cite{Vardi1994}, Vardi and Wolper showed that all LTL formulas can be translated into a B\"uchi automata.
Spin performs verification on concurrent software and can prove the correctness of process interactions which can be specified in several different ways, one being asynchronous message passing through buffered channels.
Spin was developed at Bell Labs, starting in 1980. Gerard J. Holzmann gives an introduction to the theoretical foundations, the design and structure and examples of applications in the paper \textit{The model checker SPIN}\cite{Holzmann1997}.\\

Another verification tool was developed as a collaboration between the Department of Information Technology at Uppsala University (UPP) in Sweden and the Department of Computer Science at Aalborg University (AAL) in Denmark. Larsen et al. first proposed the ideas for UPPAAL\cite{Larsen1995} in 1995 and further introduced it in the paper \textit{UPPAAL - a Tool Suite for Automatic Verification of Real-Time Systems}\cite{Bengtsson1995}.
UPPAAL is a verification tool for modelling, simulating and verifying real-time systems. It is based on the theory of timed automata~\cite{Hopcroft2001}\cite{Alur1990} and systems that gain the most advantage of UPPAAL, are systems where timing aspects are critical and where the communication goes through channels or shared variables.
As many other model checkers, UPPAAL has a modelling language, wherein the system is specified, and a query language that is used to specify the properties to check against the system. The query language is a subset of computational tree logic (CTL) that applies to real-time systems~\cite{Henzinger1994}\cite{Larsen1995}. The model checking is done by making a reachability analysis and checking the state-space. The current version of UPPAAL is called UPPAAL2K and was released in 1999\cite{Amnell2001}.\\

In 1981, Edmund M. Clarke and E. Allen Emerson managed to combine temporal logic with the state-space exploration in order to provide the first automated model checking algorithm\cite{Clarke1981}. It was capable of proving properties of programs as well as producing counterexamples.
J. Burch, E. Clarke, K. McMillan et al. used, in 1992, Ordered Binary Decision Diagrams (BDDs) in \textit{symbolic model checking}~\cite{Burch1992} where it represents the state space symbolically. The symbolic model checking can verify systems with an extremely large number of states and thus creating a solution to the problems of state space explosion.

SPIN, as well as other model checker tools, have been build on the pioneering work of Clarke and Emerson\cite{Clarke1981}, and Sifakis and Queille\cite{Queille1982}. Their works have provided a research area that is still active today. Vardi and Wolper extended the work with an automata-theoretic approach to automatically verify programs\cite{Vardi1986}.\\

\section{Hardware Description Languages}
Because of the state-space explosion problem and the increasing complexity of digital electronic circuits, a need arose for systems to be able to model the timing and data flow of a circuit with a certain amount of abstraction. This became Hardware Description Languages (HDLs) and one of the most popular HDLs today is VHSIC Hardware Description Language (VHDL)~\cite{VHDL92}\cite{VHDL98}. VHDL was initially ordered by the United States Department of Defence in 1981 to help with the growing problem of hardware life cycles. It is based on the Ada programming language and in 1987 the first IEEE standard was released. Initially, it was developed to be a pure specification language, and if was first later on that simulators for VHDL were developed.

Another very used HDL is the language Verilog which was published by Gateway Design Automation in 1985 and are, along with VHDL, the two main HDL's used for modelling circuits. Cadence Design Systems received the rights to Verilog-XL which is the HDL simulator that would end up being the de-facto standard Verilog simulator.\\

VHDL, as well as Verilog, is used to write executable specifications for hardware, which can then be run in a simulation program in order to test the logic design before building it in hardware. An essential part of HDL design is the ability to simulate the programs. This allows the model to pass design criteria and validate the design functionality and intended purpose. The possibility of simulating the HDL programs also give the opportunity of exploring the possibilities within the language and within hardware modelling. The programmer is able to test multiple versions of a solution and compare results before the hardware is produced. Thus, the possibility of simulating the HDL programs is essential for hardware design.

% Both theorem provers and model checkers have been, and are still, widely used for both software and hardware. There is a third form of formal verification that is also being used more often now. This is equivalence checking, which compares two models of a design and produces an outcome that either shows that they are equal or provides a counter-example to show when they disagree. It is starting to become common practice for hardware designers to use equvalence checking to compare the design of an optimized digital design and an unoptimized digital design. This way it is possible for the designer to check that the optimizations did not change the functionality of the design.\\

\section{Translations from \cspm{}}
Even though the translation between a specification language and an HDL or other programming language is usually quite problematic, it is still needed.
\cspm{} can specify a model and FDR4 can verify it, but to translate a model to hardware, can be error-prone. Therefore several different researchers have,  over the years, presented systems for translating \cspm{} or subsets of \cspm{} into different hardware description languages:\\

In 2000 Zhou and Stiles presented the paper \textit{The Automated Serialization of Concurrent CSP Scripts using Mathematica}\cite{Zhou2000} where they present a package of Mathematica based tools to translate concurrent CSP into equivalent sequential code.

In relation to this, Raju, Rong, and Stiles presented the paper \textit{Automatic Conversion of CSP to CTJ, JCSP, and CCSP}~\cite{Raju2003} in 2003. They present a tool that can generate executable C or Java code from a \cspm{} program. In both cases, the implementation presented in the papers, are using a subset of the CSP algebra. In the paper by Raju,
Rong, and Stiles, they use the packages CTJ, JCSP, and CCSP to resemble CSP structure. The packages are all Java or C packages which are created with the purpose of adding CSP-like features to C and Java. Both of these systems have, to our knowledge, not been extended or used in the industry.\\

In the paper \textit{An Automatic Translation of CSP to Handel-C}~\cite{Phillips2004} Jonathan D. Phillips and G. S. Stiles describe how their translator, the \texttt{CSPtoHC} translator, can translate a small subset of \cspm{} to Handel-C\cite{Celoxia2002}, which can then be compiled into files for programming an FPGA.
Marcel Oliveria and Jim Woodcock present, in the paper \textit{Automatic Generation of Verified Concurrent Hardware}~\cite{Oliveira2007}, the system \texttt{csp2hs}. It is an automatic translator from \cspm{} to Handel-C which, according to Oliveria and Woodcock, have a very similar methodology to the \texttt{CSPtoHC} translator by Phillips and Stiles, however the subset of \cspm{} supported by the two solutions are different.\\

Another example of translation between specification languages and hardware description languages is the translation between CSP\textbar\textbar B~\cite{Schneider2002a} to Handel-C. CSP\textbar\textbar B is an approach that combines the descriptions of events from CSP and the state from the B-method. The ProB system\cite{ProB}\cite{Leuschel2003} directly supports simulating CSP\textbar\textbar B models. In the paper,  Schneider et al. present two different case studies which introduce different aspects of translating from CSP\textbar\textbar B to Handel-C. The translations, presented in the paper, are carried out by hand and are thus not automatically generated.\\

Lastly, James Dibley and Karen Bradshaw present the CSPIDER tool in their paper \textit{Deriving Reusable Go Components from Verified CSP Prototypes}~\cite{Dibley2018}. The CSPIDER tool is a software tool for automatic deriving reusable Go~\cite{Go} components from verified \cspm{} prototypes. The tool is able to implement prototypes constructed from a subset of \cspm{} including recursively-defined processes, alphabetised parallel composition, channel input/output, external choice. The CSPIDER tool is, to our knowledge, the newest system working with the translation of \cspm{}.