%!TEX root = ../main.tex

% This section should contain information about the problem, but not the solution. I am analysing the problem and explaining what will be problematic when translating from SMEIL to CSPm.

% Der er tre dele i SMEIL jeg har interesse i:
% Three components: Behavioral, structural, meta data

% Jeg skal ikke fortælle hvordan jeg har gjort det men analyse af problemet og ikke af løsningen. Jeg skal blot beskrive problemstillingerne.
In this section we analyse the differences between the SMEIL model and the functionality of \cspm. We also introduce important parts of the SMEIL structure and grammar in order to give an understanding of the different challenges.

\section{Transpiling SMEIL to \cspm{}}
\label{sec:transpiling}
% When transpiling from source code to source code, it is difficult to understand how to translate structures from one language to the other without losing functionality while still maintaining the structure of each language.\\
Since we are translating code from SMEIL to \cspm{}, the challenge it to find corresponding \cspm{} structures for the SMEIL strucutres. The ultimate goal is to find methods for transpiling, that can be generalized to most problems.

From the introduction to both SMEIL and \cspm it is clear that the main intention of each language is different and therefore the transpiling of a process in SMEIL to a \cspm process might not be completely trivial. All data from the SMEIL process will need to be translated into data and structures within the \cspm model, calculations and communications alike.

% TODO: Something about functional language to imperative language


% Vigtigt at have de tre dele adskilt i afsnittet. Brug figuren fra side 107 i bujo til at henvise til at jeg har en Magic 8-ball (Mit system) og jeg skal fra SMEIL til FDR og henvise til at det er det flow jeg har brug for.


% I SMEIL har jeg et prædefineret konsistent navnerum. Jeg skal ikke lave en symboltabel. Jeg arver direkte fra SMEIL til CSPm. Så her kan jeg snakke om at hvis jeg gjorde det på en anden måde ville jeg ikke kunne gøre det sådan. Det skal jeg skrive om her. TODO: Make a decision about where this belongs. It does not seem to be fitting in with the analysis, but on the other hand this was what Brian told me. But is he right?


When analysing the general structure of SMEIL programs, there are three structures that are particular interesting when we are interested in translating from SMEIL to \cspm{}. These three structures are:
\begin{enumerate}
    \item \textbf{Behavioral:} The general behavior of each process and function.
    \item \textbf{Structural:} How the circuit is connected, i.e which buses connects to which processes.
    \item \textbf{Meta information/Observed values} %TODO: Meta information or observed values?:
    The information that are meta information but provides an understanding of what data flows through the network.
\end{enumerate}

% TODO: Should I add the clock problem to the list, so it becomes four parts?

\subsection{Behavioral}
%% - Behavioral description - hvad den enkelte funktion gør. det oversættes ret nemt. Jeg bekymre mig ikke om variable og sådan nogle ting. Det er allerede gjort før det gøres til SMEIL, og dem kan jeg genbruge i min code generation.  Funktionel indhold af processer/ opførsel af den enkelte process - det er rimelig nemt oversat direkte til CSPm. Her kan man beskrive hvis der er nogle sproglige udfordringer, fx hvis CSPm ikke har loops eller lign.
The behaviour of the single process in the SMEIL program is the base of the functionality of the SMEIL program. By analysing the different structures of processes in SMEIL, we can get a sense of how it should be created in \cspm.
\subsubsection{Processes}
% TODO: Maybe I only need to introduce SMEIL stuff that TAPS support?

% %%%% SMEIL processes %%%%
An SMEIL process is defined by the \texttt{proc} keyword and consists of an identifier, process parameters, bus and variable declarations. The body of the process, or the process statements, consists of sequential statements such as communications and calculations that are to be evaluated once for each clock cycle. A small example can be seen in Listing \ref{fig:small_proc_example_smeil}
It is not possible to declare variables inside the process statements and therefore all variable and communications must be declared in the declarative part of the process. This attribute should simplify the translation to \cspm, since TAPS will only have to search the declarative part of the process to find all variable and bus definitions.
A process can be instantiated with a set of parameters. These parameters can be a mix of input and output buses and constants. A process is initiated in the network of a SMEIL program which will be explained later.

\begin{listing}
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
proc A (in i)
    bus a_bus {chan : int}
    {
        a_bus.chan = i.chan + 1
    }
\end{minted}
\caption{An example of the structure of an SMEIL process. The process receives the input, add the input with 1 and sends it out on the output bus.}
\label{fig:small_proc_example_smeil}
\end{listing}

In the SMEIL grammar, it is possible to declare if the process is \texttt{sync} or \texttt{async}. A \texttt{sync} process are run during each clock cycle, and a \texttt{async} process are only run when they receive a signal on the input bus. The current implementation of SMEIL does not support \texttt{async} processes, which means that all SMEIL process are in sync and behaves like decribed in Chapter \ref{chap:background}, where they read and write once in each clock cycle.
The syncronicity of the processes are an essential part of the SMEIL network and therefore it is crucial that the generated code is able to model this correctly. In \cspm{} a process does not communicate until it receives an input, which match the async process of SMEIL. However, since it is only the  synchronous processes that are supported in SMEIL, it is necessary to introduce
a structure to the \cspm network, that simulates the synchronous structure of the SMEIL proceses.
\\

In an SMEIL process, the declarative part of the process can consists of different variables and constants as well as bus definitions. In this next part we introduce variables and constants, whereas buses are described in section \ref{sec:analysis_structural}.
\paragraph{Constants}
Constants are used when declaring named constant values and consists of an identifier, a type and an optional expression. The expression could be simply an integer assigned to the constant, for instance:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
const hours: uint = 24;
\end{minted}
Variables are very similar to constants but simply hold mutable values within the process. In SMEIL variables persist their values in between clock cycles, which mean that it is possible for a process to save a value or result and reuse it in the next clock cycle.
\paragraph{Variables}
The only difference between variable and constants in SMEIL, is that variables can also take a range of values, for example:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
var minutes: u6 = 0 range 0 to 59;
\end{minted}
The assignment of \texttt{= 0} is simply to give an initial value of the variable, but is optional, as well as the ranges are optional. The range give an expected value range of the variable. When simulating the SMEIL program, the range of observed values are used to define the type of the variable.

In SMEIL, the types of variable and constants must always be defined and this also applies to bus channel declaration. The types can be either unlimited size integers, \texttt{int} and \texttt{uint}, or restricted to a specific bit-length. The prefixes \texttt{i} and \texttt{u} refers to signed and unsigned integers followed by a number determining the bit-length. For instance, \texttt{i4} represents a signed 4-bit integer.
The unlimited bit size \texttt{int} and \texttt{uint} are not realistic to have in \cspm since, when verifying a program, FDR4 will look at the entire possible statespace, and with unlimited integers the statespace will be enormous. FDR4 restricts its integer types to signed 32-bit\cite{UniversityofOxford}. \cspm does not apply types to its variables and constants the same way as SMEIL and \cspm also does not support all the types that SMEIL support.
Because of the type-system of SMEIL the libsme compiler will provide a warning if the values or ranges assigned to a constant or variable are above or below what the type can represent. In the example below the number 59 cannot be represented by 4 bits and therefore it would cause a warning from the compiler.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
var minutes: u4 = 0 range 0 to 59;
\end{minted}

In the SME model, processes never terminate, but when simulating an SMEIL program, it is necessary to terminate the simulation at some point, but it should simply be seen as a snapshot of the process and that not that the process terminates when the simulation ends.
The number of clock cycles, the simulation is run for, is specified via the command line tool.
There is of course limitations to the simulation, and it is important to note that the simulation is a simple tool to see the system running, however it does necessary provide all possible results of the system. If a system fails at a 1000 clock cycles, but the system is only simulated for 100 clock cycles, then we would not know about the failure. If the translation use the observed values from a simulation, the user need to know the limitations of the simulation.
% If the simulation is not passing through enough clock cycles, the verification might be inadequate. Since the verification builds on the observed values, the simulation needs to be long enough such that the whole possible range of input values is exhausted. %TODO: Where should I add this? Removed it from the background sectionZ

In \cspm, constant can be declared as we know it from many other languages;
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
N = 5
\end{minted}
and variables can be used without declaring them first, for example in a process declaration with a local definition.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Proc(x) =
    let
        m = x % 60
    within
        channel ! m -> SKIP
\end{minted}
A variable is also defined when communication specific values over channels in \cspm. For example in the example below, the received value is assigned to the variable $x$ which is then used when writing the value out in the \texttt{output} channel.
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
P = input ? x -> output ! x -> STOP
\end{minted}

Translating constants and variables from SMEIL to \cspm will not prove difficult, since the structures are quite similar.
A potential challenge lies in deciding how to define a variable that has been declared with initial value in SMEIL, since this mean that the \cspm translation will have to define the variable before it is used within the calculations.
\paragraph{Enumerations}
In SMEIL it is also possible to declare enumerations within a process or a network declaration. Emumerations can be used to referencing symbolic constants instead of its numerical constants which can improve the readability of the program.
Currently enumerations are not implemented in TAPS.
% TODO: Enummerations are not implemented in TAPS, so should I even write about it here?


% TODO: Should I say something about Generators?
% \paragraph{Generators}
% SMEIL does not support this, so I also wont support this and therefore I might not need this paragraph. It is however interesting because it is kind of a foor loop, but not because of the side effects but to simplyfy generation of code structures.


The other part of an SMEIL process is the statement part where the actual behaviour of the process is defined. The semantics of statements in SMEIL corresponds to what we typically see in C-like languages.
\paragraph{Assignments}
An assignment in SMEIL consists of a name and an expression. It can be used in two different ways within the SMEIL process statements: assigning to a variable and assigning to a bus channel. In SMEIL the compiler will always be able to recognize what is being assigned by looking at the type of the object and therefore SMEIL do not differentiate between these two assignments.
This property will cause a challenge when translating to \cspm{}, since communication and variable assignments are two different things in a \cspm program. Thus TAPS will have to be able to recognize what type of assignment it is, in order to create the correct translation.
\paragraph{if-statements}
If-statements are structured like we know from other languages with an if-expression, then-expression, elif-expression and an else-expression.
These kinds of statements can also be defined in \cspm, but \cspm does not support elif-expressions within the if-statement, so the translation would have to restructure the elif-expression to a nested if-expression.
Since the structure of the \cspm process is different, an if-statement might have a different context in the \cspm program. It is possible that TAPS have to take extra precautions to provide the correct context to the if-statement.
% \paragraph{Loops}
% TODO: Write something here when I am sure how loops work in CSPm.

\paragraph{Traces and assertions}
The trace statement in SMEIL is not affecting the behaviour of the process, but it simply prints out the string and arguments that is given, like a printf.
In \cspm it is possible to add a print statement, but this will appear in the right hand side of the FDR4 session window for easy evaluation, and it does not support printing out text, but rather calculations. Thus the trace statements in SMEIL is not compatible with \cspm and either the trace statements should be thrown away or kept as a comment in the generated code.\\

The assert statements are used internally in SMEIL and evaluated during program execution. If the assert statement is not valid, then the execution is halted and the error message, defined in the assert statement, is printed, for instance
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
assert(hour < 23, "hours cannot be greater than 23");
\end{minted}

Even though we wish to assert properties in FDR4, the properties that FDR4 can verify are not similar to the properties that the assert statements in SMEIL are asserting. As was introduced in Section \ref{sec:background_fdr}, FDR4 is a refinement checker and the assert statements in FDR4 are asserting the refinement check. In the \cspm language, assertions like \texttt{assert 4 + 4 == 8}, however FDR4 does not support this.
The two types of assert statement are therefore not equivalent. However, it should not be of interest to translate the SMEIL assert statements, since a potential error found via an SMEIL assertion, might as well be found and corrected in SMEIL than in FDR4.
% \paragraph{Switch statements}
% TODO: Write something about switch statements when I know more.

\paragraph{Expressions}
Expressions in SMEIL and their precedence rules are similar to C-like languages and we will therefore not introduce them further. Expressions are used for defining operations and naming in SMEIL.

In \cspm the standard binary operators like \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, and \texttt{\%} all take two arguments of type \texttt{Int} and return a value of type \texttt{Int}. It is important to notice that in \cspm, the \texttt{/} operator returns the quotient and rounds towards negative infinity. The \texttt{\%} operator in \cspm returns the modulus.
Floating point number are, to our knowledge, not supported by FDR4\cite{Scattergood2011} which is also clear from the fact that the binary operators take only \texttt{Int} as their inputs.
As mentioned in Section \ref{sec:background_smeil}, SMEIL supports floating poitn numbers in the simulator, but it has not been extensively tested.

The unary \texttt{-} operator, representing a negation of an integer and the unary \texttt{!} operator, representing logical negation are both represented in the FDR4 syntax. The relational operators \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{==} and \texttt{!=} returns boolean values both in SMEIL and in \cspm. The logical conjunction and disjunction operators \texttt{\&\&} and \texttt{||} are also represented in both SMEIL and \cspm and both only accepting boolean values.
The presedence of the above mentioned operators are not entirely identical acroos SMEIL and \cspm, so it might be necessary to add extra parentheses to keep the correct semantic.

% SMEIL also supports shift operations which is not supported in FDR4, but
% The programming languages C, C++, and Go, however, have only one right shift operator, >>. Most C and C++ implementations, and Go, choose which right shift to perform depending on the type of integer being shifted: signed integers are shifted using the arithmetic shift, and unsigned integers are shifted using the logical shift. - From wiki
% TODO: Ask truls about what kind of shift it is
% TODO: Find out how many of the operators are actually possible to use in CSPm.
% \texttt{<<}, \texttt{>>}, \texttt{&}, \texttt{|}, \texttt{^}, \texttt{+}(identity), \texttt{~}(bitwise not),

% TODO: Write something about array types. Can we have that in CSPm?(Page 25 in truls master)

% %%%% CSPm processes %%%%
As mentioned above, processes in SMEIL can be defined with parameters which represents input and output buses as well as constants. In \cspm{} processes can also be defined with parameters that can be variables, channels or similar.
In \cspm the processs behaviour also represents functionality, but the behaviour is often more focused on communicative behaviour between other processes. A typical process in \cspm could look like the one in Listing \ref{dining_philosopher_cspm} which represents a philosopher process from the dining philosophers problem. %TODO: Taken from the FDR4 website - how to represent this? Footnot or citation? ..  https://www.cs.ox.ac.uk/projects/fdr/manual/examples/index.html
The process behaviour shows a philosophers actions in communicating with other processes. As can be seen, the process also conduct some simple calculations, but the main structure consists of communication, which is the purpose of \cspm, to be able to verify communication between parallel processes.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
PHIL(i) = thinks.i -> sits!i -> picks!i!i -> picks!i!((i+1)%N) ->
          eats!i -> putsdown!i!((i+1)%N) -> putsdown!i!i -> getsup!i -> PHIL(i)

\end{minted}
\caption{A dining philosopher process from the dining philosophers problem example file provided at the FDR4 webpage~\cite{fdr_example}.}
\label{dining_philosopher_cspm}
\end{listing}

The translation of processes from SMEIL to \cspm does have its challenges and cannot be translated directly. In SMEIL the calculations of the process is as important as the communication whereas in \cspm it is often the other way round. The challenge lies in structuring the \cspm process in a way that gives the same functionality while still keep the \cspm communication behaviour and the assertion properties.

\subsubsection{Generating data}
%%%%% Generator processes %%%%%
When writing pure SMEIL programs, there will always be a need to generate input for the network. If the program was not written as pure SMEIL, the input for the network would be provided by the surrounding code. But in the case of pure SMEIL, the input data must be generated, which can be done in a few ways.
One way of initialising the network is by instantiating the processes with constants given as a parameter or hard code internal values into the process. These values will then act as the starting point of the network. Another way of initialising data in the SMEIL network, is to have a seperate process creating data for the network. We call this a data generator process.

An example of a process being instantiated with a constant can be seen in Listing \ref{lst:addone_data_generation_example}. Here we see the \texttt{Addone} network, which is a simply SMEIL network with two processes. The \texttt{add} process receives an input value, add the constant value to the input and writes it out on the outbus bus. The \texttt{id} process receives an input and writes it to its output bus imediately. Network structures have not been introduced yet, but it is simply just defining the input bus of the \texttt{add} process to be the output bus of the \texttt{id} process, as well as defining that the constant value in the \texttt{add} process is 1.

\begin{listing}
    \begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
    proc addone (in input, const constant)
        bus output {
            val: uint;
        };
    {
        output.val = input.val + constant;
    }

    pric id (in input)
        bus output {
            val: uint;
        }
        var from_add : uint;
    {
        from_add = input.val;
        output.val = from_add;
    }
    network net() {
        instance add of addone(id.output, val: 1);
        instance id of id(add.output)
    }
    \end{minted}
    \caption{The SMEIL network \texttt{Addone} with two processes. The \texttt{add} process is instantiated with a value \texttt{constant} which is constant and used once for each clock cycle. The example is similar to the Addone example in \cite{smeil}.}
    \label{lst:addone_data_generation_example}
\end{listing}

In Listing \ref{lst:clock_data_generation_example} we see another way to instantiate the SMEIL network. Here the process \texttt{clock} is a data generator process. It does not have any input bus so it cannot receive data, but are simply generating data for the network. This example is simply to show the data generator process concept, so the \texttt{minutes} process are simple and are just calculating how many minutes have passed since the simulation started.
\begin{listing}
    \begin{minted}[escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
    proc clock()
        bus output {
            val: uint;
        };
        var i: uint = 0;
    {
        i = i + 1;
        output.val = i;
    }

    proc minutes (in input)
        bus output {
            val: uint;
        };
        from_clock : uint;
    {
        from_clock = input.val;
        output.val = from_clock / 60
    }


    network net() {
        instance c of clock();
        instance s of minutes(c.output)
    }
    \end{minted}
    \caption{The SMEIL network \texttt{Minutes}, with a data generator process and a calculation process.}
    \label{lst:clock_data_generation_example}
\end{listing}

The data generator process is not defined specifically in SMEIL, however it is clear that processes that do not have an input bus, cannot do anything but write data to the network.

In \cspm it is of course necessary to define the space of data that FDR4 search through. It is possible to create a process in \cspm with the same functionality as the SMEIL data generator process. However, in that case, it would be necessary to syncronise the data process with the processes receiving data, otherwise FDR4 would simply evaluate all values within the defined range of the channels, making the data process obsolete. This syncronisation might over complicate the system and it might also increase the runtime of the verification, since the network would include more states.
In Figure \ref{fig:csp_data_generator_process} it can be seen that the channel between the \texttt{data} process and the \texttt{calc} process is defined to range of \texttt{\{0..100\}}. If the processes are not syncronised on this channel, the two processes do not have to agree on communication, and therefore the state space includes all the values from 0 through 100, which would mean that we get the same result by just having the channel as input for the \texttt{calc} process, without the \texttt{data} process.
However, if the processes are syncronised, FDR4 will still allocate all 100 posibilities, but it only continues the search on the values actually communicated on the channel. In this case, the data generator process would be able to define specific data to send and that might prove to be an advantage when interested in more complex data.

So one possibiliy is to define the data in \cspm by a single channel or by a process which generates the data for the network, just like in SMEIL.

Of course if the SMEIL network does not have a data generator process, the \cspm processes would have to be instantiated with the values, just like the SMEIL processes are.\\\\
 \begin{tikzpicture}
    \node[main node] (1) {\small \texttt{data}};
    \node[main node] (2) [right = 4cm of 1] {calc};
    \draw[fill] (0.7,0) circle [radius=0.07];

    \path[draw,thick, ->]
    (1) edge node {} (2);

    \node[align=center, below, text width=1.7cm] at (3.4,1){\footnotesize\texttt{channel c : \{0..100\}}};
    \node[align=center, below, text width=1.7cm] at (1.4,0){\footnotesize\texttt{output o : \{0..10\}}};
\end{tikzpicture}

------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\


In some cases the process have no input bus, since it is instantiated with a value within the process, as in Figure %TODO: reference to specific figure part.
We can assume that all SMEIL processes with no input bus will be a data generator process of some kind, and therefore must have some outwards communication. %TODO: Can we really assume this? think about it once again.

%% Generator processes - input bus with const declared
It becomes a bit more tricky if the process have an input bus, because it is to receive data later on, but it also works as an instantiator, either by having a value defined in the process declaration %TODO: Is this possible? Fx. if clock() had an input bus but still generated the starting point.
or by having a constant as an input argument in the process parameters. In this case the transpiler will have to recognize the data generator process or the initial starting point of the network and generate the data of the network from that. %TODO: Add an example that shows a generator process without an input, where it is generated as in 7segexample, also a version like the addone example and others if I can come up with them.
%TODO: also add text that explain each of them
In \cspm it is not possible to create a loop which generates data. Since the purpose of \cspm or FDR4 is to look at all possible states of a system, a loop generating data would not make sense. Typically the data possible for the system are defined in channel definitions or initialized via a parameter for a process function, both types can be seen in Figure %TODO: Add figure with two types of data generation in \cspm. Fx. either Var(0) or channel X : 0.
Here it becomes crucial that the transpiler generates the data correctly so the system checks all possible values, but still keep the structure of the network intact, and therefore it might be necessary to seperate the data generation from the process in order to keep the process task intact.

%%% Generator processes - More than one process
In SMEIL it is possible to have more than one proces which generates data for the network. These processes can generate data in all the ways described above, and can be combined together in various ways. In the case of more than one generator process with no input bus, it should not be more complex to translate than the case with one single data generator process, since the processes task still only consist of generating data and communicating them via their outbus bus. The receiving process are declared in the SMEIL network structure and therefore as long as the transpiler generates the same network in \cspm, it will not matter wheather there are one or more data generator processes.
If the generator processes are part of the network as the process in x%TODO: Create a reference to an example like the one in AddOne, where the process is a generator process but still have a task to do afterwards.
then the translation will have to create the data without destroying the purpose of the process, %TODO: Write some more here when I know more. If having more than one generator process with an input bus, does not change the solution from having one generator process with an input bus, then write that, else write how to solve it if there are more than one and why it is different than having one generator process with input bus.




\subsection{Structural}
\label{sec:analysis_structural}
% - Strukturel information: hvilke proceser er der og hvilke buser er de limet sammen med. hvordan hænger tingene sammen. Det er også forholdsvis nemt fordi FDR har processer på samme måde som SMEIL har. de har en historisk afhængighed ift. SME og CSP.

% %%%% SMEIL buses and channels %%%%
In SMEIL a bus are used as the glue between the processes to connect them into a network. The bus are used for communication between the SME processes in the network and each bus consist of one or more channels. A channel is individually assigned a process and each channel have a type, however the same types does not have to apply to all channels in the same bus. All channels in a single bus is connected at the same time, but each process communicates on a single channel.
Buses may form many-to-many relationships between processes and thus creating a similar situation as consists in hardware buses with physical wires where several different components can be connected to the same physical wire.
% TODO: Figure out if I should introduce the basics of SMEIL like examples of buses declarations etc.

In SMEIL a bus is simply a shell that contains channels. It does not have a type or values, it contains channels which each has a name, type and values etc. Each bus in SMEIL does have an identifier and this is used to reference the specific bus.
Since a bus is connected with all channels at the same time, the processes of SMEIL does not receive the channel as input parameter, but the bus itself. It is then up to the body of the process to call the correct channel in the input bus so to get the content that was communicated on the specific channel.

\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
bus day {
    hours:   u5 range 0 to 23;
    minutes: u6 range 0 to 59;
    seconds: u6 range 0 to 59;
};
\end{minted}

A bus can also be defined with the keyword \texttt{exposed} which indicated that the bus is used to external interactions either through co-simulation or as the top-level entity of the generated VHDL code. None of these two posssible usecases are currently implemented in TAPS, and thus the keyword \texttt{exposed} will cause an error in the transpiler. %TODO: Will it cause an error? And should I add more info to this?


% TODO: Maybe add something here about outbus bus/channels and how they are defined and called.

% TODO: Show an example of a SMEIL bus and channels


% TODO: On page 26-27 in Truls master there is some interesting things about using a bus channel for either input or output and not both within the same process. Write something about that



% %%%% SMEIL Channels %%%%%
A bus channel in SMEIL is declared with an identifier and a type which represents the data the bus channel will be communicating. The bus channel can also be declared with a predefined expression, fx. %TODO: Give an example here.
and an optional range of values of the type of the bus channel.
Each channel
% TODO: Add an example where a process calls the channel in the input bus. Also create an example where the bus is not defined with channels.

% %%%% CSPm channels %%%%
In \cspm all communication goes through a channel, thus there are no shell around the channels like in SMEIL.
Channels in \cspm %TODO: something about communicating values and ranges and types
Channels in \cspm are global namespace %TODO: Is that what it is called?

% TODO: Write something about CSPm channels


% %%%% Input bus have more than one channel

% %%%% Bus only defined as parameter
If the (output?) bus is not defined with channels, as can be seen in figure x,
% TODO: Create reference to the figure created above
the process still needs to reference that specific channel in the bus. It is not possible in SMEIL to call a bus without a channel. So when the bus is called, as long as the channel called match what has been defined as channels for that specific bus, then all is good. The translation of this should be rather simple, since all buses consists of channels, all channels should be possible to translate directly to \cspm channels.
% %%%% Channel names
The difficult part of translating SMEIL channels to \cspm channels will be to be sure that the naming is unique. In SMEIL the names of the channels are local to the bus, but in \cspm all channels are global. Therefore the naming of the channels needs to be unique and then all references to the channels in SMEIL should be possible to reuse with the \cspm channel naming.
% TODO: write something about adding the range of the channel to \cspm


%% What to do if there is several channels in one bus that acts as an input bus for a process.
In SMEIL each bus can consist of several different channels. When accessing the communicated values, the process have to refer to the specific bus and the specific channel name. In \cspm all communications are done with channels. The translation between SMEIL buses and \cspm channels should be straightforward, since channels is a subset of buses in SMEIL and therefore a bus with two channels would be the same as two buses with one channel. However, when defining the input for the proceses in SMEIL, only the bus name is used and therefore the transpiling will have to be able to recognize which channels belongs to which bus in order to give the correct channels as input for the \cspm processes.



% %%%% SMEIL processes communication %%%%
In the SMEIL process parameters, the input bus will be declared as well as any constants that the process will be initialised with. The output bus can also be given in the process parameters, but in that instance it will also have to be declared somewhere else in the program
%TODO: Make sure this is correct - ask Truls
Another way to declare the output bus, is by not having it in the process parameters, but declare it in the process declarations.
A full declaration of a bus consist, as mentioned above, of an identifier, the channels and their types and values.

A process receives input communication by accessing a specific channel of the input bus. The process can then make calculations based on the input and then communicate the result out of the process by assigning the result to a specific channel of the output bus.
%TODO: Add example of an input bus and getting information?





% %%%% SMEIL network %%%%
% TODO: Add an example of an SMEIL network
The network in an SMEIL program is the crucial part which ties all the processes and communication together. In the network buses or instances of processes are defined as well as the input and output for those proceses. In order to generate a correct network in \cspm the translation of the SMEIL network is crucial.
% TODO: Write more about the SMEIL network
% %%%% SMEIL instances %%%%
% TODO: Write about the SMEIL instances here
% %%%% CSPm network %%%%
In \cspm there is also a structure that is similar to the network structure in SMEIL. When synchronizing processes together with channels in a new process in \cspm we create the structure of what channels each process communicates on, and therefore which processes communicate to which processes.
% TODO: Add more about cspm syncronisation and here above
% TODO: Change this last sentence to not sound like design (Above)
This translation step will require carefully planning in order to get all the information for each part, in the correct position of one another. In SMEIL buses can also be declared in the network declaration but.. %TODO: ...currently the system does not handle other than pure SMEIL programs and therefore we do not need to handle if these buses are not both an input and output bus in some processes.

% TODO: Write about two networks and how it will be translated to a network and therefore we should be able to have them seperated easily and the communication is what combines them, and that is the same in cspm. TODO: But ask Truls if this would even make sense. To have to networks.


% TODO: Write about instances before this part below
% TODO: Write about how one process can be defined in SMEIL several times and how it does not matter, since the process will be defined the same in CSPm but that the network will simply be generated twice with two different names and inputs or similar. (Does that also work if it is different output?)
In SMEIL the networks of the system are constructed by a series of entities and these entities are connected by bus communication. For each instance, the process and communication will be declared and thus, connecting the network. SMEIL also have the great advantage that it is possible to have several instances of the same process with different parameters. This means that a process defined in the network can be instantiated several times, with differen parameters and thereby reusing code, without having to create the process once again. Since the network structure, as mentioned above, is created by syncronizing processes together with channels in \cspm, having several different instances of the same process should not prove to be difficult, however it is evident that TAPS keep the information about each instance of each process seperate so that no information is lost in the translation.




%% I cannot assume that the output bus is defined in a busdeclaration in the process
In an SMEIL, each process can have any number and combinations of input buses, output buses and constant parameters and since SMEIL have been created so that the creation of a circuit gives the most flexibility, we have to handle several different ways of defining these in \cspm.
Process input buses can be defined in the parameter when defining the process or the communication can be created by directly using the buses through their hierarchical names %TODO: reference truls master page 20

Process output buses can be defined the same as input buses; as a parameter in the process or by using the hierarchical names of the buses. It is also possible not to have the output bus defined in the parameters but to have a bus declaration inside the process description.
% TODO: Might need to go in structure section



Constants can also be defined as a parameter and as a constant declaration within the process description. %TODO: Find out more about constants. are we interested in them, then I need to write more, otherwise I can close this part early.
When transpiling to \cspm there is a need for the transpiler to be able to recognize all different ways of defining buses and constants within the SMEIL program.

\subsection{Meta}
% - Opserverede værdier - "known limits". Meta information i SMEIL, og det skal oversættes til faktiske processer med faktiske semantic i FDR der også er en del af topologien. (Det er essensen for mig).

In the process description in SMEIL, the channels of a bus are defined as well as the types and observed values for these channels. This data is the crucial data to gather in order for FDR4 to be able to verify the values communicated on the channels. In SMEIL it is simply data that is used when simulating the program or if translated to VHDL
%TODO it is VHDL right?
. The circuit does not need to know exactly what values are communicated or what type that is.


% %%%% Monitor processes %%%%%
When verifying attributes(?) in FDR4, we need some specifics to verify on. One scenario is that we want to verify that no values are communicated on a channel, that does not lie within the expected range. In this case we will have to get the correct data from the SMEIL program and handle them in a way that gives FDR4 something to verify.
% TODO: Maybe write something about getting the ranges and thereby we should simulate or the programmer should annotate the code herself. I have already added some stuff about this in the design part

\section{Internal clock structure} \label{sec:analysis_clock}
% Here I should analyse the clock structure of SMEIL and also introduce how there is not such thing in CSPm. I am not sure if it is enough to introduce it in the background chapter, or if it is also needed here.