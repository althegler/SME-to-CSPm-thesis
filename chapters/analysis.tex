% This section should contain information about the problem, but not the solution. I am analysing the problem and explaining what will be problematic when translating from SMEIL to CSPm.

% Der er tre dele i SMEIL jeg har interesse i:
% Three components: Behavioral, structural, meta data

% Jeg skal ikke fortælle hvordan jeg har gjort det men analyse af problemet og ikke af løsningen. Jeg skal blot beskrive problemstillingerne.

\section{Transpiling SMEIL to \cspm{}} \label{sec:transpiling}
When transpiling from source to source the difficult part is to understand the structure of each language and to understand how to translate structures from one language to the other without losing functionality but still maintaining the structure of each language.

When transpiling from SMEIL to \cspm{} the goal was to find a method for transpiling, that could be generalized to most problems. We have worked on separation of concerns in order to simplify, but also to have a greater chance of being able to match more SMEIL programs.

From the introduction to both SMEIL and \cspm it is clear that the main intention of each language is different and therefore the transpiling of a process in SMEIL to a \cspm process might not be completely trivial. All data from the SMEIL process will need to be translated into data and structures within the \cspm model, calculations and communications alike.

% TODO: Something about functional language to imperative language


% Vigtigt at have de tre dele adskilt i afsnittet. Brug figuren fra side 107 i bujo til at henvise til at jeg har en Magic 8-ball (Mit system) og jeg skal fra SMEIL til FDR og henvise til at det er det flow jeg har brug for.


% I SMEIL har jeg et prædefineret konsistent navnerum. Jeg skal ikke lave en symboltabel. Jeg arver direkte fra SMEIL til CSPm. Så her kan jeg snakke om at hvis jeg gjorde det på en anden måde ville jeg ikke kunne gøre det sådan. Det skal jeg skrive om her. TODO: Make a decision about where this belongs. It does not seem to be fitting in with the analysis, but on the other hand this was what Brian told me. But is he right?


When analysing the general structure of SMEIL programs, there are three structures that are particular interesting when we are interested in translating from SMEIL to \cspm{}. These three structures are:
\begin{enumerate}
    \item \textbf{Behavioral:} The general behavior of each process and function.
    \item \textbf{Structural:} How the circuit is connected, i.e which buses connects to which processes.
    \item \textbf{Meta information/Observed values} %TODO: Meta information or observed values?:
    The information that are meta information but provides an understanding of what data flows through the network.
\end{enumerate}


\subsection{Behavioral}
%% - Behavioral description - hvad den enkelte funktion gør. det oversættes ret nemt. Jeg bekymre mig ikke om variable og sådan nogle ting. Det er allerede gjort før det gøres til SMEIL, og dem kan jeg genbruge i min code generation.  Funktionel indhold af processer/ opførsel af den enkelte process - det er rimelig nemt oversat direkte til CSPm. Her kan man beskrive hvis der er nogle sproglige udfordringer, fx hvis CSPm ikke har loops eller lign.

\subsubsection{Processes}
% TODO: Maybe I only need to introduce SMEIL stuff that TAPS support?

% %%%% SMEIL processes %%%%
A SMEIL process is defined by the \texttt{proc} keyword and consists of an identifier, process parameters, bus and variable declarations as well as the process statements which consists of sequential statements such as communications and calculations that are to be evaluated once for each clock cycle.
It is not possible to declare variables in the process statements and therefore all variable and communications are declared in the declarative part of the process. This attribute should simplify the translation to \cspm, since TAPS will only have to search the declarative part of the process to find all variable and bus definitions.
A process can be instantiated with a set of parameters. These parameters can be a mix of input and output buses and constants. A process is initiated in the network of a SMEIL program which will be explained later.

In the SMEIL grammar, it is possible to declare if the process is \texttt{sync} or \texttt{async}. A \texttt{sync} process are run during each clock cycle, and a \texttt{async} process are only run when they receive a signal on the input bus. The current implementation of SMEIL does not support \texttt{async} processes, which means that the translation to \cspm should be able to handle at least \texttt{sync} processes, but preferably both cases. Since \cspm does not support clock cycles, it is important to figure out how to simulate the same results in \cspm without having a designated clock.
% TODO: Should I write more here, or am I introducing the clock problem somewhere else?
\\

In an SMEIL process, the declarative part of the process can consists of different variables and constants. Here we shortly introduce these.
\paragraph{Constants}
Constants are used when declaring named constant values and consists of an identifier, a type and an optional expression. The expression could be simply an integer assigned to the constant, for instance:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
const hours: uint = 24;
\end{minted}
Due to the unification in SMEIL, constants should always be declared as unconstrained types, and the compiler will emit a warning for contrained types such as \texttt{u5}. %TODO: Shoudl I keep this or does this not matter?
Variables are very similar to constants but simply hold mutable values within the process. %TODO: Is it important to know that the state of variables in SMEIL persists between clock cycles?
\paragraph{Variables}
When declaring a variable in SMEIL, the only difference between variable and constants are that variables can also take a range of values, for example:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
var minutes: u6 = 0 range 0 to 59;
\end{minted}
The assignment of \texttt{= 0} is simply to give an initial value of the variable, but can be omitted, as well as the ranges. The range are used to give an expected value range of the variable and is used to calculate the bit size required of the variable type.
% TODO: Here we show a uint type, but we know that we never should see one of those in the translations and therefore I need to introduce the simulation part and the stuff about the types, but do I add it here or somewhere else?
\paragraph{Enumerations}
In SMEIL it is also possible to declare enumerations within a process or a network declaration. Emumerations can be used to referencing symbolic constants instead of its numerical constants which can improve the readability of the program.
Currently enumerations are not implemented in TAPS.
% TODO: Enummerations are not implemented in TAPS, so should I even write about it here?


% TODO: Should I say something about Generators?
% \paragraph{Generators}
% SMEIL does not support this, so I also wont support this and therefore I might not need this paragraph. It is however interesting because it is kind of a foor loop, but not because of the side effects but to simplyfy generation of code structures.

In \cspm, constant can be declared as we know it from many other languages;
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
N = 5
\end{minted}
and variables can be used without declaring them first, for example
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Proc(x) =
    let
        m = x * 60
    within
        |$\vdots$|
\end{minted}

To translate constants and variables from SMEIL to \cspm should not prove difficult, since the structures are quite similar. However the translation of ranges and types, both in constants and variables might provide some challenges, and it important to explore if these data are even necessary within the generated \cspm program.
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\



However, since we do have the process processes in both SMEIL and \cspm, transpiling SMEIL to \cspm should be possible since the general behaviour can be created in \cspm. The main two things important in the behaviour of an SMEIL program is the communication and the calculations. The communication will be possible to transpile in a fairly simple manner, and since \cspm is based on mixing the CSP algebra with a functional language, the calculations should also be possible to transpile in a reasonable manner.
For simplicity of the generated code, it would be beneficial to be able to keep the communication and calculations from the same SMEIL process in the same \cspm structure. Another potential challenge is to determine the value of a constant or variable that has not been declared with either range or initial value. 



%% Translating variables directly because we expect errors or other things to have been handled before transpiling the code.
When translating the process from SMEIL to \cspm we will be able to translate variables and calculations directly without having to translate the meaning of the it, since we are expecting SMEIL to handle behavioural errors.

% TODO: Write something more about FDR not supporting floating point
When translating from SMEIL to \cspm we will run into a problem with floating point numbers. SMEIL does support floating point numbers, but FDR4 does not, %TODO: add reference. is it only FDR4 or is it build into CSP not to support it?
and therefore we will have to convert the floating point numbers to integer, or simply not trying to verify programs that rely on floating poing numbers. The reason FDR does not support floating point numbers are... %TODO: write more here



This is a somewhat recognizable function structure for functional languages.



% %%%% CSPm processes %%%%
In \cspm{} processes can also be defined with parameters given. .. %TODO: Write more here. Also note that I have to explain parameters in the SMEIL process section above, because otherwise it wont make sense here.


In \cspm the structure is commonly consisting of communication which might include some kind of calculations, but the main purpose of \cspm processes are usually to express communication. %TODO: Add reference to FDR example (I took it from FDRs website - test example https://www.cs.ox.ac.uk/projects/fdr/manual/examples/index.html. Dining Philosophers)

\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
PHIL(i) = thinks.i -> sits!i -> picks!i!i -> picks!i!((i+1)%N) ->
          eats!i -> putsdown!i!((i+1)%N) -> putsdown!i!i -> getsup!i -> PHIL(i)

\end{minted}
\caption{x}
\label{x}
\end{listing}


% TODO: Understand CSPm processes better


%%%%% Generator processes %%%%%
When writing pure SMEIL programs, there is a need to generate input for the network. If the program was not written as pure SMEIL, the input for the network would be provided by the surrounding code. But in the case of pure SMEIL, the input data must be generated which is done by a generator process.
%%% Generator processes - clock cycles
The transpiler must be able to handle all these different processes and must ensure that the data are representing all possible values from the SMEIL program. \cspm are not able to simulate clock cycles and therefore all data communicated in the \cspm program will represent the clock cycles from the SMEIL representation.
%TODO: Remember to introduce the simulation of SMEIL somewhere and introduce ranges etc. so the clock cycle thing makes sense.
%TODO: Is this section too much design and not really analysis?
%TODO: Not sure if the clock cycle thing should be here or somewhere else.

%%% Generator processes - no input bus process.
A generator process in SMEIL can be constructed in several diffent ways, which can be seen in Figure %TODO: Add reference to figure of the different generator processs.
In some cases the process have no input bus, since it is instantiated with a value within the process, as in Figure %TODO: reference to specific figure part.
We can assume that all SMEIL processes with no input bus will be a data generator process of some kind, and therefore must have some outwards communication. %TODO: Can we really assume this? think about it once again.

%% Generator processes - input bus with const declared
It becomes a bit more tricky if the process have an input bus, because it is to receive data later on, but it also works as an instantiator, either by having a value defined in the process declaration %TODO: Is this possible? Fx. if clock() had an input bus but still generated the starting point.
or by having a constant as an input argument in the process parameters. In this case the transpiler will have to recognize the data generator process or the initial starting point of the network and generate the data of the network from that. %TODO: Add an example that shows a generator process without an input, where it is generated as in 7segexample, also a version like the addone example and others if I can come up with them.
%TODO: also add text that explain each of them
In \cspm it is not possible to create a loop which generates data. Since the purpose of \cspm or FDR4 is to look at all possible states of a system, a loop generating data would not make sense. Typically the data possible for the system are defined in channel definitions or initialized via a parameter for a process function, both types can be seen in Figure %TODO: Add figure with two types of data generation in \cspm. Fx. either Var(0) or channel X : 0.
Here it becomes crucial that the transpiler generates the data correctly so the system checks all possible values, but still keep the structure of the network intact, and therefore it might be necessary to seperate the data generation from the process in order to keep the process task intact.

%%% Generator processes - More than one process
In SMEIL it is possible to have more than one proces which generates data for the network. These processes can generate data in all the ways described above, and can be combined together in various ways. In the case of more than one generator process with no input bus, it should not be more complex to translate than the case with one single data generator process, since the processes task still only consist of generating data and communicating them via their outbus bus. The receiving process are declared in the SMEIL network structure and therefore as long as the transpiler generates the same network in \cspm, it will not matter wheather there are one or more data generator processes.
If the generator processes are part of the network as the process in x%TODO: Create a reference to an example like the one in AddOne, where the process is a generator process but still have a task to do afterwards.
then the translation will have to create the data without destroying the purpose of the process, %TODO: Write some more here when I know more. If having more than one generator process with an input bus, does not change the solution from having one generator process with an input bus, then write that, else write how to solve it if there are more than one and why it is different than having one generator process with input bus.




\subsection{Structural}
% - Strukturel information: hvilke proceser er der og hvilke buser er de limet sammen med. hvordan hænger tingene sammen. Det er også forholdsvis nemt fordi FDR har processer på samme måde som SMEIL har. de har en historisk afhængighed ift. SME og CSP.

% %%%% SMEIL buses and channels %%%%
In SMEIL a bus are used as the glue between the processes to connect them into a network. The bus are used for communication between the SME processes in the network and each bus consist of one or more channels. A channel is individually assigned a process and each channel have a type, however the same types does not have to apply to all channels in the same bus. All channels in a single bus is connected at the same time, but each process communicates on a single channel.
Buses may form many-to-many relationships between processes and thus creating a similar situation as consists in hardware buses with physical wires where several different components can be connected to the same physical wire.
% TODO: Figure out if I should introduce the basics of SMEIL like examples of buses declarations etc.

In SMEIL a bus is simply a shell that contains channels. It does not have a type or values, it contains channels which each has a name, type and values etc. Each bus in SMEIL does have an identifier and this is used to reference the specific bus.
Since a bus is connected with all channels at the same time, the processes of SMEIL does not receive the channel as input parameter, but the bus itself. It is then up to the body of the process to call the correct channel in the input bus so to get the content that was communicated on the specific channel.

\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
bus day {
    hours:   u5 range 0 to 23;
    minutes: u6 range 0 to 59;
    seconds: u6 range 0 to 59;
};
\end{minted}

A bus can also be defined with the keyword \texttt{exposed} which indicated that the bus is used to external interactions either through co-simulation or as the top-level entity of the generated VHDL code. None of these two posssible usecases are currently implemented in TAPS, and thus the keyword \texttt{exposed} will cause an error in the transpiler. %TODO: Will it cause an error? And should I add more info to this?


% TODO: Maybe add something here about outbus bus/channels and how they are defined and called.

% TODO: Show an example of a SMEIL bus and channels


% %%%% SMEIL Channels %%%%%
A bus channel in SMEIL is declared with an identifier and a type which represents the data the bus channel will be communicating. The bus channel can also be declared with a predefined expression, fx. %TODO: Give an example here.
and an optional range of values of the type of the bus channel.
Each channel
% TODO: Add an example where a process calls the channel in the input bus. Also create an example where the bus is not defined with channels.

% %%%% CSPm channels %%%%
In \cspm all communication goes through a channel, thus there are no shell around the channels like in SMEIL.
Channels in \cspm %TODO: something about communicating values and ranges and types
Channels in \cspm are global namespace %TODO: Is that what it is called?

% TODO: Write something about CSPm channels


% %%%% Input bus have more than one channel

% %%%% Bus only defined as parameter
If the (output?) bus is not defined with channels, as can be seen in figure x,
% TODO: Create reference to the figure created above
the process still needs to reference that specific channel in the bus. It is not possible in SMEIL to call a bus without a channel. So when the bus is called, as long as the channel called match what has been defined as channels for that specific bus, then all is good. The translation of this should be rather simple, since all buses consists of channels, all channels should be possible to translate directly to \cspm channels.
% %%%% Channel names
The difficult part of translating SMEIL channels to \cspm channels will be to be sure that the naming is unique. In SMEIL the names of the channels are local to the bus, but in \cspm all channels are global. Therefore the naming of the channels needs to be unique and then all references to the channels in SMEIL should be possible to reuse with the \cspm channel naming.
% TODO: write something about adding the range of the channel to \cspm


%% What to do if there is several channels in one bus that acts as an input bus for a process.
In SMEIL each bus can consist of several different channels. When accessing the communicated values, the process have to refer to the specific bus and the specific channel name. In \cspm all communications are done with channels. The translation between SMEIL buses and \cspm channels should be straightforward, since channels is a subset of buses in SMEIL and therefore a bus with two channels would be the same as two buses with one channel. However, when defining the input for the proceses in SMEIL, only the bus name is used and therefore the transpiling will have to be able to recognize which channels belongs to which bus in order to give the correct channels as input for the \cspm processes.



% %%%% SMEIL processes communication %%%%
In the SMEIL process parameters, the input bus will be declared as well as any constants that the process will be initialised with. The output bus can also be given in the process parameters, but in that instance it will also have to be declared somewhere else in the program
%TODO: Make sure this is correct - ask Truls
Another way to declare the output bus, is by not having it in the process parameters, but declare it in the process declarations.
A full declaration of a bus consist, as mentioned above, of an identifier, the channels and their types and values.

A process receives input communication by accessing a specific channel of the input bus. The process can then make calculations based on the input and then communicate the result out of the process by assigning the result to a specific channel of the output bus.
%TODO: Add example of an input bus and getting information?





% %%%% SMEIL network %%%%
% TODO: Add an example of an SMEIL network
The network in an SMEIL program is the crucial part which ties all the processes and communication together. In the network buses or instances of processes are defined as well as the input and output for those proceses. In order to generate a correct network in \cspm the translation of the SMEIL network is crucial.
% TODO: Write more about the SMEIL network
% %%%% SMEIL instances %%%%
% TODO: Write about the SMEIL instances here
% %%%% CSPm network %%%%
In \cspm there is also a structure that is similar to the network structure in SMEIL. When synchronizing processes together with channels in a new process in \cspm we create the structure of what channels each process communicates on, and therefore which processes communicate to which processes.
% TODO: Add more about cspm syncronisation and here above
% TODO: Change this last sentence to not sound like design (Above)
This translation step will require carefully planning in order to get all the information for each part, in the correct position of one another. In SMEIL buses can also be declared in the network declaration but.. %TODO: ...currently the system does not handle other than pure SMEIL programs and therefore we do not need to handle if these buses are not both an input and output bus in some processes.

% TODO: Write about two networks and how it will be translated to a network and therefore we should be able to have them seperated easily and the communication is what combines them, and that is the same in cspm. TODO: But ask Truls if this would even make sense. To have to networks.


% TODO: Write about instances before this part below
% TODO: Write about how one process can be defined in SMEIL several times and how it does not matter, since the process will be defined the same in CSPm but that the network will simply be generated twice with two different names and inputs or similar. (Does that also work if it is different output?)
In SMEIL the networks of the system are constructed by a series of entities and these entities are connected by bus communication. For each instance, the process and communication will be declared and thus, connecting the network. SMEIL also have the great advantage that it is possible to have several instances of the same process with different parameters. This means that a process defined in the network can be instantiated several times, with differen parameters and thereby reusing code, without having to create the process once again. Since the network structure, as mentioned above, is created by syncronizing processes together with channels in \cspm, having several different instances of the same process should not prove to be difficult, however it is evident that TAPS keep the information about each instance of each process seperate so that no information is lost in the translation.




%% I cannot assume that the output bus is defined in a busdeclaration in the process
In an SMEIL, each process can have any number and combinations of input buses, output buses and constant parameters and since SMEIL have been created so that the creation of a circuit gives the most flexibility, we have to handle several different ways of defining these in \cspm.
Process input buses can be defined in the parameter when defining the process or the communication can be created by directly using the buses through their hierarchical names %TODO: reference truls master page 20

Process output buses can be defined the same as input buses; as a parameter in the process or by using the hierarchical names of the buses. It is also possible not to have the output bus defined in the parameters but to have a bus declaration inside the process description.
% TODO: Might need to go in structure section



Constants can also be defined as a parameter and as a constant declaration within the process description. %TODO: Find out more about constants. are we interested in them, then I need to write more, otherwise I can close this part early.
When transpiling to \cspm there is a need for the transpiler to be able to recognize all different ways of defining buses and constants within the SMEIL program.

\subsection{Meta}
% - Opserverede værdier - "known limits". Meta information i SMEIL, og det skal oversættes til faktiske processer med faktiske semantic i FDR der også er en del af topologien. (Det er essensen for mig).

In the process description in SMEIL, the channels of a bus are defined as well as the types and observed values for these channels. This data is the crucial data to gather in order for FDR4 to be able to verify the values communicated on the channels. In SMEIL it is simply data that is used when simulating the program or if translated to VHDL
%TODO it is VHDL right?
. The circuit does not need to know exactly what values are communicated or what type that is.


% %%%% Monitor processes %%%%%
When verifying attributes(?) in FDR4, we need some specifics to verify on. One scenario is that we want to verify that no values are communicated on a channel, that does not lie within the expected range. In this case we will have to get the correct data from the SMEIL program and handle them in a way that gives FDR4 something to verify.
% TODO: Maybe write something about getting the ranges and thereby we should simulate or the programmer should annotate the code herself. I have already added some stuff about this in the design part
