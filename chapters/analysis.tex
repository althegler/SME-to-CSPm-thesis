%!TEX root = ../main.tex

% This section should contain information about the problem, but not the solution. I am analysing the problem and explaining what will be problematic when translating from SMEIL to CSPm.

% Der er tre dele i SMEIL jeg har interesse i:
% Three components: Behavioral, structural, meta data

% Jeg skal ikke fortælle hvordan jeg har gjort det men analyse af problemet og ikke af løsningen. Jeg skal blot beskrive problemstillingerne.
In this section we analyse the differences between the SMEIL model and the functionality of \cspm. We also introduce important parts of the SMEIL structure and grammar in order to give reference points.

\section{Transpiling SMEIL to \cspm{}} \label{sec:transpiling}
When transpiling from source to source the difficult part is to understand the structure of each language and to understand how to translate structures from one language to the other without losing functionality but still maintaining the structure of each language.\\
When transpiling from SMEIL to \cspm{} the goal is to find a method for transpiling, that can be generalized to most problems. We have worked on separation of concerns in order to simplify, but also to have a greater chance of being able to match more SMEIL programs.

From the introduction to both SMEIL and \cspm it is clear that the main intention of each language is different and therefore the transpiling of a process in SMEIL to a \cspm process might not be completely trivial. All data from the SMEIL process will need to be translated into data and structures within the \cspm model, calculations and communications alike.

% TODO: Something about functional language to imperative language


% Vigtigt at have de tre dele adskilt i afsnittet. Brug figuren fra side 107 i bujo til at henvise til at jeg har en Magic 8-ball (Mit system) og jeg skal fra SMEIL til FDR og henvise til at det er det flow jeg har brug for.


% I SMEIL har jeg et prædefineret konsistent navnerum. Jeg skal ikke lave en symboltabel. Jeg arver direkte fra SMEIL til CSPm. Så her kan jeg snakke om at hvis jeg gjorde det på en anden måde ville jeg ikke kunne gøre det sådan. Det skal jeg skrive om her. TODO: Make a decision about where this belongs. It does not seem to be fitting in with the analysis, but on the other hand this was what Brian told me. But is he right?


When analysing the general structure of SMEIL programs, there are three structures that are particular interesting when we are interested in translating from SMEIL to \cspm{}. These three structures are:
\begin{enumerate}
    \item \textbf{Behavioral:} The general behavior of each process and function.
    \item \textbf{Structural:} How the circuit is connected, i.e which buses connects to which processes.
    \item \textbf{Meta information/Observed values} %TODO: Meta information or observed values?:
    The information that are meta information but provides an understanding of what data flows through the network.
\end{enumerate}

% TODO: Should I add the clock problem to the list, so it becomes four parts?

\subsection{Behavioral}
%% - Behavioral description - hvad den enkelte funktion gør. det oversættes ret nemt. Jeg bekymre mig ikke om variable og sådan nogle ting. Det er allerede gjort før det gøres til SMEIL, og dem kan jeg genbruge i min code generation.  Funktionel indhold af processer/ opførsel af den enkelte process - det er rimelig nemt oversat direkte til CSPm. Her kan man beskrive hvis der er nogle sproglige udfordringer, fx hvis CSPm ikke har loops eller lign.
The behaviour of the single process and functions in the SMEIL program is what give the SMEIL program its functionality. Each process have a single function but together they build the functionality of the program. By analysing the different structures and ways to build functions and processes in SMEIL, we can get a sense of how it should be created in \cspm.
% TODO: is it even possible to have functions in SMEIL?

\subsubsection{Processes}
% TODO: Maybe I only need to introduce SMEIL stuff that TAPS support?

% %%%% SMEIL processes %%%%
A SMEIL process is defined by the \texttt{proc} keyword and consists of an identifier, process parameters, bus and variable declarations as well as the process statements which consists of sequential statements such as communications and calculations that are to be evaluated once for each clock cycle.
It is not possible to declare variables in the process statements and therefore all variable and communications are declared in the declarative part of the process. This attribute should simplify the translation to \cspm, since TAPS will only have to search the declarative part of the process to find all variable and bus definitions.
A process can be instantiated with a set of parameters. These parameters can be a mix of input and output buses and constants. A process is initiated in the network of a SMEIL program which will be explained later.

In the SMEIL grammar, it is possible to declare if the process is \texttt{sync} or \texttt{async}. A \texttt{sync} process are run during each clock cycle, and a \texttt{async} process are only run when they receive a signal on the input bus. The current implementation of SMEIL does not support \texttt{async} processes, which means that the translation to \cspm should be able to handle at least \texttt{sync} processes, but preferably both cases. Since \cspm does not support clock cycles, it is important to figure out how to simulate the same results in \cspm without having a designated clock.
% TODO: Should I write more here, or am I introducing the clock problem somewhere else?
\\

In an SMEIL process, the declarative part of the process can consists of different variables and constants. Here we shortly introduce these.
\paragraph{Constants}
Constants are used when declaring named constant values and consists of an identifier, a type and an optional expression. The expression could be simply an integer assigned to the constant, for instance:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
const hours: uint = 24;
\end{minted}
Due to the unification in SMEIL, constants should always be declared as unconstrained types, and the compiler will emit a warning for contrained types such as \texttt{u5}. %TODO: Shoudl I keep this or does this not matter?
Variables are very similar to constants but simply hold mutable values within the process. %TODO: Is it important to know that the state of variables in SMEIL persists between clock cycles?
\paragraph{Variables}
When declaring a variable in SMEIL, the only difference between variable and constants are that variables can also take a range of values, for example:
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
var minutes: u6 = 0 range 0 to 59;
\end{minted}
The assignment of \texttt{= 0} is simply to give an initial value of the variable, but can be omitted, as well as the ranges. The range are used to give an expected value range of the variable and is used to calculate the bit size required of the variable type.
% TODO: I need to introduce the simulation part, but do I add it here or somewhere else?

In SMEIL, the types of variable and constants must always be defined and this also applies to bus channel declaration. The types can be of either unlimited size integers, \texttt{int} and \texttt{uint},  or restricted to a specific bit-length. The prefixes \texttt{i} and \texttt{u} refers to signed and unsigned integers which with a number following the prefix, restricts the integer to a bit-length. For instance, \texttt{i4} represents a signed 4-bit integer.
The unlimited bit size \texttt{int} and \texttt{uint} are not realistic to have in \cspm, since when verifying a program, FDR4 will look at the entire possible statespace, and with unlimited integers, the statespace will be enormous. FDR4 restricts its integer types to signed 32-bit\cite{UniversityofOxford}, but this might still leave the verification taking an unrealistic amount of time to finish. \cspm does not apply types to its variables and constants the same way as SMEIL and therefore the types might be irrelevant in the translation. It might also prove to be a necessary meta information for the verification of the model.
\\

In \cspm, constant can be declared as we know it from many other languages;
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
N = 5
\end{minted}
and variables can be used without declaring them first, for example
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
Proc(x) =
    let
        m = x % 60
    within
        channel ! m -> SKIP
\end{minted}

Translating constants and variables from SMEIL to \cspm should not prove difficult, since the structures are quite similar.
A potential challenge is to determine the value of a constant or variable that has not been declared with either range or initial value. So the translation of ranges and types, both in constants and variables might provide some challenges, and it important to explore if these data are even necessary within the generated \cspm program.
\paragraph{Enumerations}
In SMEIL it is also possible to declare enumerations within a process or a network declaration. Emumerations can be used to referencing symbolic constants instead of its numerical constants which can improve the readability of the program.
Currently enumerations are not implemented in TAPS.
% TODO: Enummerations are not implemented in TAPS, so should I even write about it here?


% TODO: Should I say something about Generators?
% \paragraph{Generators}
% SMEIL does not support this, so I also wont support this and therefore I might not need this paragraph. It is however interesting because it is kind of a foor loop, but not because of the side effects but to simplyfy generation of code structures.


The other part of an SMEIL process is the statement part where the actual behaviour of the process is defined. The semantics of statements in SMEIL corresponds to what we typically see in C-like languages.

\paragraph{Assignments}
An assignment in SMEIL consists of a name and an expression. It can be used in two different ways within the SMEIL process statements; one is assigning to a variable and the other is assigning to a bus channel. In SMEIL the compiler will always be able to recognize what is being assigned by looking at the type of the object.
This property might cause problems when translating to \cspm, since channel communication and variable assignments are two different parts of the \cspm program. Thus TAPS will have to be able to recognize what type of assignment it is, in order to create the correct translation.
\paragraph{if-statements}
If-statements are structured like we know from other languages with an if-expression, then-expression, elif-expression and an else-expression.
These kinds of statements can also be defined in \cspm, but \cspm does not support elif-expressions within the if-statement, so the translation would have to restructure the elif-expression to a nested if-expression.
Since the structure of the \cspm process is different, an if-statement might have a different context in the \cspm program. It is possible that TAPS have to take extra precautions to provide the correct context to the if-statement.
% \paragraph{Loops}
% TODO: Write something here when I am sure how loops work in CSPm.

\paragraph{Traces and assertions}
The trace statement in SMEIL is not affecting the behaviour of the process, but it simply prints out the string and arguments that is given, like a printf.
In \cspm it is possible to add a print statement, but this will appear in the right hand side of the FDR4 session window for easy evaluation. Thus the print statements in SMEIL is not compatible with \cspm since strings are not what is evaluated in FDR4.\\\\
The assert statements are used internally in SMEIL and evaluated during program execution. If the assert statement is not valid, then the execution is halted and the error message, defined in the assert statement, is printed, for instance
\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
assert(hour < 23, "hours cannot be greater than 23");
\end{minted}
Even though we wish to assert properties in FDR4, the properties that FDR4 can verify are not similar to the properties that the assert statements in SMEIL are used for. Even if it was possible to verify the assert statements in FDR4, there would be no point in doing it, since the assertion result from FDR4 would be the same as the result from executing the SMEIL program.
% \paragraph{Switch statements}
% TODO: Write something about switch statements when I know more.

\paragraph{Expressions}
Expressions in SMEIL and their precedence rules are similar to C-like languages. Expressions are used for defining calculations, naming, function calls etc.\\
In \cspm the standard binary operators like \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and \texttt{\%} all take two arguments of type \texttt{Int} and return a value of type \texttt{Int}.
It is important to notice that in \cspm \texttt{/} returns the quotient and rounds towards negative infinity. The \texttt{\%} operator in \cspm returns the modulus.
Floating point number are, to our knowledge, not supported by FDR4\cite{Scattergood2011} which is also clear from the fact that the binary operators take only \texttt{Int} as their inputs. SMEIL is supposed to support floating point numbers, but due to the (See page 25 in truls thesis) % TODO: Finish this later when you know the extent of the support in SMEIL
The unary \texttt{-} operator, representing a negation of an integer and the unary \texttt{!} operator, representing logical negation are both represented in the FDR4 syntax.
The relational operators \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{==} and \texttt{!=} returns boolean values both in SMEIL and in \cspm.
The logical conjunction and disjunction operators \texttt{\&\&} and \texttt{||} are also represented in both SMEIL and \cspm and both only accepting boolean values.
The presedence of the above mentioned operators are not entirely identical acroos SMEIL and \cspm.
% TODO: Make sure that the precedence and binding strength are the same in SMEIL and CSPm

% TODO: Find out how many of the operators are actually possible to use in CSPm.
% \texttt{<<}, \texttt{>>}, \texttt{&}, \texttt{|}, \texttt{^}, \texttt{+}(identity), \texttt{~}(bitwise not),

% TODO: Write something about array types. Can we have that in CSPm?(Page 25 in truls master)

% TODO: write something about type unification rules. Can we have that in CSPm ?(Page 25 in truls master)

% TODO: Write something about SMEIL supporting strings, but not sure if CSPm really does that?

% %%%% CSPm processes %%%%
As mentioned above, processes in SMEIL can be defined with parameters which represents input and output buses as well as constants. In \cspm{} processes can also be defined with parameters that can be variables, channels or similar. However, processes in \cspm does not have the same functionality as a process in SMEIL. In SMEIL the process behaviour represents a part of the functionality of the network. In \cspm the processs behaviour also represents functionality, but the behaviour is often more focused on communicative behaviour between other processes. A typical process in \cspm could look like the one in Listing \ref{dining_philosopher_cspm} which represents a philosopher process from the problem of the dining philosophers from the example files on the FDR4 website. %TODO: Taken from the FDR4 website - how to represent this? Footnot or citation? ..  https://www.cs.ox.ac.uk/projects/fdr/manual/examples/index.html
The process behaviour shows a philosophers actions in communicating with other processes. As can be seen, the process also conduct some simple calculations, but the main structure consists of communication, which is the purpose of \cspm, to be able to verify communication between parallel processes.
\begin{listing}
\begin{minted}[escapeinside=||, mathescape=true]{cspm_lexer.py:CSPmLexer -x}
PHIL(i) = thinks.i -> sits!i -> picks!i!i -> picks!i!((i+1)%N) ->
          eats!i -> putsdown!i!((i+1)%N) -> putsdown!i!i -> getsup!i -> PHIL(i)

\end{minted}
\caption{A dining philosopher process from the FDR4 example file provided at the FDR4 webpage. https://www.cs.ox.ac.uk/projects/fdr/manual/examples/index.html acesses: 06/10/2018}
\label{dining_philosopher_cspm}
\end{listing}

The translation of processes from SMEIL to \cspm does have its challenges, but the structure of an SMEIL process is very general, and therefore the task is to find a way to structure the \cspm process in a way that gives the same functionality while still keep the \cspm communication behaviour and the assertion properties.

%% Translating variables directly because we expect errors or other things to have been handled before transpiling the code.
% When translating the process from SMEIL to \cspm we will be able to translate variables and calculations directly without having to translate the meaning of the it, since we are expecting SMEIL to handle behavioural errors.

\subsubsection{Generating data}
%%%%% Generator processes %%%%%
When writing pure SMEIL programs, there will always be a need to generate input for the network. If the program was not written as pure SMEIL, the input for the network would be provided by the surrounding code. But in the case of pure SMEIL, the input data must be generated which can be done in a few ways.
One way of initialising the network is by instantiating the processes with constants or internal values which then acts as the starting point of the processes. Another is to create a process which is only creating data for the network. We call this a data generator process.

%%% Generator processes - clock cycles
The transpiler must be able to handle all these different ways of generating data in different process structures and must ensure that the data used in the generated program, are representing all possible values from the SMEIL program.
% In \cspm it is not trivial to simulate clock cycles and if...
% TODO: Fix the stuff about clock cycles here.
\cspm is not able to simulate clock cycles and therefore all data communicated in the \cspm program will represent the clock cycles from the SMEIL representation.
%TODO: Remember to introduce the simulation of SMEIL somewhere and introduce ranges etc. so the clock cycle thing makes sense.
%TODO: Is this section too much design and not really analysis?
%TODO: Not sure if the clock cycle thing should be here or somewhere else.



------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\
------------------------------------------------------------------------------\\


%%% Generator processes - no input bus process.
A generator process in SMEIL can be constructed in several diffent ways, which can be seen in Figure %TODO: Add reference to figure of the different generator processs.
In some cases the process have no input bus, since it is instantiated with a value within the process, as in Figure %TODO: reference to specific figure part.
We can assume that all SMEIL processes with no input bus will be a data generator process of some kind, and therefore must have some outwards communication. %TODO: Can we really assume this? think about it once again.

%% Generator processes - input bus with const declared
It becomes a bit more tricky if the process have an input bus, because it is to receive data later on, but it also works as an instantiator, either by having a value defined in the process declaration %TODO: Is this possible? Fx. if clock() had an input bus but still generated the starting point.
or by having a constant as an input argument in the process parameters. In this case the transpiler will have to recognize the data generator process or the initial starting point of the network and generate the data of the network from that. %TODO: Add an example that shows a generator process without an input, where it is generated as in 7segexample, also a version like the addone example and others if I can come up with them.
%TODO: also add text that explain each of them
In \cspm it is not possible to create a loop which generates data. Since the purpose of \cspm or FDR4 is to look at all possible states of a system, a loop generating data would not make sense. Typically the data possible for the system are defined in channel definitions or initialized via a parameter for a process function, both types can be seen in Figure %TODO: Add figure with two types of data generation in \cspm. Fx. either Var(0) or channel X : 0.
Here it becomes crucial that the transpiler generates the data correctly so the system checks all possible values, but still keep the structure of the network intact, and therefore it might be necessary to seperate the data generation from the process in order to keep the process task intact.

%%% Generator processes - More than one process
In SMEIL it is possible to have more than one proces which generates data for the network. These processes can generate data in all the ways described above, and can be combined together in various ways. In the case of more than one generator process with no input bus, it should not be more complex to translate than the case with one single data generator process, since the processes task still only consist of generating data and communicating them via their outbus bus. The receiving process are declared in the SMEIL network structure and therefore as long as the transpiler generates the same network in \cspm, it will not matter wheather there are one or more data generator processes.
If the generator processes are part of the network as the process in x%TODO: Create a reference to an example like the one in AddOne, where the process is a generator process but still have a task to do afterwards.
then the translation will have to create the data without destroying the purpose of the process, %TODO: Write some more here when I know more. If having more than one generator process with an input bus, does not change the solution from having one generator process with an input bus, then write that, else write how to solve it if there are more than one and why it is different than having one generator process with input bus.




\subsection{Structural}
% - Strukturel information: hvilke proceser er der og hvilke buser er de limet sammen med. hvordan hænger tingene sammen. Det er også forholdsvis nemt fordi FDR har processer på samme måde som SMEIL har. de har en historisk afhængighed ift. SME og CSP.

% %%%% SMEIL buses and channels %%%%
In SMEIL a bus are used as the glue between the processes to connect them into a network. The bus are used for communication between the SME processes in the network and each bus consist of one or more channels. A channel is individually assigned a process and each channel have a type, however the same types does not have to apply to all channels in the same bus. All channels in a single bus is connected at the same time, but each process communicates on a single channel.
Buses may form many-to-many relationships between processes and thus creating a similar situation as consists in hardware buses with physical wires where several different components can be connected to the same physical wire.
% TODO: Figure out if I should introduce the basics of SMEIL like examples of buses declarations etc.

In SMEIL a bus is simply a shell that contains channels. It does not have a type or values, it contains channels which each has a name, type and values etc. Each bus in SMEIL does have an identifier and this is used to reference the specific bus.
Since a bus is connected with all channels at the same time, the processes of SMEIL does not receive the channel as input parameter, but the bus itself. It is then up to the body of the process to call the correct channel in the input bus so to get the content that was communicated on the specific channel.

\begin{minted}[linenos=false, escapeinside=||, mathescape=true]{smeil_lexer.py:SMEILLexer -x}
bus day {
    hours:   u5 range 0 to 23;
    minutes: u6 range 0 to 59;
    seconds: u6 range 0 to 59;
};
\end{minted}

A bus can also be defined with the keyword \texttt{exposed} which indicated that the bus is used to external interactions either through co-simulation or as the top-level entity of the generated VHDL code. None of these two posssible usecases are currently implemented in TAPS, and thus the keyword \texttt{exposed} will cause an error in the transpiler. %TODO: Will it cause an error? And should I add more info to this?


% TODO: Maybe add something here about outbus bus/channels and how they are defined and called.

% TODO: Show an example of a SMEIL bus and channels


% TODO: On page 26-27 in Truls master there is some interesting things about using a bus channel for either input or output and not both within the same process. Write something about that



% %%%% SMEIL Channels %%%%%
A bus channel in SMEIL is declared with an identifier and a type which represents the data the bus channel will be communicating. The bus channel can also be declared with a predefined expression, fx. %TODO: Give an example here.
and an optional range of values of the type of the bus channel.
Each channel
% TODO: Add an example where a process calls the channel in the input bus. Also create an example where the bus is not defined with channels.

% %%%% CSPm channels %%%%
In \cspm all communication goes through a channel, thus there are no shell around the channels like in SMEIL.
Channels in \cspm %TODO: something about communicating values and ranges and types
Channels in \cspm are global namespace %TODO: Is that what it is called?

% TODO: Write something about CSPm channels


% %%%% Input bus have more than one channel

% %%%% Bus only defined as parameter
If the (output?) bus is not defined with channels, as can be seen in figure x,
% TODO: Create reference to the figure created above
the process still needs to reference that specific channel in the bus. It is not possible in SMEIL to call a bus without a channel. So when the bus is called, as long as the channel called match what has been defined as channels for that specific bus, then all is good. The translation of this should be rather simple, since all buses consists of channels, all channels should be possible to translate directly to \cspm channels.
% %%%% Channel names
The difficult part of translating SMEIL channels to \cspm channels will be to be sure that the naming is unique. In SMEIL the names of the channels are local to the bus, but in \cspm all channels are global. Therefore the naming of the channels needs to be unique and then all references to the channels in SMEIL should be possible to reuse with the \cspm channel naming.
% TODO: write something about adding the range of the channel to \cspm


%% What to do if there is several channels in one bus that acts as an input bus for a process.
In SMEIL each bus can consist of several different channels. When accessing the communicated values, the process have to refer to the specific bus and the specific channel name. In \cspm all communications are done with channels. The translation between SMEIL buses and \cspm channels should be straightforward, since channels is a subset of buses in SMEIL and therefore a bus with two channels would be the same as two buses with one channel. However, when defining the input for the proceses in SMEIL, only the bus name is used and therefore the transpiling will have to be able to recognize which channels belongs to which bus in order to give the correct channels as input for the \cspm processes.



% %%%% SMEIL processes communication %%%%
In the SMEIL process parameters, the input bus will be declared as well as any constants that the process will be initialised with. The output bus can also be given in the process parameters, but in that instance it will also have to be declared somewhere else in the program
%TODO: Make sure this is correct - ask Truls
Another way to declare the output bus, is by not having it in the process parameters, but declare it in the process declarations.
A full declaration of a bus consist, as mentioned above, of an identifier, the channels and their types and values.

A process receives input communication by accessing a specific channel of the input bus. The process can then make calculations based on the input and then communicate the result out of the process by assigning the result to a specific channel of the output bus.
%TODO: Add example of an input bus and getting information?





% %%%% SMEIL network %%%%
% TODO: Add an example of an SMEIL network
The network in an SMEIL program is the crucial part which ties all the processes and communication together. In the network buses or instances of processes are defined as well as the input and output for those proceses. In order to generate a correct network in \cspm the translation of the SMEIL network is crucial.
% TODO: Write more about the SMEIL network
% %%%% SMEIL instances %%%%
% TODO: Write about the SMEIL instances here
% %%%% CSPm network %%%%
In \cspm there is also a structure that is similar to the network structure in SMEIL. When synchronizing processes together with channels in a new process in \cspm we create the structure of what channels each process communicates on, and therefore which processes communicate to which processes.
% TODO: Add more about cspm syncronisation and here above
% TODO: Change this last sentence to not sound like design (Above)
This translation step will require carefully planning in order to get all the information for each part, in the correct position of one another. In SMEIL buses can also be declared in the network declaration but.. %TODO: ...currently the system does not handle other than pure SMEIL programs and therefore we do not need to handle if these buses are not both an input and output bus in some processes.

% TODO: Write about two networks and how it will be translated to a network and therefore we should be able to have them seperated easily and the communication is what combines them, and that is the same in cspm. TODO: But ask Truls if this would even make sense. To have to networks.


% TODO: Write about instances before this part below
% TODO: Write about how one process can be defined in SMEIL several times and how it does not matter, since the process will be defined the same in CSPm but that the network will simply be generated twice with two different names and inputs or similar. (Does that also work if it is different output?)
In SMEIL the networks of the system are constructed by a series of entities and these entities are connected by bus communication. For each instance, the process and communication will be declared and thus, connecting the network. SMEIL also have the great advantage that it is possible to have several instances of the same process with different parameters. This means that a process defined in the network can be instantiated several times, with differen parameters and thereby reusing code, without having to create the process once again. Since the network structure, as mentioned above, is created by syncronizing processes together with channels in \cspm, having several different instances of the same process should not prove to be difficult, however it is evident that TAPS keep the information about each instance of each process seperate so that no information is lost in the translation.




%% I cannot assume that the output bus is defined in a busdeclaration in the process
In an SMEIL, each process can have any number and combinations of input buses, output buses and constant parameters and since SMEIL have been created so that the creation of a circuit gives the most flexibility, we have to handle several different ways of defining these in \cspm.
Process input buses can be defined in the parameter when defining the process or the communication can be created by directly using the buses through their hierarchical names %TODO: reference truls master page 20

Process output buses can be defined the same as input buses; as a parameter in the process or by using the hierarchical names of the buses. It is also possible not to have the output bus defined in the parameters but to have a bus declaration inside the process description.
% TODO: Might need to go in structure section



Constants can also be defined as a parameter and as a constant declaration within the process description. %TODO: Find out more about constants. are we interested in them, then I need to write more, otherwise I can close this part early.
When transpiling to \cspm there is a need for the transpiler to be able to recognize all different ways of defining buses and constants within the SMEIL program.

\subsection{Meta}
% - Opserverede værdier - "known limits". Meta information i SMEIL, og det skal oversættes til faktiske processer med faktiske semantic i FDR der også er en del af topologien. (Det er essensen for mig).

In the process description in SMEIL, the channels of a bus are defined as well as the types and observed values for these channels. This data is the crucial data to gather in order for FDR4 to be able to verify the values communicated on the channels. In SMEIL it is simply data that is used when simulating the program or if translated to VHDL
%TODO it is VHDL right?
. The circuit does not need to know exactly what values are communicated or what type that is.


% %%%% Monitor processes %%%%%
When verifying attributes(?) in FDR4, we need some specifics to verify on. One scenario is that we want to verify that no values are communicated on a channel, that does not lie within the expected range. In this case we will have to get the correct data from the SMEIL program and handle them in a way that gives FDR4 something to verify.
% TODO: Maybe write something about getting the ranges and thereby we should simulate or the programmer should annotate the code herself. I have already added some stuff about this in the design part
